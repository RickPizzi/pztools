#!/bin/bash
#
# MariaDB Backup Manager: a backup-tool-agnostic backup and restore script
#
# Please send bugs to pizzi@leopardus.com
#
#

# begin 

BM_VERSION="4.8.1"
CONFIGDIR=/etc/mariadb
CONFIGNAME=backup_manager.cnf
CONFIGFILE=$CONFIGDIR/$CONFIGNAME
DB=$CONFIGDIR/.backup_inventory.db
BOOTSTRAP_FILE=mysql/bckmgr_bootstrap.opt
BACKUP_LOCK_TIMEOUT=30
#
#

semaphore_setup()
{
	if [ $custom_config -eq 0 ]
        then
                if [ "$2" != "binlogs" ]
                then
                        [ $level -eq 0 ] && get_lock 1 || get_lock 0
                else
                        get_binlogs_lock
                fi
        	setup_trap $2
        else
                get_lock 1
                get_binlogs_lock wait
        	setup_trap custom
        fi
}

setup_trap()
{
	case "$1" in
		'binlogs')
        		trap 'rm -f $tmpfile $binlog_lockfile $error_log $aux_log $dbq_stderr $dumptail 2>/dev/null' 0
			;;
		'custom')
        		trap 'rm -f $tmpfile $lockfile $binlog_lockfile $error_log $aux_log $dbq_stderr $dumptail 2>/dev/null' 0
			;;
		'other')
        		trap 'rm -f $tmpfile $error_log $aux_log $dbq_stderr $dumptail 2>/dev/null' 0
			;;
		*)
        		trap 'rm -f $tmpfile $lockfile $error_log $aux_log $dbq_stderr $dumptail 2>/dev/null' 0
			;;
	esac
}

get_binlogs_lock()
{
	while true
	do
		[ ! -f $binlog_lockfile ] && break
		kill -0 $(cat $binlog_lockfile) 2>/dev/null
		[ $? -ne 0 ] && break
		if [ "$1" = "" ]
		then
			echo "Binlog or custom backup already in progress, skipping"
			exit 0
		fi
		sleep 1
	done
	echo $runtime_id > $binlog_lockfile
}

get_lock()
{
	if [ -f $lockfile ]
	then
		kill -0 $(cat $lockfile) 2>/dev/null
		if [ $? -eq 0 ]
		then	
			echo "Another backup is in progress, skipping this run."
			exit $1
		fi
	fi
	echo $runtime_id > $lockfile
}

safe_defaults()
{
	error_log=/tmp/bm.error.$$
	aux_log=/tmp/bm.aux.$$
	dumptail=/tmp/bm.dt.$$
	dbq_stderr=/tmp/dbq.stderr.$$
	tmpfile=/tmp/bm.tmp.$$
	parallelism=4
	port=3306
	dt_format="%Y-%m-%d"
	compressor="cat"
	encryptor="cat"
	uncompressor="cat"
	unencryptor="cat"
	reader="cat \$path"
	purge_incomplete=0
	expire_days=0
	smart_purge=0
	smart_purge_months=6
	master_position=0
	min_disk_pfree=20
	galera=0
	runtime_id=$$
	restore_test=0
	timeout=0
	setup_repl_only=0
	enc_key_local=0
	kill_query_time=0
	status=0
	level=0
	expire_days=7
        [ "$(which less 2>/dev/null)" != "" ] && pager="less -em -Pm--more--"  || pager="cat"
	perldoc=0
        [ "$(which perldoc 2>/dev/null)" != "" ] && perldoc=1
	point_in_time=0
	set_maintenance=0
	ignore_errors=0
	master_slave=0
	skip_notification=0
	custom_config=0
	server_path="/usr/sbin/mysqld"
	cloud_storage=0
	local_remote="eval"
}

setup_db()
{
	[ "$BM_BACKUP_INVENTORY" != "" ] && DB=$BM_BACKUP_INVENTORY
	setup_sqlite_db
}

setup_sqlite_db()
{
	if [ "$(which sqlite3 2>/dev/null)" = "" ]
	then
		echo "This script requires the sqlite3 package. Please install it."
		exit 1
	fi
	if [ "$(which curl 2>/dev/null)" = "" ]
	then
		echo "This script requires the curl package. Please install it."
		exit 1
	fi
	if  [ ! -f $DB ]
	then
		(
		echo "CREATE TABLE backup_history ("
  		echo "uuid varchar(40) NOT NULL,"
		echo "runtime_id int DEFAULT NULL,"
  		echo "start_time timestamp NULL DEFAULT NULL,"
  		echo "end_time timestamp NULL DEFAULT NULL,"
  		echo "bulocation varchar(255) DEFAULT NULL,"
  		echo "logfile varchar(255) DEFAULT NULL,"
  		echo "status tinyint DEFAULT NULL,"
  		echo "level tinyint DEFAULT NULL,"
  		echo "compressor varchar(40) DEFAULT NULL,"
  		echo "uncompressor varchar(40) DEFAULT NULL,"
  		echo "encryptor varchar(40) DEFAULT NULL,"
  		echo "unencryptor varchar(40) DEFAULT NULL,"
  		echo "cryptkey varchar(255) DEFAULT NULL,"
  		echo "last_lsn bigint DEFAULT NULL,"
  		echo "backup_tool varchar(120) DEFAULT NULL,"
  		echo "server_version varchar(50) DEFAULT NULL,"
  		echo "backup_size bigint  DEFAULT NULL,"
  		echo "ref_full_backup varchar(40) DEFAULT NULL,"
  		echo "xid bigint DEFAULT NULL,"
  		echo "dumplist varchar(2000) DEFAULT NULL,"
  		echo "kubernetes_pod varchar(64) DEFAULT NULL,"
  		echo "kubernetes_bucket varchar(255) DEFAULT NULL,"
  		echo "kubernetes_db varchar(64) DEFAULT NULL,"
  		echo "checkpoint varchar(64) DEFAULT NULL,"
		echo "binlog_file varchar(64) DEFAULT NULL,"
		echo "binlog_position varchar(64) DEFAULT NULL,"
		echo "binlog_first varchar(64) DEFAULT NULL,"
		echo "binlog_last varchar(64) DEFAULT NULL,"
  		echo "binlog_last_ts timestamp NULL DEFAULT NULL,"
		echo "kubernetes_bucket_id varchar(64) DEFAULT NULL,"
		echo "kubernetes_bucket_secret varchar(64) DEFAULT NULL,"
  		echo "level13_alert tinyint DEFAULT NULL,"
		echo "gtid_binlog_pos varchar(128) DEFAULT NULL,"
  		echo "datadir_size bigint DEFAULT NULL,"
		echo "case_insensitive tinyint DEFAULT NULL,"
  		echo "PRIMARY KEY (uuid),"
  		echo "FOREIGN KEY (ref_full_backup) REFERENCES backup_history(uuid) ON DELETE CASCADE);"
		echo "CREATE INDEX start_time ON backup_history(start_time);"
		echo "CREATE INDEX ref_full ON backup_history(ref_full_backup);"
		echo "CREATE INDEX incremental_check on backup_history(backup_tool, level, status);"
		echo "CREATE INDEX binlog_last_ts ON backup_history(binlog_last_ts);"
		) | dbquery $DB
	else
		patch_sqlite_db $DB
	fi
}

patch_sqlite_db()
{
	rev=$(echo "PRAGMA table_info(backup_history);" | dbquery $1 | tail -1 | cut -d "|" -f 1)
	case "$rev" in
		'17') 	echo "ALTER TABLE backup_history ADD COLUMN xid bigint DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'18') 	echo "ALTER TABLE backup_history ADD COLUMN dumplist varchar(2000) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN kubernetes_pod varchar(64) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN kubernetes_bucket varchar(256) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN kubernetes_db varchar(64) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN checkpoint varchar(64) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'23') 	echo "ALTER TABLE backup_history ADD COLUMN binlog_file varchar(64) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'24') 	echo "ALTER TABLE backup_history ADD COLUMN binlog_position varchar(16) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'25') 	echo "ALTER TABLE backup_history ADD COLUMN binlog_first varchar(16) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN binlog_last varchar(16) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'27') 	echo "ALTER TABLE backup_history ADD COLUMN binlog_last_ts timestamp DEFAULT NULL;" | dbquery $1
			echo "CREATE INDEX binlog_last_ts ON backup_history(binlog_last_ts);" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'28') 	echo "ALTER TABLE backup_history ADD COLUMN kubernetes_bucket_id varchar(64) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN kubernetes_bucket_secret varchar(64) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'30') 	echo "ALTER TABLE backup_history ADD COLUMN level13_alert tinyint DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'31') 	echo "ALTER TABLE backup_history ADD COLUMN gtid_binlog_pos varchar(128) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'32') 	echo "ALTER TABLE backup_history ADD COLUMN datadir_size bigint DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'33') 	echo "ALTER TABLE backup_history ADD COLUMN case_insensitive tinyint DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
	esac
}

clean_exit()
{
	[ "$what" = "backup" ] && echo "delete from backup_history where uuid = '$backup_id';" | dbquery $DB
	exit $1
}

curl_before()
{
	[ "$url_before" != "" ] && curl --output - --insecure --silent --connect-timeout 10  "$url_before" > $tt/callout_before.log 2>&1
}

curl_after()
{
	[ "$url_after" != "" ] && curl --output - --insecure --silent --connect-timeout 10  "$url_after" > $tt/callout_after.log 2>&1
}

check_free_space()
{
	if [ $disk_space_p_avail -eq 0 ]
	then
		echo "ERROR: filesystem is full for target directory $target."
		msg="Filesystem for backup target directory is full. Exiting."
		echo $msg
		[ "$failure_notify" != "" ] && echo $msg | send_mail "$customer: backup FAILED" $failure_notify
		status=1; fire_webhook
		exit 1
	fi
	if [ $level -eq 0 -a $disk_space_p_avail -lt $min_disk_pfree ]
	then
		echo "ERROR: Not enough free space on target directory $target."
		msg="Filesystem has $disk_space_p_avail% ($disk_space_avail) free, but $min_disk_pfree% is required. Exiting."
		echo $msg
		[ "$failure_notify" != "" ] && echo $msg | send_mail "$customer: backup FAILED" $failure_notify
		status=1; fire_webhook
		exit 1
	fi
}

email_notification()
{
	[ -t 0 ] && return
	[ $skip_notification -eq 1 ] && return
	if [ "$failure_notify" != "" ]
	then
		if [ $status -eq 1 ]
		then
			echo "Backup failed, please run 'backup_manager logs $backup_id' for details" | send_mail "$customer: backup FAILED" $failure_notify
		else
			[ "$success_notify" != "" -a $level -eq 0 ] && inventory pretty | send_mail "$customer: backup SUCCESSFUL" $success_notify
		fi
	fi
}

run_with_timeout()
{
	pid=$(jobs -p)
	if [ $timeout -eq 0  ]
	then
		wait $pid
		status=$?
		return
	fi
	echo "NOTICE: backup_timeout in effect, timeout ${timeout}m, controller id $pid"
	countdown=$((timeout*12+1))
	while true
	do
		kill -0 $pid 2>/dev/null || break	
		countdown=$((countdown-1))
		[ $countdown -eq 0 ] && break
		sleep 5
	done
	if [ $countdown -eq 0 ]
	then
		echo "ERROR: Backup timed out. Killing it."
		pkill -9 -P $pid
		echo "Backup killed due to timeout." >> $logfile
		status=1
	else
		wait $pid
		status=$?
	fi
}

scan_binlog_archive()
{
	echo -n "scanning binlog archive.."
	for bf in $(ls $bxfolder)
	do
	#t=$(mysqlbinlog --no-defaults $bf | fgrep -m 1 "Start: binlog" | sed -re "s/^#([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)\s+([0-9 ]*):([0-9]*):([0-9]*) server (.*)$/20\1\2-\3\4-\5\6 \7:\8:\9/" -e "s/( )([0-9]:)/ 0\2/")
	t=$(cat $bf | $ssh $mysqlbinlog --no-defaults - | fgrep -m 1 "Start: binlog" | sed -re "s/^#([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)\s+([0-9 ]*):([0-9]*):([0-9]*) server (.*)$/20\1\2-\3\4-\5\6 \7:\8:\9/" -e "s/( )([0-9]:)/ 0\2/")
		if [ "$(echo "select '$t' > '$requested_binlog_ts';" | dbquery $DB)" = "1" ]
		then 
			last_b=$prev_bf
			scan_complete=1
			echo
			return
		fi
		prev_bf=$bf
		echo -n "."
	done
	echo
}

# set bxfolder before calling
apply_binlogs()
{
	bf_start_file=$(echo "select binlog_file from backup_history where uuid = '$binlogs_starting_point';" | dbquery $DB)
	bf_start_pos=$(echo "select binlog_position from backup_history where uuid = '$binlogs_starting_point';" | dbquery $DB)
	bf_start_ts=$(echo "select binlog_last_ts from backup_history where uuid = '$binlogs_starting_point';" | dbquery $DB)
	[ "$bf_start_file" = "$requested_binlog_file" -a "$bf_start_pos" = "$requested_binlog_position" ] && return 0
	[ "$bf_start_ts" = "$requested_binlog_ts" ] && return 0
	bf_parent=$(echo "select ref_full_backup from backup_history where uuid = '$binlogs_starting_point';" | dbquery $DB)
	[ "$bf_parent" = "" ] && bf_parent=$binlogs_starting_point
	case_insens=$(echo "select case_insensitive from backup_history where uuid = '$bf_parent';" | dbquery $DB)
	if [ "$requested_binlog_ts" != "" ]
	then
		echo "Now applying binary logs for all events having timestamp < '$requested_binlog_ts'"
	else
		echo "Now applying binary logs up to: file $requested_binlog_file, position $requested_binlog_position"
		requested_binlog_ts="2038-01-19 03:14:07"
	fi
	initial_bf_done=0
	scan_complete=0
	echo "Inital position for binlogs: file $bf_start_file, position $bf_start_pos"
	mariadb_instance start
	if [ $? -ne 0 ]
	then
		echo "ERROR: unable to start MariaDB auxiliary instance. More info: $target/backup_manager_mysqld.err"
		echo "Aborting restore."
		return 1
	fi
	[ ! -d $bxfolder ] && mkdir $bxfolder
	cd $bxfolder
	wanted_seqno=${bf_start_file:(-6)}
        scan_start=$(echo "select start_time from backup_history where uuid = '$uuid';" | dbquery $DB)
        for bp in $(echo "select uuid from backup_history where backup_tool = 'binlogs' and ref_full_backup = '$bf_parent' and start_time > '$scan_start' order by start_time asc;" | dbquery $DB)
	do
		last_seqno=$(echo "select substr(binlog_last, -6) from backup_history where uuid = '$bp';" | dbquery $DB)
		[ $last_seqno -lt $wanted_seqno ] && continue
		echo "extracting binlog backup $bp"
		extract_binlog_piece $bp  || return 1
		[ $scan_complete -eq 1 ] && break
		[ "$bp" = "$target_binlog_backup_id" ] && break
		[ "$last_file" != "" ] && break
		current_position $bp
	done
	mariadb_instance stop
	cd /tmp
	rmdir $bxfolder
	return 0
}

pit_input_error()
{
	echo "ERROR: '$1': not a valid point-in-time specification."
	echo "accepted formats: timestamp ('YYYY-MM-DD HH:MM:SS') or position (binlogfile:position)"
	exit 1
}

pit_dry_run()
{       
        if [ "$2" = "" ]
        then    
                echo "usage: $0 validate-pit <backupid> <point-in-time>"
                exit 1
        fi
        uuid=$(echo "select uuid from backup_history where uuid = '$1';" | dbquery $DB)
        if [ "$uuid" = "" ]
        then    
                echo "ERROR: backup $1 not found in inventory."
                exit 1
        fi
        validate_point_in_time "$2" dontask
        exit 0
}


validate_point_in_time()
{
	if [ "$(echo "select datetime('$1') = '${1/T/ }';" | dbquery $DB)" = "1" ]
	then
		requested_binlog_ts="${1/T/ }"
	else
		IFS=":"
		posarr=($1)
		[ ${#posarr[@]} -ne 2 ] && pit_input_error "$1"
		requested_binlog_file=${posarr[0]}
		requested_binlog_position=${posarr[1]}
		unset IFS
		echo "$requested_binlog_file" | grep -qE "^[-0-9a-z\.]+$"  || pit_input_error "$1"
		echo "$requested_binlog_position" | grep -qE "^[0-9]+$" || pit_input_error "$1"
	fi
	mysqlbinlog=$($ssh which mysqlbinlog 2>/dev/null)
	if [ "$mysqlbinlog" = "" ]
	then
		echo "ERROR: mysqlbinlog program not installed, cannot restore to point-in-time. Exiting."
		exit 1
	fi
	check_pit_availability
	if [ "$target_binlog_backup_id" = "" ]
	then
		echo "ERROR: requested point-in-time not available in the specified full backup."
		echo "Please run \"backup_manager inventory binlogs\" to verify if another backup has it."
		exit 1
	fi
	echo -n "Point-in-time recovery requested: "
	if [ "$requested_binlog_ts" = "" ]
	then
		echo "file $requested_binlog_file, position $requested_binlog_position"
	else
		echo "'$requested_binlog_ts'"
	fi
	echo "Requested point-in-time found in backup piece $target_binlog_backup_id."
	[ "$2" = "" ] && confirm_operation
	[ "$target_binlog_backup_id" != "$uuid" ] && point_in_time=1
}

pit_not_present()
{
	echo "ERROR: requested point-in-time not available in this backup."
	echo "You requested $requested_binlog_file:$requested_binlog_position and this backup starts with $bf:$bp."
	echo "Please select an older backup, or run without point-in-time recovery."
}

check_pit_availability()
{
	if [ "$requested_binlog_file" != "" ]
	then
		bf=$(echo "select binlog_file from backup_history where uuid = '$uuid';" | dbquery $DB)
		bp=$(echo "select binlog_position from backup_history where uuid = '$uuid';" | dbquery $DB)
		#echo "full $uuid: $bf:$bp"
		if [ "$bf" \> "$requested_binlog_file" ]
		then
			pit_not_present
			exit 1
		fi
		if [ "$bf" = "$requested_binlog_file" ]
		then
			if [ $bp -gt $requested_binlog_position ]
			then
				pit_not_present
				exit 1
			fi
		fi
		for bb_id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and backup_tool = 'binlogs' and status = 0 order by start_time asc;" | dbquery $DB)
		do
			bl=$(echo "select binlog_last from backup_history where uuid = '$bb_id';" | dbquery $DB)
			if [ "$bl" \> "$requested_binlog_file" -o "$bl" = "$requested_binlog_file" ]
			then
				target_binlog_backup_id=$bb_id
				return
			fi
		done
		for bb_id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and level = 1 and status = 0 order by start_time asc;" | dbquery $DB)
		do
			bl=$(echo "select binlog_file from backup_history where uuid = '$bb_id';" | dbquery $DB)
			if [ "$bl" \> "$requested_binlog_file" -o "$bl" = "$requested_binlog_file" ]
			then
				target_binlog_backup_id=$bb_id
				return
			fi
		done
	else
                blt=$(echo "select binlog_last_ts from backup_history where uuid = '$uuid';" | dbquery $DB)
		[ "$requested_binlog_ts" \< "$blt" ] && return
		if [ "$requested_binlog_ts" = "$blt" ]
		then
			target_binlog_backup_id=$uuid
			return
		fi
		 pt=$(echo "select uuid from backup_history where ((binlog_last_ts = '$requested_binlog_ts' and level in (0,1)) or (binlog_last_ts > '$requested_binlog_ts' and level = 3)) and status = 0 limit 1;" | dbquery $DB)
                ref=$(echo "select ref_full_backup from backup_history where uuid = '$pt';" | dbquery $DB)
		if [ "$ref" = "" ]
		then
			echo "ERROR: requested point-in-time not available in this backup."
                        exit 1
		fi
                if [ "$ref" != "$uuid" ]
                then
                        echo "ERROR: a more recent full backup exists for the requested point in time."
                        echo "In order to speed up your restore, please base it on backup id $ref."
                        exit 1
                fi
                target_binlog_backup_id=$pt
	fi
}

find_binlogs_backup_sp()
{
        last_binlog=$(echo "select binlog_file from backup_history where backup_tool = 'binlogs' and status=0 order by end_time desc limit 1;" | dbquery $DB)
	if [ "$last_binlog" = "" ]
	then
        	binlog_start=$(echo "select binlog_file from backup_history where uuid = '$1';" | dbquery $DB)
	else
		binlog_start=$last_binlog
	fi
}

send_mail()
{
	if [ $(mailx -V | fgrep -c GNU) -gt 0 ]
	then
		(
			echo "<PRE>"
			cat
			echo "</PRE>"
		) | mailx -s "$1" -a "Content-Type: text/html" $2
	else
		mailx -s "$1" $2
	fi
}

purge_incomplete()
{
	[ $purge_incomplete -eq 0 ] && return
	[ $status -eq 0 ] && return
	[ "$tt" = "" ] && return
	echo "purging incomplete backup"
	case "$tool" in
		'mariabackup'|'xtrabackup'|'mysqldump'|'smartdump') 
					rm -f $tt/$fn
					;;
		'mariaunpacked'|'mydumper') 
					mv $logfile $aux_log 2>/dev/null
					rm -rf $tt/*
					mv $aux_log $logfile 2>/dev/null
					;;
	esac
}

current_position()
{
	echo "select '(current position: ' || binlog_file || ':' || binlog_position || ', GTID: [' || gtid_binlog_pos || '], backup time: ' || binlog_last_ts || ')' from backup_history where uuid = '$1';" | dbquery $DB
}

incr_check_position()
{
	if [ $point_in_time -eq 1 ]
	then
		if [ "$requested_binlog_file" != "" ]
		then
			this_binlog_file=$(echo "select binlog_file from backup_history where uuid = '$id';" | dbquery $DB)
			[ "$this_binlog_file" \> "$requested_binlog_file" ] && return 0
			if [ "$this_binlog_file" = "$requested_binlog_file" ]
			then
				this_binlog_position=$(echo "select binlog_position from backup_history where uuid = '$id';" | dbquery $DB)
				[ $this_binlog_position -gt $requested_binlog_position ] && return 0
			fi
		else
			this_binlog_ts=$(echo "select binlog_last_ts from backup_history where uuid = '$id';" | dbquery $DB)
                        [ "$this_binlog_ts" \> "$requested_binlog_ts" ] && return 0
		fi
	fi
	return 1
}

yes_or_no()
{
	while true
	do
		read a
		case "$a" in
			'N'|'n') return 1;;
			'Y'|'y') return 0;;
			*) echo -n "Please enter Y or N: ";;
		esac
	done
}

confirm_operation()
{
	l=1
	while [ $l -eq 1 ]
	do
		echo -n "Confirm? y/N "
		read a
		case "$a" in
			'N'|'n'|'') echo "Never mind."; exit 1;;
			'Y'|'y') l=0;;
		esac
	done
}

print_latest()
{
	path=$(echo "select bulocation from backup_history where level = 0 and backup_tool in ('mariabackup','xtrabackup') and status = 0 order by start_time desc limit 1;" | dbquery $DB)
	if [ "$path" = "" ]
	then
		echo "no backups found."
		exit 1
	else
		echo $path
	fi
}

print_latest_id()
{
	id=$(echo "select uuid from backup_history where level = 0 and backup_tool in ('mariabackup','xtrabackup') and status = 0 order by start_time desc limit 1;" | dbquery $DB)
	if [ "$id" = "" ]
	then
		echo "no backups found."
		exit 1
	else
		echo $id
	fi
}

remove_files()
{
	for fn in $(echo "select bulocation || ' ' || logfile from backup_history where uuid = '$1';" | dbquery $DB)
	do
		rm -f $fn
	done
}

purge_incrementals()
{
	for ip in $(echo "select uuid from backup_history where ref_full_backup = '$1' and level=1;" | dbquery $DB)
	do
		remove_files $ip
		echo "delete from backup_history where uuid = '$ip';" | dbquery $DB
	done
}

smart_purge()
{
	keep=$(echo "select uuid || ',' || '0' from backup_history where start_time > date('now','-6 day') union select uuid || ',' || '1' from backup_history where start_time > date('now','-1 month', '-5 day') and strftime('%w', start_time)  = '0' union select uuid || ',' || '1' from backup_history where start_time > date('now','-$smart_purge_months month', '-1 month', '-6 day') and strftime('%w', start_time)  = '0' group by strftime('%m', start_time);" | dbquery $DB)
	echo -n "Purging backups using smart purge, keeping last $smart_purge_months months... "
	[ $dry -eq 1 ] && echo "(dry run)" || echo
	for fp in $(echo "select uuid from backup_history where level=0 order by start_time;" | dbquery $DB)
	do
		kf=$(echo "$keep" | fgrep $fp | head -1)
		pi=$(echo $kf | grep -c ",1$")
		if [ "$kf" != "" ]
		then
			[ $pi -eq 1 -a $dry -eq 0 ] && purge_incrementals $fp
			continue
		fi
		do_purge $fp
	done
}

do_purge()
{
	echo "purging $1"
	if [ $dry -eq 0 ]
	then
		if [ $cloud_storage -eq 0 ]
		then
			path=$(echo "select bulocation from backup_history where uuid = '$1';" | dbquery $DB)
			if [ -d $path ]
			then
				rm -rf $path
			else
				remove_files $1
			fi
			for ref_id in $(echo "select uuid from backup_history where ref_full_backup = '$1';" | dbquery $DB)
			do
				remove_files $ref_id
			done
			rmdir --ignore-fail-on-non-empty $(dirname $path)
			rmdir --ignore-fail-on-non-empty $(dirname $(dirname $path))
		fi
		(echo "PRAGMA foreign_keys=ON;"; echo "delete from backup_history where uuid = '$1';") | dbquery $DB
	fi
}

purge_backups()
{
	check_root purge
	if [ $expire_days -eq 0 -a $smart_purge -eq 0 ]
	then
		echo "purge is not properly configured."
		echo "please set either purge_days variable, or enable smart purge in config file."
		exit 1
	fi
	dry=0
	[ "$1" = "dry-run" -o "$1" = "dryrun" ] && dry=1
	if [ "$1" != "" -a $dry -eq 0 ]
	then
		if [ $(echo "select count(*) from backup_history where uuid = '$1';" | dbquery $DB) -eq 0 ]
		then
			echo "backup with id '$1' not found."
			exit 1
		fi
		echo "purging backup piece $1"
		path=$(echo "select bulocation from backup_history where uuid = '$1';" | dbquery $DB)
		if [ -d $path ]
		then
			rm -rf $path
		else
			remove_files $1
		fi
		echo "delete from backup_history where uuid = '$1';" | dbquery $DB
		return
	fi
	if [ $smart_purge -eq 1 ] 
	then
		smart_purge $1
		return
	fi
	echo -n "Purging backups older than $expire_days days... "
	[ $dry -eq 1 ] && echo "(dry run)" || echo
        [ -f $lockfile ] && r_id=$(cat $lockfile) || r_id=0
	for fp in $(echo "select uuid from backup_history where level in (0, 2, 3) and start_time < '$(date -d "today - $expire_days days" +%Y-%m-%d\ %T) and runtime_id <> $r_id order by start_time';" | dbquery $DB)
	do
		do_purge $fp
	done
}

check_home_config()
{
	if [ "$BM_CONFIG_FILE" != "" ]
	then
		CONFIGFILE=$BM_CONFIG_FILE
		return
	fi
	[ $(id -u) -eq 0 ] && return
	[ -f $HOME/$CONFIGNAME ] && CONFIGFILE=$HOME/$CONFIGNAME
}

self_doc()
{
	base64 -d << DOC_EOF | gzip -dc | sed -e "s/\$VERSION/v$BM_VERSION/" > /tmp/bmdoc.$$
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
o+rvJ/MFQ9xenPtj80XwU1RXwf8AEMnM2zZIAAA=
DOC_EOF
[ $perldoc -eq 1 ] && perldoc /tmp/bmdoc.$$ || $pager /tmp/bmdoc.$$
rm -f /tmp/bmdoc.$$
}

dbquery()
{
	dbq=$(cat)
	qtr=0
	while true
	do
		echo "$dbq" | sqlite3 $* 2>$dbq_stderr
		if [ -s $dbq_stderr ]
		then
			qtr=$((qtr+1))
			sleep $((RANDOM%5+1))
			[ $qtr -lt 10 ] && continue
			echo "ERROR: Unable to update inventory. Backup will proceed nonetheless."
			echo "$(date) inventory query \"$dbq\" failed with: $(cat $dbq_stderr)" >> /tmp/backup_manager.debug
		fi
		break
	done
}

inv_dbquery()
{
	sqlite3 -column -header $*
}

validate_table_name()
{
	ts_schema=${1%.*}
	ts_table=${1#*.}
	if [ "$ts_schema" = "" -o "$ts_table" = "" ]
	then
		echo "ERROR: invalid table name $3"
		exit 1
	fi
}
# end

inventory()
{
	sqlite_inventory $*
	rm -f $dbq_stderr 2>/dev/null
}

replication_info()
{
	rc=$(echo "select uuid || binlog_file from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$rc" = "" ] && return
	[ "$rc" = "$uuid" ] && echo "No replication info available for this backup" || echo "select 'Replication info for $1: position ' || binlog_file || ':' || binlog_position || ', GTID ' || ifnull(gtid_binlog_pos, 'N/A') from backup_history where uuid = '$1';" | dbquery $DB
}

backup_size()
{
	rc=$(echo "select datadir_size from backup_history where uuid = '$1';" | dbquery $DB)
	echo $rc
}

backup_time()
{
	rc=$(echo "select binlog_last_ts from backup_history where uuid = '$1';" | dbquery $DB)
	echo $rc
}

backup_type()
{
	rc=$(echo "select backup_tool from backup_history where uuid = '$1';" | dbquery $DB)
	echo $rc
}

parse_config()
{
	host="$BACKUP_HOST"
	port="$BACKUP_PORT"
	user="$BACKUP_USER"
	password="$BACKUP_PASSWORD"
	socket="$BACKUP_SOCKET"
	grep -q "^backup_host" $CONFIGFILE && host=$(grep "^backup_host" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^backup_port" $CONFIGFILE && port=$(grep "^backup_port" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^backup_user" $CONFIGFILE && user=$(grep "^backup_user" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^backup_password" $CONFIGFILE && password=$(grep "^backup_password" $CONFIGFILE | sed -re 's/([^=]*)=(.*)$/\2/')
	grep -q "^backup_socket" $CONFIGFILE && socket=$(grep "^backup_socket" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^target_directory" $CONFIGFILE && target=$(grep "^target_directory" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^compressor" $CONFIGFILE && compressor=$(grep "^compressor" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^uncompressor" $CONFIGFILE && uncompressor=$(grep "^uncompressor" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^encryptor" $CONFIGFILE && encryptor=$(grep "^encryptor" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^unencryptor" $CONFIGFILE && unencryptor=$(grep "^unencryptor" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^downloader" $CONFIGFILE && reader=$(grep "^downloader" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^purge_incomplete_backups" $CONFIGFILE && purge_incomplete=$(grep "^purge_incomplete_backups" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^expire_days" $CONFIGFILE && expire_days=$(grep "^expire_days" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^purge_days" $CONFIGFILE && expire_days=$(grep "^purge_days" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^smart_purge=" $CONFIGFILE && smart_purge=$(grep "^smart_purge=" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^smart_purge_months" $CONFIGFILE && smart_purge_months=$(grep "^smart_purge_months" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^customer" $CONFIGFILE && customer=$(grep "^customer" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^notify_label" $CONFIGFILE && customer=$(grep "^notify_label" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^parallelism" $CONFIGFILE && parallelism=$(grep "^parallelism" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^date_format" $CONFIGFILE && dt_format=$(grep "^date_format" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^failure_notify" $CONFIGFILE && failure_notify=$(grep "^failure_notify" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^success_notify" $CONFIGFILE && success_notify=$(grep "^success_notify" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^master_position" $CONFIGFILE && master_position=$(grep "^master_position" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^free_space_percentage" $CONFIGFILE && min_disk_pfree=$(grep "^free_space_percentage" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^callout_url_before" $CONFIGFILE && url_before=$(grep "^callout_url_before" $CONFIGFILE | sed -re 's/([^=]*)=(.*)$/\2/')
	grep -q "^callout_url_after" $CONFIGFILE && url_after=$(grep "^callout_url_after" $CONFIGFILE | sed -re 's/([^=]*)=(.*)$/\2/')
	grep -q "^galera_info" $CONFIGFILE && galera=$(grep "^galera_info" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^restore_test_directory" $CONFIGFILE && restore_test_dir=$(grep "^restore_test_directory" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^backup_timeout" $CONFIGFILE && timeout=$(grep "^backup_timeout" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^kill_query_time" $CONFIGFILE && kill_query_time=$(grep "^kill_query_time" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^open_files_limit" $CONFIGFILE && ulimit=$(grep "^open_files_limit" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^server_path" $CONFIGFILE && server_path=$(grep "^server_path" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^webhook_script" $CONFIGFILE && webhook_script=$(grep "^webhook_script" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^cloud_storage" $CONFIGFILE && cloud_storage=$(grep "^cloud_storage" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^heartbeat_schema" $CONFIGFILE && hb_schema=$(grep "^heartbeat_schema" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^heartbeat_table" $CONFIGFILE && hb_table=$(grep "^heartbeat_table" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^heartbeat_stale_seconds" $CONFIGFILE && hb_stale_secs=$(grep "^heartbeat_stale_seconds" $CONFIGFILE | cut -d"=" -f2)

	if [ "$1" = "backup" ]
	then
		if [ "$host" = "" -o "$user" = "" ]
		then
			echo "Please set backup_host and backup_user in $CONFIGFILE."
			exit 1
		fi
		if [ "$target" = "" ]
		then
			echo "Please set target_directory in $CONFIGFILE."
				exit 1
		fi
		if [ ! -d "$target" ]
		then
			echo "Target directory $target does not exist."
			exit 1
		fi
	fi
	if [ "$compressor" != "" ]
	then
		ct=$(which ${compressor/%\ */} 2>/dev/null)
		if [ "$ct" = "" ]
		then
			echo "You have configured ${compressor/%\ */}, please install it first."
			exit 1
		fi
	fi
	if [ "$encryptor" != "" ]
	then
		ct=$(which ${encryptor/%\ */} 2>/dev/null)
		if [ "$ct" = "" ]
		then
			echo "You have configured ${encryptor/%\ */}, please install it first."
			exit 1
		fi
		if [ "$(which openssl 2>/dev/null)" = "" ]
		then
			echo "ERROR: This script requires the openssl package. Please install it."
			exit 1
		fi
	fi
	[ "$BM_DOWNLOADER" != "" ] && reader=$BM_DOWNLOADER

	lockfile=/tmp/backup_manager.lock
	binlog_lockfile=/tmp/backup_manager_binlogs.lock
	if [ "$success_notify" != "" -a "$failure_notify" = "" ]
	then
		echo "NOTICE: 'failure_notify' not set in config, using email in 'success_notify' for failure notifications."
		failure_notify=$success_notify
	fi
	if [ "$failure_notify" != "" ]
	then
		mx=$(which mailx 2>/dev/null)
		if [ "$mx" = "" ]
		then
			echo "You have configured email notifications, please install the mailx utility."
			exit 1
		fi
		if [ "$customer" = "" ]
		then
			echo "You have configured email notifications, please configure customer name."
			exit 1
		fi
	fi

	if [ "$1" = "backup" ]
	then
		get_backup_level $* || usage
		semaphore_setup $*
	else
		setup_trap other
	fi
}

server_check()
{
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
        mysqladmin -u $user $sock_str $pass_str ping >$aux_log 2>&1
	if [ $? -ne 0 ]
	then
		echo
		echo "ERROR: cannot connect to database instance"
	else
		fgrep -iq denied $aux_log || return
		echo
		fgrep -i denied $aux_log | sed -e "s/error/ERROR/"
	fi
	echo
	echo "pre-flight checks failed, cannot continue. Exiting."
	status=1; fire_webhook
	exit 1
}

mysql_variable()
{
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	echo "select @@$1" | mysql -ANr -u $user $sock_str $pass_str
}

prepare_target()
{
	backup_id=$(date "+%s$$" | md5sum | cut -d" " -f 1)
	case "$level" in
		0) fn=full_$(date +%H:%M);;
			1) fn=incr_$(date +%H:%M);;
		2) fn=${dumplist}_$(date +%H:%M);;
		3) fn=binlogs_$(date +%H:%M);;
	esac
	case "$tool" in
		'mydumper')
				fn=""
				tt=$target/$(date +$dt_format)/${tool}_$(date +%H:%M)
				;;
		'smartdump')
				fn="smartdump_$(date +%H:%M)"
				tt=$target/$(date +$dt_format)/$tool
				;;
		'mariaunpacked')
				fn=""
				tt=$target/$(date +$dt_format)/${tool}/$(date +%H:%M)
				;;
		*)
				tt=$target/$(date +$dt_format)/$tool
				;;
	esac
	mkdir -p $tt
	echo "Target directory for this backup: $tt"
	logfile=$tt/$backup_id.log
	case "$tool" in
		'binlogs'|'zsnapshot') ;;
		*) echo "Logfile: $logfile";;
	esac
}

save_bootstrap()
{
	case "$tool" in
		'mariabackup'| 'xtrabackup' | 'mariaunpacked' )
			cp $DB $(mysql_variable datadir)/$BOOTSTRAP_FILE 2>/dev/null
			;;
	esac
}

inventory_init()
{
	case "$level" in
		1) echo "insert into backup_history values('$backup_id', $runtime_id, '$(date +%Y-%m-%d\ %T)', NULL, '$location', '$logfile', NULL, $level, '$compressor', '$uncompressor', '$encryptor', '$unencryptor', '$local_key', NULL, '$tool', '$(mysql_variable version)', NULL, '$ref_full', NULL, '$dumplist', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL);" | dbquery $DB;;
		*) echo "insert into backup_history values('$backup_id', $runtime_id, '$(date +%Y-%m-%d\ %T)', NULL, '$location', '$logfile', NULL, $level, '$compressor', '$uncompressor', '$encryptor', '$unencryptor', '$local_key', NULL, '$tool', '$(mysql_variable version)', NULL, NULL, NULL, '$dumplist', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL);" | dbquery $DB;;
	esac
}

save_datadir_size()
{
	ddsz=$(du -B 1 -s --exclude="*\.[0-9][0-9][0-9][0-9][0-9][0-9]" $(mysql_variable datadir) | cut -f 1)
	[ "$ddsz" != "" ] && echo "update backup_history set datadir_size = $ddsz where uuid = '$backup_id';" | dbquery $DB
}

update_backup_status()
{
	check_status $1
	echo "update backup_history set end_time = '$(date +%Y-%m-%d\ %T)' where uuid = '$backup_id';" | dbquery $DB
	[ $status -ne 0 ] && return
	case_insens=$(mysql_variable lower_case_table_names)
	case "$tool" in
		'mariaunpacked')
			echo "update backup_history set last_lsn = $lsn, case_insensitive = $case_insens, backup_size = $(du -bs $tt | cut -f 1) where uuid = '$backup_id';" | dbquery $DB
			pit_xid
			;;
		'mariabackup'| 'xtrabackup' )
			echo "update backup_history set last_lsn = $lsn, case_insensitive = $case_insens, backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			pit_xid
			;;
		'zsnapshot')
			echo "update backup_history set backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			;;
		'mysqldump')
			echo "update backup_history set backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			;;
		'smartdump')
			echo "update backup_history set backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			;;
		'mydumper')
			echo "update backup_history set backup_size = $(du -b $tt | cut -f 1) where uuid = '$backup_id';" | dbquery $DB
			;;
		'binlogs')
			echo "update backup_history set backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			;;
	esac
	case $level in
		0) save_datadir_size;;
		2) [ "$dumplist" = "ALL" ] && save_datadir_size;;
	esac
}

fire_webhook()
{
	[ "$webhook_script" = "" ] && return
	[ "$customer" != "" ] && export BACKUP_LABEL="$customer"
	eval $webhook_script $tool $level $status
}

perform_backup()
{
	echo "MariaDB Backup Manager $BM_VERSION starting"
	location=$tt/$fn 
	if [ "$encryptor" != "" -a "$enc_key" = "" ]
	then
		enc_key=$(openssl rand -base64 32)
		export enc_key="$enc_key"
		local_key=$enc_key
	fi
	inventory_init
	case "$tool" in
		'mariabackup')
			perform_maria_backup;;
		'zsnapshot')
			perform_zsnapshot_backup;;
		'mariaunpacked')
			perform_mariaunpacked_backup;;
		'xtrabackup')
			perform_xtra_backup;;
		'mysqldump')
			perform_mysqldump_backup;;
		'smartdump')
			perform_smartdump_backup;;
		'mydumper')
			perform_mydumper_backup;;
		'binlogs')
			perform_binlogs_backup;;
		*)
			echo "Unsupported backup tool $tool"
			clean_exit 1
			;;
	esac
}

perform_binlogs_backup()
{
	mysqlbinlog=$(which mysqlbinlog 2>/dev/null)
	if [ "$mysqlbinlog" = "" ]
	then
		echo "ERROR: mysqlbinlog program not installed, but needed for binlogs backups."
		clean_exit 1
	fi
	if [ "$(mysql_variable log_bin)" != "1" ]
	then
		echo "ERROR: cannot backup binary logs if they are not enabled on server."
		clean_exit 1
	fi
	# check for a valid full backup to base binlogs backup on
	ref_id=$(echo "select uuid from backup_history where level = 0 and backup_tool in ('mariabackup','xtrabackup','mariaunpacked') and status = 0 order by start_time desc limit 1;" | dbquery $DB)
	if [ "$ref_id" = "" ]
	then
		echo "ERROR: no full backup available to base binlog backups on. Exiting."
		clean_exit 1
	else
		binlog_base=$(mysql_variable log_bin_basename)
		[ "$binlog_base" = "" ] && clean_exit 0 # server is down
		find_binlogs_backup_sp $ref_id
		build_binlog_list
		echo "Backing up binary log files" 
		echo "Files in this backup: $binlog_list"
		cd $(dirname $binlog_base)
		tar cf - $binlog_list 2>$error_log | $compressor | $encryptor 2>/dev/null > $tt/$fn
		if [ -s $error_log ]
		then
			status=1
		else
			blarr=($binlog_list)
			position_from_binlog ${binlog##*/}
			binlog_file=${binlog##*/}
			echo "update backup_history set ref_full_backup = '$ref_id' , binlog_file = '$binlog_file', binlog_position = $binlog_pos, gtid_binlog_pos='$gtid_binlog_pos', binlog_first = '${blarr[0]}', binlog_last = '${blarr[-1]}', binlog_last_ts = datetime('$lb_ts', '+1 second') where uuid = '$backup_id';" | dbquery $DB
			status=0
		fi
	fi
	update_backup_status
	fire_webhook
}

save_binlog_info()
{
	[ $status -ne 0 ] && return
	binlog_ts=$(mysqlbinlog --no-defaults --skip-annotate-row-events --base64-output=NEVER --stop-position $binlog_pos $(dirname $(mysql_variable log_bin_basename))/$binlog_file | fgrep "end_log_pos " | tail -1 | sed -re "s/^#([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+) ([0-9 ]*):([0-9]*):([0-9]*) server (.*)$/20\1\2-\3\4-\5\6 \7:\8:\9/" -e "s/( )([0-9]:)/0\2/")
	case "$tool" in
		'mariabackup'|'mariaunpacked'|'zsnapshot')
			gtid_binlog_pos=$(echo "select BINLOG_GTID_POS('$binlog_file',$binlog_pos)" | mysql -ANr -u $user $sock_str $pass_str)
			;;
	esac
}

check_status()
{
	case "$tool" in
		'mariabackup'|'xtrabackup'|'mariaunpacked')
			tail -5 $logfile | fgrep -q "completed OK"
			status=$? # override exit status from backup tool
			if [ $status -eq 1 ]
			then
				tail -1 $logfile | fgrep -q "BACKUP STAGE START: Lock wait timeout exceeded"
				if [ $? -eq 0 ]
				then
					echo
					echo "ERROR: backup could not be started due to other connection(s) holding metadata lock(s)."
					echo "This may happen if there is a bulk data load or other maintenance ongoing."
					echo "If you get this error repeatedly, it may mean that the workload is not backup compatible."
					echo "In this case, you can try and schedule the backup at a different time."
					echo
				fi
			fi
			if [ "$(mysql_variable log_bin)" = "1" -a $status -eq 0 ]
			then
                                if [ "$1" = "export" ]
                                then
                                        binlog_file=$(tail $logfile | fgrep "Last binlog file ." | sed -re "s/^(.*)\sLast binlog file \.\/(.*), position ([0-9]*)$/\2/")
                                        binlog_pos=$(tail $logfile | fgrep "Last binlog file ." | sed -re "s/^(.*)\sLast binlog file \.\/(.*), position ([0-9]*)$/\3/")
                                else
                                        binlog_file=$(tail $logfile | fgrep "MySQL binlog position:" | sed -re "s/^(.*)filename '(.*)', position '([0-9]*)'(.*)$/\2/")
                                        binlog_pos=$(tail $logfile | fgrep "MySQL binlog position:" | sed -re "s/^(.*)filename '(.*)', position '([0-9]*)'(.*)$/\3/")
                                fi
				save_binlog_info
                        fi
			echo "update backup_history set status = $status, binlog_file = '$binlog_file', binlog_position = '$binlog_pos', gtid_binlog_pos='$gtid_binlog_pos', binlog_last_ts = '$binlog_ts' where uuid = '$backup_id';" | dbquery $DB
			;;
		'zsnapshot')
			save_binlog_info
			echo "update backup_history set status = $status, binlog_file = '$binlog_file', binlog_position = '$binlog_pos', gtid_binlog_pos='$gtid_binlog_pos', binlog_last_ts = '$binlog_ts' where uuid = '$backup_id';" | dbquery $DB
			;;
		'mysqldump')
			[ -s $logfile ] && status=1
                        grep -q "^-- Dump completed" $dumptail || status=1
			echo "update backup_history set status = $status where uuid = '$backup_id';" | dbquery $DB
			;;
		'smartdump')
			ri=$(cat /tmp/smartdump_master_pos 2>/dev/null | sed -re "s/^(.*):(.*)\s(.*)$/, binlog_file = '\1', binlog_position = \2, gtid_binlog_pos = '\3'/")
			echo "update backup_history set status = $status $ri where uuid = '$backup_id';" | dbquery $DB
			;;
		*)	echo "update backup_history set status = $status where uuid = '$backup_id';" | dbquery $DB
			;;
	esac
        [ "$1" = "noprint" ] && return
	echo "Exit status of $tool was $status."
	[ $status -eq 0 ] && echo "Backup SUCCESSFUL" || echo "Backup FAILED"
}

incremental_check()
{
	[ $level -ne 1 ] && return
	extra=""
	ref_full=$(echo "select uuid from backup_history where level = 0 and backup_tool = '$tool' and status = 0 $extra order by start_time desc limit 1;" | dbquery $DB)
	if [ "$ref_full" = "" ]
	then
		msg="ERROR: no valid full backup found, cannot perform incremental backup at this time."
		echo $msg
		[ "$failure_notify" != "" ] && echo $msg | send_mail "$customer: backup FAILED" $failure_notify
		exit 1	
	fi
	echo "Performing an incremental backup based on $ref_full"
}

sqlite_inventory()
{
	echo
        echo -n "MariaDB Backup Manager v$BM_VERSION"
	echo
	echo
	[ -f $lockfile ] && g_r_id=$(cat $lockfile) || g_r_id=0
	[ -f $binlog_lockfile ] && b_r_id=$(cat $binlog_lockfile) || b_r_id=0
	case "$1" in
		'pretty'|'short') 
			width="0 0 5 0 0 10 0 0 0 9"
			echo -e ".width $width\nselect uuid as 'backup id', backup_tool as 'backup tool', case(level) when 0 then 'full' when 1 then 'incr' when 2 then 'dump' end as level, datetime(start_time) as 'start time        ', datetime(end_time) as 'end time           ', ((strftime('%s', end_time) - strftime('%s', start_time)) / 86400) || '+' || time(strftime('%s', end_time) - strftime('%s', start_time), 'unixepoch') as duration, last_lsn as 'last LSN', case when length(server_version) > 20 then substr(server_version,1,17) || '..' || substr(server_version, -1) else server_version end as 'server version', case when backup_size < 1000000 then substr('        ' || round(backup_size/1000.0, 2) || 'K', -10, 10) when backup_size between 1000000 and 999999999 then substr('        ' || round(backup_size/1000000.0, 2) || 'M', -10, 10) else substr('        ' || round(backup_size/1000000000.0, 2) || 'G', -10, 10) end as 'backup sz', case when datadir_size < 1000000 then substr('          ' || round(datadir_size/1000.0, 2) || 'K', -9, 9) when datadir_size between 1000000 and 999999999 then substr('          ' || round(datadir_size/1000000.0, 2) || 'M', -9, 9) else substr('          ' || round(datadir_size/1000000000.0, 2) || 'G', -9, 9) end as 'data size', case when status = 0 then 'succeeded' when status is null and runtime_id in ($g_r_id, $b_r_id) then 'running' else 'failed' end as status, case(level) when 2 then dumplist end as 'additional info' from backup_history order by start_time desc;" | inv_dbquery $DB 2>/dev/null | tee /tmp/bi$$
			;;
		'binlogs')
			width="1 0 0 5 0 0 9 9 28 13 0"
			echo -e ".width $width\nselect case(level) when 0 then 'F' else ' ' end as f, uuid as 'backup id', backup_tool as 'backup tool', case(level) when 0 then 'full' when 1 then 'incr' when 2 then 'dump' end as level, datetime(start_time) as 'start time        ', datetime(end_time) as 'end time           ', case when backup_size < 1000000 then substr('        ' || round(backup_size/1000.0, 2) || 'K', -8, 8) when backup_size between 1000000 and 999999999 then substr('        ' || round(backup_size/1000000.0, 2) || 'M', -8, 8) else substr('        ' || round(backup_size/1000000000.0, 2) || 'G', -8, 8) end as 'disk size', case when status = 0 then 'succeeded' when status is null and runtime_id in ($g_r_id, $b_r_id) then 'running' else 'failed' end as status, case(level) when 3 then '' else binlog_file || ':' || binlog_position end as 'backup position', substr(binlog_first, -6) || '-' || substr(binlog_last, -6) as binlogs, binlog_last_ts as 'backup point-in-time'  from backup_history order by binlog_last_ts desc;" | dbquery -column -header $DB 2>/dev/null | tee /tmp/bi$$
			;;
		*) echo "select * from backup_history order by start_time desc;" | inv_dbquery $DB 2>/dev/null | tee /tmp/bi$$
			;;
	esac
	echo
	if [ ! -s /tmp/bi$$ ]
	then
		echo "There are no backups in inventory. "
	fi
	rm -f /tmp/bi$$
	[ -d $target ] && echo "Backup directory $target $disk_space_p_used% used, $disk_space_avail left" 
	echo
}

usage() 
{               
	echo "usage: $0 backup [ mariabackup | mariaunpacked | xtrabackup | zsnapshot | mydumper | mysqldump | smartdump | binlogs ]" 
	exit 1                  
}   

level_usage()
{
	echo "usage: $0 backup $1 [ full | incr ]" 
	exit 1                  
}

get_backup_level()
{
	incr=""
	case "$2" in
		'mariaunpacked') level=0;;
		'mariabackup'|'xtrabackup'|'zsnapshot')
			incr="| incr"
			case "$3" in
				'full') level=0;;
				'incr'|'incremental') [ "$incr" != "" ] && level=1;;
				*) level_usage $2;;
			esac
			;;
		'mysqldump') 	level=2
				dumplist="$3"
				[ "$dumplist" = "" -o "$dumplist" = "full" ] && dumplist="ALL"
				;;
		'smartdump') 	level=2
				;;
		'binlogs') level=3;;
		'mydumper') level=0;;
		*) 	return 1;;
	esac
	return 0
}

do_backup()
{
	check_root backup
	tool=$1
	what="backup"
	server_check
	incremental_check
	prepare_target
	check_free_space
	check_slave_status
	curl_before
	save_bootstrap
	perform_backup
	email_notification
	curl_after
	purge_incomplete
}

get_repl_creds()
{
	[ "$BM_MASTER_INFO" != "" ] && mi="$BM_MASTER_INFO" || mi=$(mysql_variable datadir 2>/dev/null)/master.info
	if [ "$mi" = "/master.info" ]
	then
		echo "WARNING: no replication info available (local server is down and BM_MASTER_INFO env var is empty)"
		return
	fi
	if [ ! -f $mi ]
	then
		echo "WARNING: no replication info available (checked $mi)"
		return
	fi
	if [ "$(tail -1 $mi)" != "END_MARKER" ]
	then
		echo "WARNING: $mi doesn't look like valid replication info, ignoring"
		return
	fi
	lc=0
	while read -r l; do
		case $lc in
			3) repl_host="$l";;
			4) repl_user="$l";;
			5) repl_pass="$l";;
			6) repl_port="$l";;
			8) repl_ssl="$l";;
			9) repl_ssl_ca="$l";;
			11) repl_ssl_cert="$l";;
			13) repl_ssl_key="$l";;
		esac
       		lc=$((lc+1))
	done < $mi
}

which_gtid()
{
	gtid_list=$(tail $logfile | fgrep gtid_slave_pos | tr -d "'" | cut -d";" -f 1 | sed -re "s/^(.*)gtid_slave_pos\ (.*)$/\2/" | tr "," " ")
	tid=0
	for gtid in $gtid_list
	do
		this=$(echo $gtid | cut -d"-" -f3)
		[ $this -gt $tid ] && tid=$this
	done
	echo $tid
}

build_master_cmd()
{
	master_cmd="mysql -u $repl_user -p$repl_pass -h$repl_host -P$repl_port -ANr --skip-ssl --max-allowed-packet=1073741824"
}

convert_incr_to_full()
{
	lv=$(echo "select level from backup_history where uuid = '$1' and status = 0;" | dbquery $DB)
	[ "$lv" != "1" ] && return
	rf=$(echo "select ref_full_backup from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$rf" = "" ] && return
	pit=$(echo "select binlog_last_ts from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$pit" = "" ] && return
	echo "Converting request to full:$rf @ '$pit'"
	exec $0 restore $rf $2 "$pit" noconfirm
}

do_remote_restore()
{
	while true
	do
		echo -n "Please enter hostname or IP address of the remote restore target: "
		read target_host
		[ "$target_host" = "" ] && continue
		ssh -oConnectTimeout=10 root@$target_host true && break
		echo
		echo "That didn't work."
		echo "Please make sure you entered the correct information, and ssh keypair authentication is set up properly."	
		echo
		[ ! -t 0 ] && exit 1
	done
	if [ "$BM_BACKUP_PATH" = "" ]
	then    
		while true
		do
			echo -n "Please enter path where backups can be found on this host (or quit and set \$BM_BACKUP_PATH instead): "
			read backup_path
			[ "$backup_path" = "" ] && continue
			[ -d $backup_path ] && break
			echo
			echo "That didn't work."
			echo "Please enter a valid path."
			echo
		done    
	else    
		backup_path="$BM_BACKUP_PATH"
	fi      
	ssh="ssh -q root@$target_host"
	local_remote="$ssh"
	replication_credentials
	if [ "$repl_user" != "" ] 
	then
		admin_user="$ADMIN_USER"
		admin_pass="$ADMIN_PASSWORD"
		if [ "$admin_user" = "" -o "$admin_pass" = "" ]
	       	then
			echo "ERROR: automatic replication setup requires exporting ADMIN_USER and ADMIN_PASSWORD in the environment first. Exiting."
			exit 1
		fi
	fi
	do_restore $1 "$2" "$3" "$4"
	if [ "$repl_user" != "" ] 
	then
		$ssh chown -R mysql:mysql $2
		start_remote_server
		wait_for_remote_server
		user=$admin_user
		password=$admin_pass
		setup_replication $target_host $2
		echo "Replication set up successfully."
	fi
}

wait_for_remote_server()
{
	cd=10
	echo -n "Waiting for remote service to start..."
	while true
	do
        	echo "select 1" | $ssh mysql -u $admin_user -p$admin_pass > /dev/null 2>&1 && break
		cd=$((cd-1))
		[ $cd -eq 0 ] && break
		echo -n "."
		sleep 9
	done
	echo
	if [ $cd -eq 0 ]
	then
		echo "ERROR: server failed to start, or admin credentials not working. Exiting."
		exit 1
	fi
}

start_remote_server()
{
	
	echo -n "Starting remote server... "
	if [ "$($ssh which supervisorctl 2>/dev/null)" != "" ]
	then
		$ssh supervisorctl start mariadb
		echo
		return
	fi
	if [ "$($ssh which systemctl 2>/dev/null)" != "" ]
	then
		$ssh systemctl start mariadb.service
		echo
		return
	fi
	if [ "$($ssh which service 2>/dev/null)" != "" ]
	then
		$ssh service mariadb start
		echo
		return
	fi
	echo "ERROR: unable to start MariaDB service on remote target. Exiting."
	exit 1
}

compression_encryption_override()
{
	uncompressor=$(echo "select uncompressor from backup_history where uuid = '$1';" | dbquery $DB)
	if [ "$(which $uncompressor 2>/dev/null)" = "" ]
	then
		echo "ERROR: cannot exec '$uncompressor', is the program installed on this machine?"
		exit 1
	fi
	unencryptor=$(echo "select unencryptor from backup_history where uuid = '$1';" | dbquery $DB)
	if [ "$(which $unencryptor 2>/dev/null)" = "" ]
	then
		echo "ERROR: cannot exec '$unencryptor', is the program installed on this machine?"
		exit 1
	fi
}

do_restore()
{
	check_root restore
	if [ "$1" = "" ]
	then
		echo "usage: $0 restore <backupid> <targetdir> [ <point-in-time> ]" 
		exit 1
	fi
	if [ "$1" = "test" ]
	then
		do_restore_test
		return
	fi
	convert_incr_to_full $*
	what="restore"
	uuid=$1
	if [ $(echo "select count(*) from backup_history where uuid = '$1' and level in (0, 2) and status = 0;" | dbquery $DB) -eq 0 ]
	then
		echo "full backup with id '$1' not found, or not valid."
		exit 1
	fi
	tool=$(echo "select backup_tool from backup_history where uuid = '$1';" | dbquery $DB)
	if [ "$ssh" != "" -a "$tool" != "mariabackup" ]
	then
		echo "ERROR: this backup type does not support remote restore."
		exit 1
	fi
	case "$tool" in
		'binlogs'|'mariaunpacked')	toolcheck="mysqlbinlog";;
		'zsnapshot')			toolcheck="zfs";;
		*)				toolcheck=$tool
	esac
	if [ "$($ssh which $toolcheck 2>/dev/null)" = "" ]
	then
		echo "ERROR: tool $tool needed to restore '$1' is not installed. Please install it."
		exit 1
	fi
	case "$tool" in
		'mariabackup'|'xtrabackup'|'mariaunpacked'|'zsnapshot')
			if [ "$2" = "" ]
			then
				echo "usage: $0 restore [ backupid ] [ targetdir ] [ point-in-time ]"
				exit 1
			fi
			target=$2
			if [ "$target" != "-" ]
			then
				if $ssh [ -d $target ]
				then
					if [ "$($ssh ls -a1 $target | tr -d ".\n")" != "" ]
					then
						echo "ERROR: target directory $target must be empty."
						exit 1
					fi
				fi
			fi
			[ "$3" != "" ] && validate_point_in_time "$3" $4
			[ "$2" != "-" ] && echo -n "Restoring backup '$uuid' using $tool to $target"
			[ "$2" != "-" ] && echo
			if [ "$target" != "-" -a "$local_remote" = "eval" ]
			then
				[ ! -d $target ] && mkdir -p $target
				logfile=$target/restore.log
			else
				logfile=/tmp/restore.log
				[ "$RESTORE_LOG" != "" ] && logfile=$RESTORE_LOG
			fi
			rm -f $logfile
			[ "$tool" != "zsnapshot" ] && echo "Logfile: $logfile"
			;;
	esac
	dim_prepare_memory
	compression_encryption_override $1
	case "$tool" in
		'mariabackup')
			perform_maria_restore;;
		'mariaunpacked')
			perform_mariaunpacked_restore;;
		'zsnapshot')
			perform_zsnapshot_restore;;
		'xtrabackup')
			perform_xtra_restore;;
		'mysqldump')
			perform_mysqldump_restore;;
		'smartdump')
			perform_smartdump_restore;;
		'mydumper')
			perform_mydumper_restore;;
	esac
	case "$tool" in
		'mariabackup'|'xtrabackup')
			if [ "$target" != "-" ]
			then
				echo "Exit status of $tool was $status."
				if [ $restore_test -eq 1 ]
				then
					if [ $status -eq 0 ]
					then
						[ "$success_notify" != "" ] && echo "Restore test successful. Details in /tmp/restore.log" | send_mail "$customer: restore test SUCCESSFUL" $success_notify 
					else
						[ "$failure_notify" != "" ] && echo "Restore test FAILED, please see /tmp/restore.log for details" | send_mail "$customer: restore test FAILED" $failure_notify
					fi
				else
					if [ $status -eq 0 ]
					then
						echo "Restore complete."
						[ "$repl_user" = "" ] && echo "Please don't forget to chown -R mysql:mysql $target."
					else
						echo "ERROR: restore failed! Please see $logfile for details."
						exit 1
					fi
				fi
			else
				echo $status > /tmp/build_slave.status
			fi
			;;
	esac
}

inventory_cleanup()
{
	exit 1
}

extract_binlog_piece()
{
	path=$(echo "select bulocation from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$backup_path" != "" ] && path=$backup_path/$(echo $path | sed -re "s/^(.*)\/([0-9-]*)\/(.*)\/(.*)$/\2\/\3\/\4/")
	key=$(echo "select cryptkey from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	if [ ! -f $path ]
	then
		echo "ERROR: binlogs backup archive not found. Aborting restore."
		kill $instance 2>/dev/null
		return 1
	fi
	eval $reader | $unencryptor 2>/dev/null | $uncompressor | tar xf -
	first_b=$(basename $(ls -1 $bxfolder/* | head -1))
	last_b=$(basename $(ls -1 $bxfolder/* | tail -1))
	if [ "$requested_binlog_file" != "" ]
	then
		[ "$last_b" \> "$requested_binlog_file" ] && last_b=$requested_binlog_file
	else
		scan_binlog_archive
		if [ "$last_b" = "" ]
 		then
 			echo "ERROR: required binlog $bf_start_file not available. Aborting restore."
 			kill $instance 2>/dev/null
 			return 1
 		fi
	fi
	[ "$bf_start_file" \> "$first_b" ] && first_b=$bf_start_file
	echo -n "applying binlog files from $first_b to $last_b.."
	for bf in $(ls $bxfolder)
	do
		[ "$bf_start_file" \> "$bf" ] && continue
		echo -n "."
		if [ "$bf" != "$requested_binlog_file" ]
		then
			if [ $initial_bf_done -eq 1 ]
			then
				cat $bxfolder/$bf | $local_remote $mysqlbinlog --no-defaults --stop-datetime="'$requested_binlog_ts'" - | $ssh mysql -A -S /tmp/backup_manager.sock 2>$aux_log
			else
				initial_bf_done=1
				cat $bxfolder/$bf | $local_remote $mysqlbinlog --no-defaults --start-position=$bf_start_pos --stop-datetime="'$requested_binlog_ts'" - | $ssh mysql -A -S /tmp/backup_manager.sock 2>$aux_log
			fi
			if [ $? -ne 0 ]
			then
				echo
				echo "ERROR: apply of binary log $bf failed!"
				cat $aux_log
				echo "Aborting restore."
				kill $instance 2>/dev/null
				return 1
			fi
		else
			last_file=$bf
			if [ $initial_bf_done -eq 1 ]
			then
				cat $bxfolder/$bf | $local_remote $mysqlbinlog --no-defaults --stop-position=$requested_binlog_position --stop-datetime="'$requested_binlog_ts'" - | $ssh mysql -A -S /tmp/backup_manager.sock 2>$aux_log
			else
				cat $bxfolder/$bf | $local_remote $mysqlbinlog --no-defaults --start-position=$bf_start_pos --stop-position=$requested_binlog_position --stop-datetime="'$requested_binlog_ts'" - | $ssh mysql -A -S /tmp/backup_manager.sock 2>$aux_log
			fi
			if [ $? -ne 0 ]
			then
				echo
				echo "ERROR: apply of binary log $bf failed!"
				cat $aux_log
				echo "Aborting restore."
				kill $instance 2>/dev/null
				return 1
			fi
			break
		fi
		[ "$bf" = "$last_b" ] && break
	done
	echo
	rm -f $bxfolder/*
	return 0
}

check_root()
{
	if [ $(id -u) -ne 0 ]
        then
                echo "the $1 command requires superuser privileges. Exiting."
                exit 1
        fi
}

backup_stage()
{
	case "$1" in
		'START') echo -n "BACKUP STAGE: $1 ";;
		'END') echo "$1";;
		*) echo -n "$1 ";;
	esac
	echo "backup stage $1;" >&${mysqlc[1]}
	while read -t 0.2 -u ${mysqlc[0]} row
	do
		echo "$row"
	done > $aux_log
	fgrep -q "Query OK," $aux_log 2>/dev/null
	if [ $? -ne 0 ]
	then
		echo
		cat $aux_log
		echo "Exiting."
		clean_exit 1
	fi
}

zfs_purge_snapshots()
{
	[ $level -ne 0 ] && return
	id=$(echo "select uuid from backup_history where level = 0 and backup_tool = 'zsnapshot' and status = 0 order by start_time desc limit 1;" | dbquery $DB)
	[ "$id" = "" ] && return
	for ip in $(echo "select uuid from backup_history where ref_full_backup = '$id' and level=1;" | dbquery $DB)
	do
		zfs destroy ${snap_t:1}@$ip
	done
	zfs destroy ${snap_t:1}@$id
}

zfs_preflight_checks()
{
	d=$(mysql_variable datadir)
	if [ "$(df -t zfs $d/ibdata1 2>/dev/null)" = "" ]
	then
		echo "ERROR: snapshot backup requires that datadir is on a ZFS filesystem. Exiting."
		clean_exit 1
	fi
	z=$(which zfs 2>/dev/null)
	if [ "$z" = "" ]
	then
		echo "Please install the zfs command."
		clean_exit 1
	fi
	zfs_purge_snapshots
}

perform_zsnapshot_backup()
{
	echo "Performing backup using ZFS snapshot."
	snap_t=$(stat -Lc %m $(mysql_variable datadir))
	zfs_preflight_checks
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	coproc mysqlc { script -c "mysql -ANr -u $user $sock_str $pass_str 2>&1" /dev/null; }
	backup_stage START
	backup_stage FLUSH
	backup_stage BLOCK_DDL
	backup_stage BLOCK_COMMIT
	zfs snapshot ${snap_t:1}@$backup_id 2>$aux_log
	if [ $? -ne 0 ]
	then
		echo "ERROR: zfs snapshot command failed!"
		cat $aux_log
		echo "Exiting."
		clean_exit 1
	fi
	ms=$(echo "show master status" | mysql -ANr -u $user $sock_str $pass_str 2>$aux_log)
	if [ "$ms" = "" ]
	then
		echo -n "ERROR: cannot obtain master status: "
		cat $aux_log
		echo "Exiting."
		clean_exit 1
	fi
	binlog_file=$(echo "$ms" | cut -f 1)
	binlog_pos=$(echo "$ms" | cut -f 2)
	backup_stage END
	echo -n "Saving snapshot... "
	case "$level" in
		0)
			zfs send ${snap_t:1}@$backup_id | $compressor | $encryptor > $tt/$fn 2>$aux_log
			;;
		1)
			zfs send -i @$ref_full ${snap_t:1}@$backup_id | $compressor | $encryptor > $tt/$fn 2>$aux_log
			;;
	esac
	if [ $? -ne 0 ]
	then
		echo "ERROR: zfs send command failed!"
		cat $aux_log
		echo "Exiting."
		clean_exit 1
	fi
	echo
	update_backup_status
	fire_webhook
}

perform_maria_backup()
{
	mariabackup=$(which mariabackup 2>/dev/null)
	if [ "$mariabackup" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool."
	fi
	mkdir -p $target/checkpoints/mariabackup
	open_files_limit
	[ "$password" != "" ] && pass_str="--password=$password"
	[ "$socket" != "" ] && sock_str="--socket=$socket"
	[ $galera -eq 1 ] && galera_str="--galera-info"
	[ $kill_query_time -gt 0 ] && kill_str="--kill-long-queries-timeout=$kill_query_time --kill-long-query-type=SELECT"
	case $level in
		0)
			mariabackup --backup $galera_str $kill_str $limit_str --user=$user $pass_str $sock_str --parallel=$parallelism --extra-lsndir=/tmp --stream=xbstream --slave-info --ftwrl-wait-timeout=$BACKUP_LOCK_TIMEOUT --ftwrl-wait-threshold=999999 --target-dir=$tt 2>> $logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/mariabackup 2>/dev/null
			;;
		1)
			cp $target/checkpoints/mariabackup/xtrabackup_checkpoints /tmp 2>/dev/null
			mariabackup --backup $galera_str $kill_str $limit_str --incremental-basedir=$target/checkpoints/mariabackup --user=$user $sock_str $pass_str --parallel=$parallelism --extra-lsndir=/tmp --stream=xbstream --slave-info --ftwrl-wait-timeout=$BACKUP_LOCK_TIMEOUT --ftwrl-wait-threshold=999999 --target-dir=$tt 2>> $logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/mariabackup 2>/dev/null
			;;
	esac
	get_lsn
	update_backup_status
	fire_webhook
}

open_files_limit()
{
	[ "$ulimit" = "" ] && return
	limit_str="--open-files-limit=$ulimit"
	curr_fmax=$(cat /proc/sys/fs/file-max)
	[ $curr_fmax -lt $ulimit ] && echo $((ulimit+curr_fmax)) > /proc/sys/fs/file-max
}

perform_mariaunpacked_backup()
{
	mariabackup=$(which mariabackup 2>/dev/null)
	if [ "$mariabackup" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool."
	fi
	mkdir -p $target/checkpoints/mariaunpacked
	[ "$password" != "" ] && pass_str="--password=$password"
	[ "$socket" != "" ] && sock_str="--socket=$socket"
	[ $galera -eq 1 ] && galera_str="--galera-info"
	[ $kill_query_time -gt 0 ] && kill_str="--kill-long-queries-timeout=$kill_query_time --kill-long-query-type=SELECT"
	case $level in
		0)
			mariabackup --backup $galera_str $kill_str --user=$user $pass_str $sock_str --parallel=$parallelism --extra-lsndir=/tmp --slave-info --ftwrl-wait-timeout=$BACKUP_LOCK_TIMEOUT --ftwrl-wait-threshold=999999 --target-dir=$tt 2>> $logfile &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/mariaunpacked 2>/dev/null
			;;
		1)	# NOT IMPLEMENTABLE
			;;
	esac
        check_status noprint
        [ $status -ne 0 ] && return
	open_files_limit
        dim_prepare_memory
        mariabackup --prepare $limit_str --export --use-memory=${prepare_memory}K --target-dir=$tt >> $logfile 2>&1
        status=$?
        [ $status -ne 0 ] && return
        tail -1 $logfile | fgrep -q "completed OK"
        status=$?
	fire_webhook
        [ $status -ne 0 ] && return
        get_lsn
        update_backup_status export
        echo "Backup prepared successfully for export."
}

perform_xtra_backup()
{
	xtrabackup=$(which xtrabackup 2>/dev/null)
	if [ "$xtrabackup" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool."
	fi
	mkdir -p $target/checkpoints/xtrabackup
	[ "$password" != "" ] && pass_str="--password=$password"
	[ "$socket" != "" ] && sock_str="--socket=$socket"
	[ $galera -eq 1 ] && galera_str="--galera-info"
	[ $kill_query_time -gt 0 ] && kill_str="--kill-long-queries-timeout=$kill_query_time --kill-long-query-type=SELECT"
	case $level in
		0)
			xtrabackup --backup $galera_str $kill_str --user=$user $pass_str $sock_str --parallel=$parallelism --extra-lsndir=/tmp --target-dir=$tt --stream=xbstream --slave-info 2>> $logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/xtrabackup 2>/dev/null
			;;
		1)
			cp $target/checkpoints/xtrabackup/xtrabackup_checkpoints /tmp 2>/dev/null
			xtrabackup --backup $galera_str $kill_str --incremental-basedir=$target/checkpoints/xtrabackup --user=$user $pass_str $sock_str --parallel=$parallelism --extra-lsndir=/tmp --target-dir=$tt --stream=xbstream --slave-info 2>> $logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/xtrabackup 2>/dev/null
			;;
	esac
	get_lsn
	update_backup_status
	fire_webhook
}

perform_mydumper_backup()
{
	mydumper=$(which mydumper 2>/dev/null)
	if [ "$mydumper" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool." 
		[ "$compressor" != "cat" ] && echo "Note: compression configured in config file, but $tool will use its built-in compression instead."
		[ "$encryptor" != "cat" ] && echo "Warning: encryption configured in config file, but not supported by $tool, hence setting ignored."
	fi
	[ $kill_query_time -gt 0 ] && kill_str="-l $kill_query_time -K"
	case $level in
		0)
			[ "$password" != "" ] && pass_str="-p $password"
			[ "$socket" != "" ] && sock_str="-S $socket"
			$mydumper -o $tt -t $parallelism -L $logfile $kill_str -G -E -R -v 3 -c -h $host -P $port $sock_str -u $user $pass_str &
			run_with_timeout
			;;
		1)
			echo "Incremental backups not supported by $tool. Exiting."
			clean_exit 1
			;;
	esac
	update_backup_status
	fire_webhook
}

set_read_only()
{
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	[ "$port" != "" ] && port_str="-P$port"
	echo "set global read_only=$1" | mysql -A -u $user $sock_str $pass_str $port_str
}

perform_smartdump_backup()
{
	smartdump=$(which smartdump 2>/dev/null)
	if [ "$smartdump" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool."
	fi
	ro=$(mysql_variable read_only)
	[ "$ro" = "1" ] && set_read_only 0
	[ "$password" != "" ] && pass_str="--password $password"
	[ "$socket" != "" ] && sock_str="--socket $socket"
	[ "$port" != "" ] && port_str="--port $port"
	$smartdump  --dump --lock-timeout=30 --threads $parallelism --host $host --user $user $pass_str $sock_str $port_str 2>$logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
	run_with_timeout
	[ "$ro" = "1" ] && set_read_only 1
	update_backup_status
	fire_webhook
}

perform_mysqldump_backup()
{
	mysqldump=$(which mysqldump 2>/dev/null)
	if [ "$mysqldump" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool."
	fi
	[ "$dumplist" = "ALL" ] && dbstr="--all-databases --master-data=2" || dbstr="--databases ${dumplist//,/ }"
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	[ "$port" != "" ] && port_str="-P$port"
	[ $master_position -eq 1 ] && mp_str="--dump-slave=2"
	$mysqldump --single-transaction --routines --triggers $mp_str --log-error=$logfile --max_allowed_packet=1G -h $host $port_str $sock_str -u $user $pass_str $dbstr | tee >(tail -1 > $dumptail) | $compressor | $encryptor 2>/dev/null > $tt/$fn &
	run_with_timeout
	update_backup_status
	fire_webhook
}

perform_mydumper_restore()
{
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	echo "To restore this $tool dump, please use: myloader -d $path ..."
	exit 0
}

perform_smartdump_restore()
{
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	[ "$password" != "" ] && pass_str="--password $password"
	[ "$socket" != "" ] && sock_str="--socket $socket"
	[ "$port" != "" ] && port_str="--port $port"
	eval $reader | $unencryptor 2>/dev/null | $uncompressor | smartdump --stream --threads $parallelism --host $host --user $user $pass_str $sock_str $port_str
	status=$?
}

perform_mysqldump_restore()
{
	if [ -t 1 ]
	then
		echo "To restore this $tool dump, please use: $0 restore $uuid | mysql -h ... "
		exit 1
	fi
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	eval $reader | $unencryptor 2>/dev/null | $uncompressor
	status=$?
}

do_restore_test()
{
	tb=$(echo "select uuid from backup_history where level = 0 and status = 0 and backup_tool in ('mariabackup', 'xtrabackup') order by start_time desc limit 1;" | dbquery $DB)
	if [ "$tb" = "" ]
	then
		msg="no valid backup found to perform a restore test. Exiting."
		echo "ERROR: $msg"
		[ ! -t 1 -a "$failure_notify" != "" ] && echo $msg | send_mail "$customer: restore test FAILED" $failure_notify
		return
	fi
	echo "Performing a test restore of backup $tb and related incrementals"
	restore_test=1
	[ "$restore_test_dir" != "" ] && do_restore $tb $restore_test_dir/RESTORE-TEST || do_restore $tb $target/RESTORE-TEST
	mv $logfile /tmp/
	echo "Removing restore test directory $target. Details of this test execution can be found in /tmp/restore.log."
	rm -rf $target
	exit $status
}

build_slave()
{
	check_root build_slave
	if [ "$1" = "" -o "$2" = "" ]
	then
		echo "usage: $0 build-slave [ targethost ] [ targetdir ]"
		exit 1
	fi
	replication_credentials
	if [ "$repl_user" = "" ] 
	then
		echo "Not a slave myself, cannot build another slave. Exiting."
		exit 1
	fi
	ssh_setup $1
	echo "*** Login to $1 successful"
	if [ $setup_repl_only -eq 0 ]
	then
		ssh -q $1 test -d $2
		if [ $? -ne 0 ]
		then
			ssh -q $1 mkdir $2
			if [ $? -ne 0 ]
			then
				echo "error creating target directory $2 on $1. Exiting."
				exit 1
			fi
		fi
		if [ "$(ssh -q $1 ls -1 $2)" != "" ]
		then
			echo "target directory $2 on target host $1 must be empty. Exiting."
			exit 1
		fi
        	uuid=$(echo "select uuid from backup_history where level = 0 and backup_tool in ('mariabackup','xtrabackup') and status = 0 order by start_time desc limit 1;" | dbquery $DB)
		if [ "$uuid" = "" ]
		then
			echo "no backup suitable for slave build found in inventory. Exiting."
			exit 1
		fi
        	tool=$(echo "select backup_tool from backup_history where uuid = '$uuid';" | dbquery $DB)
		case "$tool" in
			'mariabackup') rtool="mbstream"; ropts="-p $parallelism";;
			'xtrabackup') rtool="xbstream"; ropts="";;
		esac
		ssh -q $1 id mysql >/dev/null 2>&1
		if [ $? -ne 0 ]
		then
			echo "ERROR: MariaDB not found. Please install MariaDB-server package on $1 and retry."
			exit 1
		fi
		ssh -q $1 which $rtool >/dev/null 2>&1
		if [ $? -ne 0 ]
		then
			echo "ERROR: $rtool is not installed on $1. Please install the $tool package there and retry."
			exit 1
		fi
		echo "*** Streaming last good full backup ($uuid) to $1:$2"
		r_uncompressor=$uncompressor
		uncompressor="cat" 
		do_restore $uuid - | ssh -q $1 "$r_uncompressor | $rtool $ropts -v -x -C $2"
		status=$(cat /tmp/build_slave.status)
		if [ $status -ne 0 ]
		then
			echo "Streaming error detected! Exiting."
			exit 1
		fi
		echo "*** Preparing backup on $1"
        	avail=$(ssh -q $1 "grep ^MemTotal /proc/meminfo" | sed -re "s/^MemTotal:(\s*)([0-9]*) kB/\2/")
		["$avail" = "" ] && avail=16777216
        	prepare_memory=$((avail/4))
		[ "$tool" = "mariabackup" ] && open_files_limit
		ssh -q $1 $tool --prepare $limit_str --use-memory=${prepare_memory}K --target-dir=$2
		echo "*** Fixing permissions on $1"
		ssh -q $1 chown -R mysql:mysql $2
		echo "*** Starting MariaDB on $1"
		ssh -q $1 service mysql start
		if [ $? -ne 0 ]
		then
			ssh -q $1 service mariadb start
			if [ $? -ne 0 ]
			then
				echo "MariaDB failed to start. Stopping here."
				echo "You can start it by hand and resume the process with: '$0 setup-replication $*'"
				exit 1
			fi
		fi
	fi
	if [ "$repl_user" != "" ]
	then
		echo "*** Setting up replication on $1"
		[ "$password" != "" ] && pass_str="-p$password"
		config_lookup $1 socket || build_slave_failure $*
		[ "$cfg" != "" ] && sock_str="-S$cfg" || sock_str=""
		gtid=$(ssh -q $1 cat $2/xtrabackup_binlog_info | sed -re "s/^(.*)\s+(.*)\s+(.*)/\3/")
		if [ "$gtid" = "" -a "$BM_OVERRIDE_GTID_POS" = "" -a "$BM_CLEAR_GTID_POS" = "" ]
		then
			echo "Unable to get GTID info for replication. Are GTIDs enabled on backup server?"
			exit 1
		fi
		( 
			echo "RESET MASTER;"
			if [ "$BM_CLEAR_GTID_POS" = "" ]
			then
				if [ "$BM_OVERRIDE_GTID_POS" != "" ]
				then
					echo "SET GLOBAL gtid_slave_pos = '$BM_OVERRIDE_GTID_POS';"
				else
					echo "SET GLOBAL gtid_slave_pos = '$gtid';"
				fi
				echo "CHANGE MASTER TO MASTER_HOST='$repl_host', MASTER_PORT=$repl_port, MASTER_USER='$repl_user', MASTER_PASSWORD='$repl_pass', MASTER_USE_GTID=slave_pos;"
			else
				echo "CHANGE MASTER TO MASTER_HOST='$repl_host', MASTER_PORT=$repl_port, MASTER_USER='$repl_user', MASTER_PASSWORD='$repl_pass';"
			fi
			[ "$repl_ssl" = "1" ] && echo "CHANGE MASTER TO MASTER_SSL=1, MASTER_SSL_CA='$repl_ssl_ca', MASTER_SSL_CERT='$repl_ssl_cert', MASTER_SSL_KEY='$repl_ssl_key';"
			echo "START SLAVE;" 
		) | ssh -q $1 "cat | mysql -ANr -u $user $sock_str $pass_str" || build_slave_failure $*
		sleep 10
		success=$(echo "show slave status\G" | ssh -q $1 mysql -Ar -u $user $sock_str $pass_str | grep 'Running:' | fgrep -c Yes)
		if [ "$success" = "2" ]
		then
			echo "*** Slave started successfully!"
		fi
	fi
	[ $setup_repl_only -eq 0 ] && echo "*** Build complete."
}

build_slave_failure()
{
	[ $setup_repl_only -eq 0 ] && echo "Replication setup failed."
	echo "Please fix the issue and retry with: '$0 setup-replication $*'"
	exit 1
}

config_lookup()
{
	cfg=$(ssh -q $1 "find /etc/my* -type f -name \*.cnf | xargs grep -rh ^$2" | sort | uniq | tr -d "[ \t]" | cut -d"=" -f 2)
	if [ $(echo "$cfg" | wc -w) -gt 1 ]
	then
		echo "ERROR: found multiple config values for $2!"
		return 1
	fi
	return 0
}

perform_xtra_restore()
{
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	if [ "$target" != "-" ]
	then
		mkdir -p $target/full
		echo -n "extracting full backup $uuid... "
		echo "--> eval $reader | $unencryptor | $uncompressor | xbstream -p $parallelism -x -v -C $target/full" >> $logfile
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | xbstream -p $parallelism -x -v -C $target/full 2>> $logfile
	else
		eval $reader | $unencryptor 2>/dev/null | $uncompressor 2>> $logfile
		status=$?
		return
	fi
	status=$?
	echo
	[ $status -ne 0 ] && return
	echo -n "applying redo logs for $uuid... "
	echo "--> xtrabackup --prepare --apply-log-only --use-memory=${prepare_memory}K --target-dir=$target/full" >> $logfile
	xtrabackup --prepare --apply-log-only --use-memory=${prepare_memory}K --target-dir=$target/full >> $logfile 2>&1
	status=$?
	echo
	[ $status -ne 0 ] && return
	tail -1 $logfile | fgrep -q "completed OK"
	status=$?
	[ $status -ne 0 ] && return
	binlogs_starting_point=$uuid
	for id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and backup_tool = '$tool' and status =0 order by start_time asc;" | dbquery $DB)
	do
		incr_check_position $id && break
		path=$(echo "select bulocation from backup_history where uuid = '$id';" | dbquery $DB)
		key=$(echo "select cryptkey from backup_history where uuid = '$id';" | dbquery $DB)
		[ "$key" != "" ] && export enc_key="$key"
		incdir=$(basename $path)
		echo -n "extracting incremental backup $id... "
		mkdir -p $target/$incdir
		echo "--> eval $reader | $unencryptor | $uncompressor | xbstream -p $parallelism -x -v -C $target/$incdir" >> $logfile
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | xbstream -p $parallelism -x -v -C $target/$incdir 2>> $logfile
		status=$?
		echo
		[ $status -ne 0 ] && break
		echo -n "applying redo logs for $id... "
		echo "--> xtrabackup --prepare --apply-log-only --use-memory=${prepare_memory}K --target-dir=$target/full --incremental-dir=$target/$incdir" >> $logfile
		xtrabackup --prepare --apply-log-only --use-memory=${prepare_memory}K --target-dir=$target/full --incremental-dir=$target/$incdir >> $logfile 2>&1
		status=$?
		echo
		[ $status -ne 0 ] && break
		tail -1 $logfile | fgrep -q "completed OK"
		status=$?
		[ $status -ne 0 ] && break
		binlogs_starting_point=$id
		rm -rf $target/$incdir
	done
	[ $status -ne 0 ] && return
	echo -n "final preparation of backup... "
	echo "--> xtrabackup --prepare --use-memory=${prepare_memory}K --target-dir=$target/full" >> $logfile 
	xtrabackup --prepare --use-memory=${prepare_memory}K --target-dir=$target/full >> $logfile 2>&1
	status=$?
	echo
	[ $status -ne 0 ] && return
	tail -1 $logfile | fgrep -q "completed OK"
	status=$?
	mv $target/full/* $target/
	rmdir $target/full
	if [ $status -eq 0 -a $point_in_time -eq 1 ]
	then
		bxfolder=$target/.backupmanager
		apply_binlogs || exit 1
	        echo "Done applying binary logs."
	fi
}

perform_zsnapshot_restore()
{
	snap_t=$(stat -Lc %m $target)
	if [ "$(df -t zfs $snap_t 2>/dev/null)" = "" ]
	then
		echo "ERROR: restoring a snapshot requires that target dir is on a ZFS filesystem. Exiting."
		clean_exit 1
	fi
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	echo -n "restoring full snapshot $uuid... "
	eval $reader | $unencryptor 2>/dev/null | $uncompressor | zfs recv -u ${target:1} 2>$aux_log
	if [ $? -ne 0 ]
	then
		echo
		echo "ERROR: zfs receiver failed! Exiting."
		cat $aux_log
		exit 1
	else
		echo -n " OK "
	fi
	current_position $uuid
	binlogs_starting_point=$uuid
	if [ "$requested_binlog_ts" != "" ]
	then
		this_binlog_ts=$(echo "select binlog_last_ts from backup_history where uuid = '$uuid';" | dbquery $DB)
		[ "$this_binlog_ts" = "$requested_binlog_ts" ] && restore_incr=0 || restore_incr=1
	else
		restore_incr=1
	fi
	if [ $restore_incr -eq 1 ]
	then
		for id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and backup_tool = '$tool' and status = 0 order by start_time asc;" | dbquery $DB)
		do
			if [ $point_in_time -eq 1 ]
			then
				this_binlog_ts=$(echo "select binlog_last_ts from backup_history where uuid = '$id';" | dbquery $DB)
				[ "$this_binlog_ts" = "$requested_binlog_ts" ] && break
			fi
		done
		path=$(echo "select bulocation from backup_history where uuid = '$id';" | dbquery $DB)
		key=$(echo "select cryptkey from backup_history where uuid = '$id';" | dbquery $DB)
		[ "$key" != "" ] && export enc_key="$key"
		echo -n "restoring incremental snapshot $id... "
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | zfs recv -u ${target:1} 2>$aux_log
		if [ $? -ne 0 ]
		then
			echo
			echo "ERROR: zfs receiver failed! Exiting."
			cat $aux_log
			exit 1
		else
			echo -n " OK "
			current_position $id
			binlogs_starting_point=$id
		fi
	fi
	zfs mount ${target:1}
	echo "Restore complete, datadir restored to $target."
}

perform_maria_restore()
{
	mb_ver=$($ssh mariabackup --version 2>&1 | sed -re "s/(.*)server (.[0-9])\.([0-9])(.*)/\2.\3/")
	[ "$mb_ver" = "10.1" ] && mb_all="--apply-log-only" || mb_all=""
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$backup_path" != "" ] && path=$backup_path/$(echo $path | sed -re "s/^(.*)\/([0-9-]*)\/(.*)\/(.*)$/\2\/\3\/\4/")
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	rm -f /tmp/xtrabackup*
	if [ "$target" != "-" ]
	then
		echo -n "extracting full backup $uuid... "
		$ssh mkdir -p $target/full
		echo "--> eval $reader | $unencryptor | $uncompressor | $ssh mbstream -p $parallelism -x -v -C $target/full" >> $logfile
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | $ssh mbstream -p $parallelism -x -v -C $target/full 2>> $logfile
	else
		eval $reader | $unencryptor 2>/dev/null | $uncompressor 2>> $logfile
		status=$?
		return
	fi
	status=$?
	echo
	[ $status -ne 0 ] && return
	open_files_limit
	echo -n "applying redo logs for $uuid... "
	echo "--> $ssh mariabackup --prepare $mb_all $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full" >> $logfile
	$ssh mariabackup --prepare $mb_all $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full >> $logfile 2>&1
	status=$?
	echo
	[ $status -ne 0 ] && return
	tail -1 $logfile | fgrep -q "completed OK"
	status=$?
	[ $status -ne 0 ] && return
	current_position $uuid
	binlogs_starting_point=$uuid
	for id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and backup_tool = '$tool' and status = 0 order by start_time asc;" | dbquery $DB)
	do
		incr_check_position $id && break
		path=$(echo "select bulocation from backup_history where uuid = '$id';" | dbquery $DB)
		[ "$backup_path" != "" ] && path=$backup_path/$(echo $path | sed -re "s/^(.*)\/([0-9-]*)\/(.*)\/(.*)$/\2\/\3\/\4/")
		key=$(echo "select cryptkey from backup_history where uuid = '$id';" | dbquery $DB)
		[ "$key" != "" ] && export enc_key="$key"
		incdir=$(basename $path)
		echo -n "extracting incremental backup $id... "
		$ssh mkdir -p $target/$incdir
		rm -f /tmp/xtrabackup*
		echo "--> eval $reader | $unencryptor | $uncompressor | $ssh mbstream -p $parallelism -x -v -C $target/$incdir" >> $logfile
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | $ssh mbstream -p $parallelism -x -v -C $target/$incdir 2>> $logfile
		status=$?
		echo
		[ $status -ne 0 ] && break
		echo -n "applying redo logs for $id... "
		echo "--> $ssh mariabackup --prepare $mb_all $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full --incremental-dir=$target/$incdir" >> $logfile
		$ssh mariabackup --prepare $mb_all $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full --incremental-dir=$target/$incdir >> $logfile 2>&1
		status=$?
		echo
		[ $status -ne 0 ] && break
			tail -1 $logfile | fgrep -q "completed OK"
		status=$?
		[ $status -ne 0 ] && break
		current_position $id
		binlogs_starting_point=$id
		$ssh rm -rf $target/$incdir
	done
	[ $status -ne 0 ] && return
	echo -n "Finalizing backup... "
	echo "--> $ssh mariabackup --prepare $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full" >> $logfile 
	$ssh mariabackup --prepare $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full >> $logfile 2>&1
	status=$?
	echo
	[ $status -ne 0 ] && return
	tail -1 $logfile | fgrep -q "completed OK"
	status=$?
	$ssh mv $target/full/* $target/
	$ssh rmdir $target/full
	if [ $status -eq 0 -a $point_in_time -eq 1 ]
	then
		[ "$backup_path" = "" ] && bxfolder=$target/.backupmanager || bxfolder=$backup_path/.backupmanager
		apply_binlogs || exit 1
	        echo "Done applying binary logs."
	fi
}

perform_mariaunpacked_restore()
{
	mariabackup=$(which mariabackup 2>/dev/null)
	if [ "$mariabackup" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	fi
	rsync=$(which rsync 2>/dev/null)
	if [ "$rsync" = "" ]
	then
		echo "ERROR: Please install rsync first."
		clean_exit 1
	fi
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	rsync -a $path/* $target/
	if [ $? -ne 0 ]
	then
		echo "ERROR:copying backup to $target failed."
		clean_exit 1
	fi
	if [ $point_in_time -eq 1 ]
	then
		current_position $uuid
		binlogs_starting_point=$uuid
		bxfolder=$target/.backupmanager
		apply_binlogs || exit 1
	        echo "Done applying binary logs."
	else
		echo "The data at $target is ready for use."
	fi
	status=0
}

ssh_setup()
{
	if [ ! -f $HOME/.ssh/id_rsa.pub ]
	then
		ssh-keygen -q -t rsa -b 2048 -f $HOME/.ssh/id_rsa -N ''
		if [ $? -ne 0 ]
		then
			echo "error setting up public/private key pair. Exiting."
			exit 1
		fi
	fi
	ssh -oPasswordAuthentication=no -q $1 true
	if [ $? -ne 0 ]
	then
		echo "*** Setting up ssh"
		echo "Setting up public/private key authentication. Please enter $targethost password."
		cat $HOME/.ssh/id_rsa.pub | ssh -tq $1 "mkdir .ssh 2>/dev/null; chmod 755 .ssh; cat >> .ssh/authorized_keys; chmod 644 .ssh/authorized_keys"
		if [ $? -ne 0 ]
		then
			echo "error setting up public/private key pair. Exiting."
			rm -rf $HOME/.ssh/id_rsa*
			exit 1
		fi
	fi
	ssh -q $1 true
	if [ $? -ne 0 ]
	then
		echo "ssh connection to $1 was not successful. Exiting."
		exit 1
	fi
}

replication_credentials()
{
	get_repl_creds
}

pit_xid()
{
	replication_credentials
	[ "$repl_user" = "" ] && return
	build_master_cmd
	target_gtid=$(which_gtid)
	[ $target_gtid -eq 0 ] && return
	for binlog in $(echo "show binary logs" | $master_cmd 2>/dev/null | cut -f 1 | sort -r)
	do
		gtid=$(echo "show binlog events in '$binlog' limit 5" | $master_cmd 2>/dev/null | fgrep -v Gtid_list | fgrep Gtid | cut -f 6 | cut -d" " -f 3 | cut -d"-" -f 3)
		[ "$gtid" = "" ] && break
		if [ $target_gtid -ge $gtid ]
		then
			target_binlog=$binlog
			break
		fi
	done
	[ "$target_binlog" = "" ] && return
        pos=$(echo "show binlog events in '$target_binlog'" | $master_cmd 2>/dev/null | grep -E -- "GTID\ ([0-9]*)-([0-9]*)-$target_gtid($| )" | cut -f 2)
	[ "$pos" = "" ] && return
	xid=$(echo "show binlog events in '$target_binlog' from $pos" | $master_cmd 2>/dev/null | fgrep -m 1 COMMIT | sed -re "s/^(.*)\ xid=([0-9]*)\ (.*)/\2/")
	if [ "$xid" !=  "" ]
	then
		echo "update backup_history set xid = $xid  where uuid = '$backup_id';" | dbquery $DB
		echo "Great! Xid $xid for galera master decoupling has been retrieved and saved to inventory."
	fi
}

disk_space()
{
	[ ! -d $target ] && return
	disk_space_avail=$(df -h $target |  tail -1 | tr -s " " "\t" | cut -f 4)
	disk_space_avail_k=$(df -k $target |  tail -1 | tr -s " " "\t" | cut -f 4)
	disk_space_p_used=$(df -h $target |  tail -1 | tr -s " " "\t" | cut -f 5 | tr -d "%")
	disk_space_p_avail=$((100-disk_space_p_used))
}

check_slave_status()
{
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	if [ "$hb_schema" != "" -a "$hb_table" != "" -a "$hb_stale_secs" != "" ]
	then
		hb_delay=$(echo "select timestampdiff(second, ts, now()) from $hb_schema.$hb_table order by ts desc limit 1" | mysql -ANr -u $user $sock_str $pass_str)
		if [ "$hb_delay" = "" ]
		then
			true
		else
			[ $hb_delay -ge $hb_stale_secs ]
		fi
	else
		echo "show slave status\G" | mysql -Ar -u $user $sock_str $pass_str | grep -P "Slave_(.*)_Running:" | egrep -q "No|Connecting"
	fi
	if [ $? -eq 0 ]
	then
		msg="ERROR: replication is broken, will not backup stale data. Exiting."
		echo $msg
		[ "$tool" = "binlogs" ] && exit 1
		[ "$failure_notify" != "" ] && echo $msg | send_mail "$customer: backup FAILED" $failure_notify
		status=1; fire_webhook
		exit 1
	fi
}

get_lsn()
{
	lsn=$(fgrep last_lsn $target/checkpoints/$tool/xtrabackup_checkpoints 2>/dev/null | tr -d " " | cut -d"=" -f 2)
}

build_config()
{
	if [ $(id -u) -ne 0 ]
	then
		CONFIGFILE=$HOME/$CONFIGNAME
	else
		[ ! -d $CONFIGDIR ] && mkdir $CONFIGDIR
	fi
	if [ -f $CONFIGFILE ]
	then
		echo "$CONFIGFILE already exists, will not overwrite."
		exit 1
	fi
	base64 -d << DOC_EOF | gzip -dc | sed -e "s/\$VERSION/v$BM_VERSION/" > $CONFIGFILE
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
DOC_EOF

	echo "Created $CONFIGFILE. Please adjust it for your setup." 
	exit 0
}

check_server_path()
{
	while true
	do
		$ssh [ -f $server_path ] && return
		echo "ERROR: could not find MariaDB server executable '$server_path'!"
		echo -n "Please enter its location on this system (including filename): "
		read server_path
	done
}

mariadb_instance()
{
	case "$1" in
		'start')
			check_server_path
			echo -n "starting MariaDB auxiliary instance on $target... "
			$local_remote "echo 'server_id=987654321' >> $target/backup-my.cnf"
			$local_remote "echo 'lower_case_table_names=$case_insens' >> $target/backup-my.cnf"
			$ssh $server_path --defaults-file=$target/backup-my.cnf  --innodb_file_per_table  --skip-grant-tables --basedir=/usr --datadir=$target --plugin-dir=/usr/lib64/mysql/plugin --user=root --log-error=$target/backup_manager_mysqld.err $limit_str --pid-file=$target/mysql.pid --socket=/tmp/backup_manager.sock --port=65432 2>> $target/backup_manager_mysqld.err &
			sleep 10
			instance=$($ssh cat $target/mysql.pid 2>/dev/null)
			[ "$instance" = "" ] && return 1
			echo "(pid $instance)"
			$ssh kill -0 $instance 2>/dev/null
			return $?
			;;
                'stop') echo "stopping MariaDB auxiliary instance"
			$ssh kill $instance
			;;
	esac
}

# end

dim_prepare_memory()
{
        avail=$($ssh grep ^MemTotal  /proc/meminfo | sed -re "s/^MemTotal:(\s*)([0-9]*) kB/\2/")
        prepare_memory=$((avail/4))
}

run_purge_backups()
{
	purge_backups $*
}

show_logs()
{
	logfile=$(echo "select logfile from backup_history where uuid = '$1';" | dbquery $DB)
	if [ "$logfile" = "" ]
	then
		echo "backup with id '$1' not found."
		exit 1
	fi
	[ "$(which less 2>/dev/null)" != "" ] && pager="less" || pager="more"
	if [ "$(which fuser 2>/dev/null)" != "" ]
	then
        	fuser -s $logfile && tail -f $logfile || $pager $logfile
	else
        	echo -e "  loading logfile into pager, please wait... \r\c"
		$pager $logfile
	fi
}

build_binlog_list()
{
	ena=0
	binlog_list=""
	for binlog in $(ls ${binlog_base}* | grep -v index)
	do
		[ "${binlog##*/}" \> "$binlog_start" -o "${binlog##*/}" = "$binlog_start" ] && ena=1
		[ $ena -eq 0 ] && continue
		binlog_list="$binlog_list ${binlog##*/}"
	done
	binlog_list=$(echo $binlog_list | sed -e "s/${binlog##*/}//")
	if [ "${binlog_list## }" = "" ]
	then
		echo "No binary logs needing backup."
		clean_exit 0
	fi
}

position_from_binlog()
{
	cat $1 | $ssh $mysqlbinlog --no-defaults --skip-annotate-row-events --base64-output=NEVER - | fgrep -v Warning | fgrep -C10 -m1 "Start: binlog" > $aux_log
	lb_ts=$(grep "GTID " $aux_log | sed -re "s/^#([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)\s+([0-9 ]*):([0-9]*):([0-9]*) server (.*)$/20\1\2-\3\4-\5\6 \7:\8:\9/" -e "s/( )([0-9]:)/ 0\2/")
	[ "$lb_ts" = "" ] && lb_ts=$(grep "created " $aux_log | sed -re "s/^#([0-9][0-9])([0-9][0-9])([0-9][0-9])(\s*)([0-9]*):([0-9]*):([0-9]*)\s(.*)$/20\1-\2-\3 \5:\6:\7/" -e "s/( )([0-9]:)/ 0\2/")
        binlog_pos=$(grep "^# at " $aux_log | head -1 | sed -re "s/^# at ([0-9]*)/\1/")
	gtid_binlog_pos=$(cat $aux_log | tr -d "\n" | tr -d "#" | sed -re "s/(.*)\[(.*)\](.*)/\2/")
}

setup_replication()
{
	setup_repl_only=1
	build_slave $1 $2
}

get_replication_info()
{
	replication_info $1
}

safe_defaults
if [ "$1" = "debug" ]
then
	while true
	do
		sleep 10
	done
	exit 1
fi
[ "$1" = "build-config" ] && build_config
check_home_config
if [ ! -f $CONFIGFILE ]
then
	[ $# -eq 0 ] && self_doc
	echo "$CONFIGFILE not found. You can build it with: $0 build-config."
	[ $(id -u) -ne 0 ] && echo "Since you are not running as root, it will be created in your home directory."
	exit 1
fi
[ "$1" = "help" ] && self_doc
parse_config $*
setup_db
case "$1" in
	'backup') 	
		disk_space
		do_backup $2 $3 $4 $5
		exit $status
		;;
	'restore') 	
		do_restore $2 "$3" "$4" "$5"
		;;
	'remote-restore') 	
		do_remote_restore $2 "$3" "$4" "$5"
		;;
	'inventory'|'inv'|'list') 
		disk_space
		inventory $2 $3 $4
		;;
	'purge') 
		run_purge_backups $2
		;;
	'logs') 
		show_logs $2
		;;
	'build-slave') 
		build_slave $2 $3
		;;
	'print-latest') 
		print_latest
		;;
	'print-latest-id') 
		print_latest_id
		;;
	'replication-info') 
		get_replication_info $2
		;;
	'backup-type') 
		backup_type $2
		;;
	'backup-time') 
		backup_time $2
		;;
	'backup-size') 
		backup_size $2
		;;
	'validate-pit') 
		pit_dry_run $2 "$3"
		;;
	'setup-replication') 
		setup_replication $2 $3 
		;;
	'version') 
		echo $BM_VERSION
		;;
	'help')
		;;
	*) 
		[ "$1" = "" ] && self_doc || echo "$0: unkown option $1"; exit 1
		;;
esac
exit 0
