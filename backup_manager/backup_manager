#!/bin/bash
#
# MariaDB Backup Manager: a backup-tool-agnostic backup and restore script
#
# Please send bugs to pizzi@leopardus.com
#
#

# begin 

BM_VERSION="4.8.18"
CONFIGDIR=/etc/mariadb
CONFIGNAME=backup_manager.cnf
CONFIGFILE=$CONFIGDIR/$CONFIGNAME
DB=$CONFIGDIR/.backup_inventory.db
BOOTSTRAP_FILE=mysql/bckmgr_bootstrap.opt
BACKUP_LOCK_TIMEOUT=30
#
#

semaphore_setup()
{
	if [ $custom_config -eq 0 ]
        then
                if [ "$2" != "binlogs" ]
                then
                        [ $level -eq 0 ] && get_lock 1 || get_lock 0
                else
                        get_binlogs_lock
                fi
        	setup_trap $2
        else
                get_lock 1
                get_binlogs_lock wait
        	setup_trap custom
        fi
}

setup_trap()
{
	case "$1" in
		'binlogs')
        		trap 'rm -f $tmpfile $binlog_lockfile $error_log $aux_log $dbq_stderr $dumptail 2>/dev/null' 0
			;;
		'custom')
        		trap 'rm -f $tmpfile $lockfile $binlog_lockfile $error_log $aux_log $dbq_stderr $dumptail 2>/dev/null' 0
			;;
		'other')
        		trap 'rm -f $tmpfile $error_log $aux_log $dbq_stderr $dumptail 2>/dev/null' 0
			;;
		*)
        		trap 'rm -f $tmpfile $lockfile $error_log $aux_log $dbq_stderr $dumptail 2>/dev/null' 0
			;;
	esac
}

get_binlogs_lock()
{
	while true
	do
		[ ! -f $binlog_lockfile ] && break
		kill -0 $(cat $binlog_lockfile) 2>/dev/null
		[ $? -ne 0 ] && break
		if [ "$1" = "" ]
		then
			echo "Binlog or custom backup already in progress, skipping"
			exit 0
		fi
		sleep 1
	done
	echo $runtime_id > $binlog_lockfile
}

get_lock()
{
	if [ -f $lockfile ]
	then
		kill -0 $(cat $lockfile) 2>/dev/null
		if [ $? -eq 0 ]
		then	
			echo "Another backup is in progress, skipping this run."
			exit $1
		fi
	fi
	echo $runtime_id > $lockfile
}

safe_defaults()
{
	error_log=/tmp/bm.error.$$
	aux_log=/tmp/bm.aux.$$
	dumptail=/tmp/bm.dt.$$
	dbq_stderr=/tmp/dbq.stderr.$$
	tmpfile=/tmp/bm.tmp.$$
	parallelism=4
	port=3306
	dt_format="%Y-%m-%d"
	compressor="cat"
	encryptor="cat"
	uncompressor="cat"
	unencryptor="cat"
	reader="cat \$path"
	default_reader="$reader"
	purge_incomplete=0
	expire_days=0
	smart_purge=0
	smart_purge_months=6
	master_position=0
	min_disk_pfree=20
	galera=0
	runtime_id=$$
	restore_test=0
	timeout=0
	setup_repl_only=0
	enc_key_local=0
	kill_query_time=0
	status=0
	level=0
	expire_days=7
        [ "$(which less 2>/dev/null)" != "" ] && pager="less -em -Pm--more--"  || pager="cat"
	perldoc=0
        [ "$(which perldoc 2>/dev/null)" != "" ] && perldoc=1
	point_in_time=0
	set_maintenance=0
	ignore_errors=0
	master_slave=0
	skip_notification=0
	custom_config=0
	server_path="/usr/sbin/mysqld"
	cloud_storage=0
	local_remote="eval"
}

setup_db()
{
	[ "$BM_BACKUP_INVENTORY" != "" ] && DB=$BM_BACKUP_INVENTORY
	setup_sqlite_db
}

setup_sqlite_db()
{
	if [ "$(which sqlite3 2>/dev/null)" = "" ]
	then
		echo "This script requires the sqlite3 package. Please install it."
		exit 1
	fi
	if [ "$(which curl 2>/dev/null)" = "" ]
	then
		echo "This script requires the curl package. Please install it."
		exit 1
	fi
	if  [ ! -f $DB ]
	then
		(
		echo "CREATE TABLE backup_history ("
  		echo "uuid varchar(40) NOT NULL,"
		echo "runtime_id int DEFAULT NULL,"
  		echo "start_time timestamp NULL DEFAULT NULL,"
  		echo "end_time timestamp NULL DEFAULT NULL,"
  		echo "bulocation varchar(255) DEFAULT NULL,"
  		echo "logfile varchar(255) DEFAULT NULL,"
  		echo "status tinyint DEFAULT NULL,"
  		echo "level tinyint DEFAULT NULL,"
  		echo "compressor varchar(40) DEFAULT NULL,"
  		echo "uncompressor varchar(40) DEFAULT NULL,"
  		echo "encryptor varchar(40) DEFAULT NULL,"
  		echo "unencryptor varchar(40) DEFAULT NULL,"
  		echo "cryptkey varchar(255) DEFAULT NULL,"
  		echo "last_lsn bigint DEFAULT NULL,"
  		echo "backup_tool varchar(120) DEFAULT NULL,"
  		echo "server_version varchar(50) DEFAULT NULL,"
  		echo "backup_size bigint  DEFAULT NULL,"
  		echo "ref_full_backup varchar(40) DEFAULT NULL,"
  		echo "xid bigint DEFAULT NULL,"
  		echo "dumplist varchar(2000) DEFAULT NULL,"
  		echo "kubernetes_pod varchar(64) DEFAULT NULL,"
  		echo "kubernetes_bucket varchar(255) DEFAULT NULL,"
  		echo "kubernetes_db varchar(64) DEFAULT NULL,"
  		echo "checkpoint varchar(64) DEFAULT NULL,"
		echo "binlog_file varchar(64) DEFAULT NULL,"
		echo "binlog_position varchar(64) DEFAULT NULL,"
		echo "binlog_first varchar(64) DEFAULT NULL,"
		echo "binlog_last varchar(64) DEFAULT NULL,"
  		echo "binlog_last_ts timestamp NULL DEFAULT NULL,"
		echo "kubernetes_bucket_id varchar(64) DEFAULT NULL,"
		echo "kubernetes_bucket_secret varchar(64) DEFAULT NULL,"
  		echo "level13_alert tinyint DEFAULT NULL,"
		echo "gtid_binlog_pos varchar(128) DEFAULT NULL,"
  		echo "datadir_size bigint DEFAULT NULL,"
		echo "case_insensitive tinyint DEFAULT NULL,"
  		echo "PRIMARY KEY (uuid),"
  		echo "FOREIGN KEY (ref_full_backup) REFERENCES backup_history(uuid) ON DELETE CASCADE);"
		echo "CREATE INDEX start_time ON backup_history(start_time);"
		echo "CREATE INDEX ref_full ON backup_history(ref_full_backup);"
		echo "CREATE INDEX incremental_check on backup_history(backup_tool, level, status);"
		echo "CREATE INDEX binlog_last_ts ON backup_history(binlog_last_ts);"
		) | dbquery $DB
	else
		patch_sqlite_db $DB
	fi
}

patch_sqlite_db()
{
	rev=$(echo "PRAGMA table_info(backup_history);" | dbquery $1 | tail -1 | cut -d "|" -f 1)
	case "$rev" in
		'17') 	echo "ALTER TABLE backup_history ADD COLUMN xid bigint DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'18') 	echo "ALTER TABLE backup_history ADD COLUMN dumplist varchar(2000) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN kubernetes_pod varchar(64) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN kubernetes_bucket varchar(256) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN kubernetes_db varchar(64) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN checkpoint varchar(64) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'23') 	echo "ALTER TABLE backup_history ADD COLUMN binlog_file varchar(64) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'24') 	echo "ALTER TABLE backup_history ADD COLUMN binlog_position varchar(16) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'25') 	echo "ALTER TABLE backup_history ADD COLUMN binlog_first varchar(16) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN binlog_last varchar(16) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'27') 	echo "ALTER TABLE backup_history ADD COLUMN binlog_last_ts timestamp DEFAULT NULL;" | dbquery $1
			echo "CREATE INDEX binlog_last_ts ON backup_history(binlog_last_ts);" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'28') 	echo "ALTER TABLE backup_history ADD COLUMN kubernetes_bucket_id varchar(64) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN kubernetes_bucket_secret varchar(64) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'30') 	echo "ALTER TABLE backup_history ADD COLUMN level13_alert tinyint DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'31') 	echo "ALTER TABLE backup_history ADD COLUMN gtid_binlog_pos varchar(128) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'32') 	echo "ALTER TABLE backup_history ADD COLUMN datadir_size bigint DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'33') 	echo "ALTER TABLE backup_history ADD COLUMN case_insensitive tinyint DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
	esac
}

clean_exit()
{
	[ "$what" = "backup" ] && echo "delete from backup_history where uuid = '$backup_id';" | dbquery $DB
	exit $1
}

curl_before()
{
	[ "$url_before" != "" ] && curl --output - --insecure --silent --connect-timeout 10  "$url_before" > $tt/callout_before.log 2>&1
}

curl_after()
{
	[ "$url_after" != "" ] && curl --output - --insecure --silent --connect-timeout 10  "$url_after" > $tt/callout_after.log 2>&1
}

check_free_space()
{
	if [ $disk_space_p_avail -eq 0 ]
	then
		echo "ERROR: filesystem is full for target directory $target."
		msg="Filesystem for backup target directory is full. Exiting."
		echo $msg
		[ "$failure_notify" != "" ] && echo $msg | send_mail "$customer: backup FAILED" $failure_notify
		status=1; fire_webhook
			exit 1
	fi
	if [ $level -eq 0 -a $disk_space_p_avail -lt $min_disk_pfree ]
	then
		echo "ERROR: Not enough free space on target directory $target."
		msg="Filesystem has $disk_space_p_avail% ($disk_space_avail) free, but $min_disk_pfree% is required. Exiting."
		echo $msg
		[ "$failure_notify" != "" ] && echo $msg | send_mail "$customer: backup FAILED" $failure_notify
		status=1; fire_webhook
		exit 1
	fi
}

email_notification()
{
	[ -t 0 ] && return
	[ $skip_notification -eq 1 ] && return
	if [ "$failure_notify" != "" ]
	then
		if [ $status -eq 1 ]
		then
			echo "Backup failed, please run 'backup_manager logs $backup_id' for details" | send_mail "$customer: backup FAILED" $failure_notify
		else
			[ "$success_notify" != "" -a $level -eq 0 ] && inventory pretty | send_mail "$customer: backup SUCCESSFUL" $success_notify
		fi
	fi
}

run_with_timeout()
{
	pid=$(jobs -p)
	if [ $timeout -eq 0  ]
	then
		wait $pid
		status=$?
		return
	fi
	echo "NOTICE: backup_timeout in effect, timeout ${timeout}m, controller id $pid"
	countdown=$((timeout*12+1))
	while true
	do
		kill -0 $pid 2>/dev/null || break	
		countdown=$((countdown-1))
		[ $countdown -eq 0 ] && break
		sleep 5
	done
	if [ $countdown -eq 0 ]
	then
		echo "ERROR: Backup timed out. Killing it."
		pkill -9 -P $pid
		echo "Backup killed due to timeout." >> $logfile
		status=1
	else
		wait $pid
		status=$?
	fi
}

scan_binlog_archive()
{
	echo -n "scanning binlog archive.."
	for bf in $(ls $bxfolder)
	do
	t=$(cat $bf | $ssh $mysqlbinlog --no-defaults - | fgrep -m 1 "Start: binlog" | sed -re "s/^#([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)\s+([0-9 ]*):([0-9]*):([0-9]*) server (.*)$/20\1\2-\3\4-\5\6 \7:\8:\9/" -e "s/( )([0-9]:)/ 0\2/")
		if [ "$(echo "select '$t' > '$requested_binlog_ts';" | dbquery $DB)" = "1" ]
		then 
			last_b=$prev_bf
			scan_complete=1
			echo
			return
		fi
		prev_bf=$bf
		echo -n "."
	done
	echo
}

# set bxfolder before calling
apply_binlogs()
{
	bf_start_file=$(echo "select binlog_file from backup_history where uuid = '$binlogs_starting_point';" | dbquery $DB)
	bf_start_pos=$(echo "select binlog_position from backup_history where uuid = '$binlogs_starting_point';" | dbquery $DB)
	bf_start_ts=$(echo "select datetime(binlog_last_ts,'+1 second') from backup_history where uuid = '$binlogs_starting_point';" | dbquery $DB)
	[ "$bf_start_file" = "$requested_binlog_file" -a "$bf_start_pos" = "$requested_binlog_position" ] && return 0
	[ "$bf_start_ts" = "$requested_binlog_ts" ] && return 0
	bf_parent=$(echo "select ref_full_backup from backup_history where uuid = '$binlogs_starting_point';" | dbquery $DB)
	[ "$bf_parent" = "" ] && bf_parent=$binlogs_starting_point
	case_insens=$(echo "select case_insensitive from backup_history where uuid = '$bf_parent';" | dbquery $DB)
	if [ "$requested_binlog_ts" != "" ]
	then
		echo "Now applying binary logs for all events having timestamp < '$requested_binlog_ts'"
	else
		echo "Now applying binary logs up to: file $requested_binlog_file, position $requested_binlog_position"
		requested_binlog_ts="2038-01-19 03:14:07"
	fi
	initial_bf_done=0
	scan_complete=0
	echo "Inital position for binlogs: file $bf_start_file, position $bf_start_pos"
	mariadb_instance start
	if [ $? -ne 0 ]
	then
		echo "ERROR: unable to start MariaDB auxiliary instance. More info: /tmp/backup_manager_mysqld.err"
		echo "Aborting restore."
		return 1
	fi
	[ ! -d $bxfolder ] && mkdir $bxfolder
	cd $bxfolder
	wanted_seqno=${bf_start_file:(-6)}
        scan_start=$(echo "select start_time from backup_history where uuid = '$uuid';" | dbquery $DB)
        for bp in $(echo "select uuid from backup_history where backup_tool = 'binlogs' and ref_full_backup = '$bf_parent' and start_time > '$scan_start' order by start_time asc;" | dbquery $DB)
	do
		last_seqno=$(echo "select substr(binlog_last, -6) from backup_history where uuid = '$bp';" | dbquery $DB)
		[ $last_seqno -lt $wanted_seqno ] && continue
		echo "extracting binlog backup $bp"
		state_update "applying binlog backup $bp"
		extract_binlog_piece $bp  || return 1
		[ $scan_complete -eq 1 ] && break
		[ "$bp" = "$target_binlog_backup_id" ] && break
		[ "$last_file" != "" ] && break
		current_position $bp
	done
	mariadb_instance stop
	cd /tmp
	rmdir $bxfolder
	return 0
}

pit_input_error()
{
	echo "ERROR: '$1': not a valid point-in-time specification."
	echo "accepted formats: timestamp ('YYYY-MM-DD HH:MM:SS') or position (binlogfile:position)"
	exit 1
}

pit_dry_run()
{       
        if [ "$2" = "" ]
        then    
                echo "usage: $0 validate-pit <backupid> <point-in-time>"
                exit 1
        fi
        uuid=$(echo "select uuid from backup_history where uuid = '$1';" | dbquery $DB)
        if [ "$uuid" = "" ]
        then    
                echo "ERROR: backup $1 not found in inventory."
                exit 1
        fi
        validate_point_in_time "$2" dontask
        exit 0
}


validate_point_in_time()
{
	if [ "$(echo "select datetime('$1') = '${1/T/ }';" | dbquery $DB)" = "1" ]
	then
		requested_binlog_ts="${1/T/ }"
	else
		IFS=":"
		posarr=($1)
		[ ${#posarr[@]} -ne 2 ] && pit_input_error "$1"
		requested_binlog_file=${posarr[0]}
		requested_binlog_position=${posarr[1]}
		unset IFS
		echo "$requested_binlog_file" | grep -qE "^[-0-9a-z\.]+$"  || pit_input_error "$1"
		echo "$requested_binlog_position" | grep -qE "^[0-9]+$" || pit_input_error "$1"
	fi
	check_pit_availability
	if [ "$target_binlog_backup_id" = "" ]
	then
		echo "ERROR: requested point-in-time not available in the specified full backup."
		echo "Please run \"backup_manager inventory binlogs\" to verify if another backup has it."
		exit 1
	fi
	echo -n "Point-in-time recovery requested: "
	if [ "$requested_binlog_ts" = "" ]
	then
		echo "file $requested_binlog_file, position $requested_binlog_position"
	else
		echo "'$requested_binlog_ts'"
	fi
	echo "Requested point-in-time found in backup piece $target_binlog_backup_id."
	[ "$2" = "" ] && confirm_operation
	[ "$target_binlog_backup_id" != "$uuid" ] && point_in_time=1
}

pit_not_present()
{
	echo "ERROR: requested point-in-time not available in this backup."
	echo "You requested $requested_binlog_file:$requested_binlog_position and this backup starts with $bf:$bp."
	echo "Please select an older backup, or run without point-in-time recovery."
}

check_pit_availability()
{
	if [ "$requested_binlog_file" != "" ]
	then
		bf=$(echo "select binlog_file from backup_history where uuid = '$uuid';" | dbquery $DB)
		bp=$(echo "select binlog_position from backup_history where uuid = '$uuid';" | dbquery $DB)
		if [ "$bf" \> "$requested_binlog_file" ]
		then
			pit_not_present
			exit 1
		fi
		if [ "$bf" = "$requested_binlog_file" ]
		then
			if [ $bp -gt $requested_binlog_position ]
			then
				pit_not_present
				exit 1
			fi
		fi
		for bb_id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and backup_tool = 'binlogs' and status = 0 order by start_time asc;" | dbquery $DB)
		do
			bl=$(echo "select binlog_last from backup_history where uuid = '$bb_id';" | dbquery $DB)
			if [ "$bl" \> "$requested_binlog_file" -o "$bl" = "$requested_binlog_file" ]
			then
				target_binlog_backup_id=$bb_id
				return
			fi
		done
		for bb_id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and level = 1 and status = 0 order by start_time asc;" | dbquery $DB)
		do
			bl=$(echo "select binlog_file from backup_history where uuid = '$bb_id';" | dbquery $DB)
			if [ "$bl" \> "$requested_binlog_file" -o "$bl" = "$requested_binlog_file" ]
			then
				target_binlog_backup_id=$bb_id
				return
			fi
		done
	else
                blt=$(echo "select datetime(binlog_last_ts,'+1 second') from backup_history where uuid = '$uuid';" | dbquery $DB)
		[ "$requested_binlog_ts" \< "$blt" ] && return
		if [ "$requested_binlog_ts" = "$blt" ]
		then
			target_binlog_backup_id=$uuid
			return
		fi
		 pt=$(echo "select uuid from backup_history where ((datetime(binlog_last_ts,'+1 second') = '$requested_binlog_ts' and level in (0,1)) or (binlog_last_ts > '$requested_binlog_ts' and level = 3)) and status = 0 limit 1;" | dbquery $DB)
                ref=$(echo "select ref_full_backup from backup_history where uuid = '$pt';" | dbquery $DB)
		if [ "$ref" = "" ]
		then
			echo "ERROR: requested point-in-time not available in this backup."
                        exit 1
		fi
                if [ "$ref" != "$uuid" ]
                then
                        echo "ERROR: a more recent full backup exists for the requested point in time."
                        echo "In order to speed up your restore, please base it on backup id $ref."
                        exit 1
                fi
                target_binlog_backup_id=$pt
	fi
}

find_binlogs_backup_sp()
{
        last_binlog=$(echo "select binlog_file from backup_history where backup_tool = 'binlogs' and status=0 order by end_time desc limit 1;" | dbquery $DB)
	if [ "$last_binlog" = "" ]
	then
        	binlog_start=$(echo "select binlog_file from backup_history where uuid = '$1';" | dbquery $DB)
	else
		binlog_start=$last_binlog
	fi
}

send_mail()
{
	if [ $(mailx -V | fgrep -c GNU) -gt 0 ]
	then
		(
			echo "<PRE>"
			cat
			echo "</PRE>"
		) | mailx -s "$1" -a "Content-Type: text/html" $2
	else
		mailx -s "$1" $2
	fi
}

purge_incomplete()
{
	[ $purge_incomplete -eq 0 ] && return
	[ $status -eq 0 ] && return
	[ "$tt" = "" ] && return
	echo "purging incomplete backup"
	case "$tool" in
		'mariabackup'|'xtrabackup'|'mysqldump'|'smartdump') 
					rm -f $tt/$fn
					;;
		'mariaunpacked'|'mydumper') 
					mv $logfile $aux_log 2>/dev/null
					rm -rf $tt/*
					mv $aux_log $logfile 2>/dev/null
					;;
	esac
}

current_position()
{
	echo "select '(current position: ' || binlog_file || ':' || binlog_position || ', GTID: [' || gtid_binlog_pos || '], backup time: ' || binlog_last_ts || ')' from backup_history where uuid = '$1';" | dbquery $DB
}

incr_check_position()
{
	if [ $point_in_time -eq 1 ]
	then
		if [ "$requested_binlog_file" != "" ]
		then
			this_binlog_file=$(echo "select binlog_file from backup_history where uuid = '$id';" | dbquery $DB)
			[ "$this_binlog_file" \> "$requested_binlog_file" ] && return 0
			if [ "$this_binlog_file" = "$requested_binlog_file" ]
			then
				this_binlog_position=$(echo "select binlog_position from backup_history where uuid = '$id';" | dbquery $DB)
				[ $this_binlog_position -gt $requested_binlog_position ] && return 0
			fi
		else
			this_binlog_ts=$(echo "select binlog_last_ts from backup_history where uuid = '$id';" | dbquery $DB)
                        [ "$this_binlog_ts" \> "$requested_binlog_ts" ] && return 0
		fi
	fi
	return 1
}

yes_or_no()
{
	while true
	do
		read a
		case "$a" in
			'N'|'n') return 1;;
			'Y'|'y') return 0;;
			*) echo -n "Please enter Y or N: ";;
		esac
	done
}

confirm_operation()
{
	l=1
	while [ $l -eq 1 ]
	do
		echo -n "Confirm? y/N "
		read a
		case "$a" in
			'N'|'n'|'') echo "Never mind."; exit 1;;
			'Y'|'y') l=0;;
		esac
	done
}

print_latest()
{
	path=$(echo "select bulocation from backup_history where level = 0 and backup_tool in ('mariabackup','xtrabackup') and status = 0 order by start_time desc limit 1;" | dbquery $DB)
	if [ "$path" = "" ]
	then
		echo "no backups found."
		exit 1
	else
		echo $path
	fi
}

print_latest_id()
{
	id=$(echo "select uuid from backup_history where level = 0 and backup_tool in ('mariabackup','xtrabackup') and status = 0 order by start_time desc limit 1;" | dbquery $DB)
	if [ "$id" = "" ]
	then
		echo "no backups found."
		exit 1
	else
		echo $id
	fi
}

remove_files()
{
	for fn in $(echo "select bulocation || ' ' || logfile from backup_history where uuid = '$1';" | dbquery $DB)
	do
		rm -f $fn
	done
}

purge_incrementals()
{
	for ip in $(echo "select uuid from backup_history where ref_full_backup = '$1' and level=1;" | dbquery $DB)
	do
		remove_files $ip
		echo "delete from backup_history where uuid = '$ip';" | dbquery $DB
	done
}

smart_purge()
{
	keep=$(echo "select uuid || ',' || '0' from backup_history where start_time > date('now','-6 day') union select uuid || ',' || '1' from backup_history where start_time > date('now','-1 month', '-5 day') and strftime('%w', start_time)  = '0' union select uuid || ',' || '1' from backup_history where start_time > date('now','-$smart_purge_months month', '-1 month', '-6 day') and strftime('%w', start_time)  = '0' group by strftime('%m', start_time);" | dbquery $DB)
	echo -n "Purging backups using smart purge, keeping last $smart_purge_months months... "
	[ $dry -eq 1 ] && echo "(dry run)" || echo
	for fp in $(echo "select uuid from backup_history where level=0 order by start_time;" | dbquery $DB)
	do
		kf=$(echo "$keep" | fgrep $fp | head -1)
		pi=$(echo $kf | grep -c ",1$")
		if [ "$kf" != "" ]
		then
			[ $pi -eq 1 -a $dry -eq 0 ] && purge_incrementals $fp
			continue
		fi
		do_purge $fp
	done
}

do_purge()
{
	echo "purging $1"
	if [ $dry -eq 0 ]
	then
		if [ $cloud_storage -eq 0 ]
		then
			path=$(echo "select bulocation from backup_history where uuid = '$1';" | dbquery $DB)
			if [ -d $path ]
			then
				rm -rf $path
			else
				remove_files $1
			fi
			for ref_id in $(echo "select uuid from backup_history where ref_full_backup = '$1';" | dbquery $DB)
			do
				remove_files $ref_id
			done
			rmdir --ignore-fail-on-non-empty $(dirname $path)
			rmdir --ignore-fail-on-non-empty $(dirname $(dirname $path))
		fi
		(echo "PRAGMA foreign_keys=ON;"; echo "delete from backup_history where uuid = '$1';") | dbquery $DB
	fi
}

purge_backups()
{
	check_root purge
	if [ $expire_days -eq 0 -a $smart_purge -eq 0 ]
	then
		echo "purge is not properly configured."
		echo "please set either purge_days variable, or enable smart purge in config file."
		exit 1
	fi
	dry=0
	[ "$1" = "dry-run" -o "$1" = "dryrun" ] && dry=1
	if [ "$1" != "" -a $dry -eq 0 ]
	then
		if [ $(echo "select count(*) from backup_history where uuid = '$1';" | dbquery $DB) -eq 0 ]
		then
			echo "backup with id '$1' not found."
			exit 1
		fi
		echo "purging backup piece $1"
		path=$(echo "select bulocation from backup_history where uuid = '$1';" | dbquery $DB)
		if [ -d $path ]
		then
			rm -rf $path
		else
			remove_files $1
		fi
		echo "delete from backup_history where uuid = '$1';" | dbquery $DB
		return
	fi
	if [ $smart_purge -eq 1 ] 
	then
		smart_purge $1
		return
	fi
	echo -n "Purging backups older than $expire_days days... "
	[ $dry -eq 1 ] && echo "(dry run)" || echo
        [ -f $lockfile ] && r_id=$(cat $lockfile) || r_id=0
	for fp in $(echo "select uuid from backup_history where level in (0, 2, 3) and start_time < '$(date -d "today - $expire_days days" +%Y-%m-%d\ %T) and runtime_id <> $r_id order by start_time';" | dbquery $DB)
	do
		do_purge $fp
	done
}

check_home_config()
{
	if [ "$BM_CONFIG_FILE" != "" ]
	then
		CONFIGFILE=$BM_CONFIG_FILE
		return
	fi
	[ $(id -u) -eq 0 ] && return
	[ -f $HOME/$CONFIGNAME ] && CONFIGFILE=$HOME/$CONFIGNAME
}

self_doc()
{
	base64 -d << DOC_EOF | gzip -dc | sed -e "s/\$VERSION/v$BM_VERSION/" > /tmp/bmdoc.$$
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
DOC_EOF
[ $perldoc -eq 1 ] && perldoc /tmp/bmdoc.$$ || $pager /tmp/bmdoc.$$
rm -f /tmp/bmdoc.$$
}

dbquery()
{
	dbq=$(cat)
	qtr=0
	while true
	do
		echo "$dbq" | sqlite3 $* 2>$dbq_stderr
		if [ -s $dbq_stderr ]
		then
			qtr=$((qtr+1))
			sleep $((RANDOM%5+1))
			[ $qtr -lt 10 ] && continue
			echo "ERROR: Unable to update inventory. Backup will proceed nonetheless."
			echo "$(date) inventory query \"$dbq\" failed with: $(cat $dbq_stderr)" >> /tmp/backup_manager.debug
		fi
		break
	done
}

inv_dbquery()
{
	sqlite3 -column -header $*
}

validate_table_name()
{
	ts_schema=${1%.*}
	ts_table=${1#*.}
	if [ "$ts_schema" = "" -o "$ts_table" = "" ]
	then
		echo "ERROR: invalid table name $3"
		exit 1
	fi
}

inventory()
{
	sqlite_inventory $*
	rm -f $dbq_stderr 2>/dev/null
}

replication_info()
{
	rc=$(echo "select uuid || binlog_file from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$rc" = "" ] && return
	[ "$rc" = "$uuid" ] && echo "No replication info available for this backup" || echo "select 'Replication info for $1: position ' || binlog_file || ':' || binlog_position || ', GTID ' || ifnull(gtid_binlog_pos, 'N/A') from backup_history where uuid = '$1';" | dbquery $DB
}

backup_size()
{
	rc=$(echo "select datadir_size from backup_history where uuid = '$1';" | dbquery $DB)
	echo $rc
}

backup_time()
{
	rc=$(echo "select binlog_last_ts from backup_history where uuid = '$1';" | dbquery $DB)
	echo $rc
}

backup_type()
{
	rc=$(echo "select backup_tool from backup_history where uuid = '$1';" | dbquery $DB)
	echo $rc
}

parse_config()
{
	host="$BACKUP_HOST"
	port="$BACKUP_PORT"
	user="$BACKUP_USER"
	password="$BACKUP_PASSWORD"
	socket="$BACKUP_SOCKET"
	grep -q "^backup_host" $CONFIGFILE && host=$(grep "^backup_host" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^backup_port" $CONFIGFILE && port=$(grep "^backup_port" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^backup_user" $CONFIGFILE && user=$(grep "^backup_user" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^backup_password" $CONFIGFILE && password=$(grep "^backup_password" $CONFIGFILE | sed -re 's/([^=]*)=(.*)$/\2/')
	grep -q "^backup_socket" $CONFIGFILE && socket=$(grep "^backup_socket" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^target_directory" $CONFIGFILE && target=$(grep "^target_directory" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^compressor" $CONFIGFILE && compressor=$(grep "^compressor" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^uncompressor" $CONFIGFILE && uncompressor=$(grep "^uncompressor" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^encryptor" $CONFIGFILE && encryptor=$(grep "^encryptor" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^unencryptor" $CONFIGFILE && unencryptor=$(grep "^unencryptor" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^downloader" $CONFIGFILE && reader=$(grep "^downloader" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^purge_incomplete_backups" $CONFIGFILE && purge_incomplete=$(grep "^purge_incomplete_backups" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^expire_days" $CONFIGFILE && expire_days=$(grep "^expire_days" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^purge_days" $CONFIGFILE && expire_days=$(grep "^purge_days" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^smart_purge=" $CONFIGFILE && smart_purge=$(grep "^smart_purge=" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^smart_purge_months" $CONFIGFILE && smart_purge_months=$(grep "^smart_purge_months" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^customer" $CONFIGFILE && customer=$(grep "^customer" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^notify_label" $CONFIGFILE && customer=$(grep "^notify_label" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^parallelism" $CONFIGFILE && parallelism=$(grep "^parallelism" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^date_format" $CONFIGFILE && dt_format=$(grep "^date_format" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^failure_notify" $CONFIGFILE && failure_notify=$(grep "^failure_notify" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^success_notify" $CONFIGFILE && success_notify=$(grep "^success_notify" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^master_position" $CONFIGFILE && master_position=$(grep "^master_position" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^free_space_percentage" $CONFIGFILE && min_disk_pfree=$(grep "^free_space_percentage" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^callout_url_before" $CONFIGFILE && url_before=$(grep "^callout_url_before" $CONFIGFILE | sed -re 's/([^=]*)=(.*)$/\2/')
	grep -q "^callout_url_after" $CONFIGFILE && url_after=$(grep "^callout_url_after" $CONFIGFILE | sed -re 's/([^=]*)=(.*)$/\2/')
	grep -q "^galera_info" $CONFIGFILE && galera=$(grep "^galera_info" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^restore_test_directory" $CONFIGFILE && restore_test_dir=$(grep "^restore_test_directory" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^backup_timeout" $CONFIGFILE && timeout=$(grep "^backup_timeout" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^kill_query_time" $CONFIGFILE && kill_query_time=$(grep "^kill_query_time" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^open_files_limit" $CONFIGFILE && ulimit=$(grep "^open_files_limit" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^server_path" $CONFIGFILE && server_path=$(grep "^server_path" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^webhook_script" $CONFIGFILE && webhook_script=$(grep "^webhook_script" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^cloud_storage" $CONFIGFILE && cloud_storage=$(grep "^cloud_storage" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^heartbeat_schema" $CONFIGFILE && hb_schema=$(grep "^heartbeat_schema" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^heartbeat_table" $CONFIGFILE && hb_table=$(grep "^heartbeat_table" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^heartbeat_stale_seconds" $CONFIGFILE && hb_stale_secs=$(grep "^heartbeat_stale_seconds" $CONFIGFILE | cut -d"=" -f2)

	if [ "$1" = "backup" ]
	then
		if [ "$host" = "" -o "$user" = "" ]
		then
			echo "Please set backup_host and backup_user in $CONFIGFILE."
			exit 1
		fi
		if [ "$target" = "" ]
		then
			echo "Please set target_directory in $CONFIGFILE."
				exit 1
		fi
		if [ ! -d "$target" ]
		then
			echo "Target directory $target does not exist."
			exit 1
		fi
	fi
	if [ "$compressor" != "" ]
	then
		ct=$(which ${compressor/%\ */} 2>/dev/null)
		if [ "$ct" = "" ]
		then
			echo "You have configured ${compressor/%\ */}, please install it first."
			exit 1
		fi
	fi
	if [ "$encryptor" != "" ]
	then
		ct=$(which ${encryptor/%\ */} 2>/dev/null)
		if [ "$ct" = "" ]
		then
			echo "You have configured ${encryptor/%\ */}, please install it first."
			exit 1
		fi
		if [ "$(which openssl 2>/dev/null)" = "" ]
		then
			echo "ERROR: This script requires the openssl package. Please install it."
			exit 1
		fi
	fi
		[ "$BM_DOWNLOADER" != "" ] && reader=$BM_DOWNLOADER
	[ "$BM_SERVER_PATH" != "" ] && server_path=$BM_SERVER_PATH

	lockfile=/tmp/backup_manager.lock
	binlog_lockfile=/tmp/backup_manager_binlogs.lock
	if [ "$success_notify" != "" -a "$failure_notify" = "" ]
	then
		echo "NOTICE: 'failure_notify' not set in config, using email in 'success_notify' for failure notifications."
		failure_notify=$success_notify
	fi
	if [ "$failure_notify" != "" ]
	then
		mx=$(which mailx 2>/dev/null)
		if [ "$mx" = "" ]
		then
			echo "You have configured email notifications, please install the mailx utility."
			exit 1
		fi
		if [ "$customer" = "" ]
		then
			echo "You have configured email notifications, please configure customer name."
			exit 1
		fi
	fi

	if [ "$1" = "backup" ]
	then
		get_backup_level $* || usage
		semaphore_setup $*
	else
		setup_trap other
	fi
}

server_check()
{
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	find_util mysqladmin
        $util -u $user $sock_str $pass_str ping >$aux_log 2>&1
	if [ $? -ne 0 ]
	then
		echo
		echo "ERROR: cannot connect to database instance"
	else
		fgrep -iq denied $aux_log || return
		echo
		fgrep -i denied $aux_log | sed -e "s/error/ERROR/"
	fi
	echo
	echo "pre-flight checks failed, cannot continue. Exiting."
	status=1; fire_webhook
	exit 1
}

mysql_variable()
{
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	echo "select @@$1" | mysql -ANr -u $user $sock_str $pass_str
}

prepare_target()
{
	backup_id=$(date "+%s$$" | md5sum | cut -d" " -f 1)
	case "$level" in
		0) fn=full_$(date +%H:%M);;
			1) fn=incr_$(date +%H:%M);;
		2) fn=${dumplist}_$(date +%H:%M);;
		3) fn=binlogs_$(date +%H:%M);;
	esac
	case "$tool" in
		'mydumper')
				fn=""
				tt=$target/$(date +$dt_format)/${tool}_$(date +%H:%M)
				;;
		'smartdump')
				fn="smartdump_$(date +%H:%M)"
				tt=$target/$(date +$dt_format)/$tool
				;;
		'mariaunpacked')
				fn=""
				tt=$target/$(date +$dt_format)/${tool}/$(date +%H:%M)
				;;
		*)
				tt=$target/$(date +$dt_format)/$tool
				;;
	esac
	mkdir -p $tt
	echo "Target directory for this backup: $tt"
	logfile=$tt/$backup_id.log
	case "$tool" in
		'binlogs'|'zsnapshot') ;;
		*) echo "Logfile: $logfile";;
	esac
}

save_bootstrap()
{
	case "$tool" in
		'mariabackup'| 'xtrabackup' | 'mariaunpacked' )
			cp $DB $(mysql_variable datadir)/$BOOTSTRAP_FILE 2>/dev/null
			;;
	esac
}

inventory_init()
{
	case "$level" in
		1) echo "insert into backup_history values('$backup_id', $runtime_id, '$(date +%Y-%m-%d\ %T)', NULL, '$location', '$logfile', NULL, $level, '$compressor', '$uncompressor', '$encryptor', '$unencryptor', '$local_key', NULL, '$tool', '$(mysql_variable version)', NULL, '$ref_full', NULL, '$dumplist', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL);" | dbquery $DB;;
		*) echo "insert into backup_history values('$backup_id', $runtime_id, '$(date +%Y-%m-%d\ %T)', NULL, '$location', '$logfile', NULL, $level, '$compressor', '$uncompressor', '$encryptor', '$unencryptor', '$local_key', NULL, '$tool', '$(mysql_variable version)', NULL, NULL, NULL, '$dumplist', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL);" | dbquery $DB;;
	esac
}

save_datadir_size()
{
	ddsz=$(du -B 1 -s --exclude="*\.[0-9][0-9][0-9][0-9][0-9][0-9]" $(mysql_variable datadir) | cut -f 1)
	[ "$ddsz" != "" ] && echo "update backup_history set datadir_size = $ddsz where uuid = '$backup_id';" | dbquery $DB
}

update_backup_status()
{
	check_status $1
	echo "update backup_history set end_time = '$(date +%Y-%m-%d\ %T)' where uuid = '$backup_id';" | dbquery $DB
	[ $status -ne 0 ] && return
	case_insens=$(mysql_variable lower_case_table_names)
	case "$tool" in
		'mariaunpacked')
			echo "update backup_history set last_lsn = $lsn, case_insensitive = $case_insens, backup_size = $(du -bs $tt | cut -f 1) where uuid = '$backup_id';" | dbquery $DB
			pit_xid
			;;
		'mariabackup'| 'xtrabackup' )
			echo "update backup_history set last_lsn = $lsn, case_insensitive = $case_insens, backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			pit_xid
			;;
		'zsnapshot')
			echo "update backup_history set backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			;;
		'mysqldump')
			echo "update backup_history set backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			;;
		'smartdump')
			echo "update backup_history set backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			;;
		'mydumper')
			echo "update backup_history set backup_size = $(du -b $tt | cut -f 1) where uuid = '$backup_id';" | dbquery $DB
			;;
		'binlogs')
			echo "update backup_history set backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			;;
	esac
	case $level in
		0) save_datadir_size;;
		2) [ "$dumplist" = "ALL" ] && save_datadir_size;;
	esac
}

fire_webhook()
{
	[ "$webhook_script" = "" ] && return
	[ "$customer" != "" ] && export BACKUP_LABEL="$customer"
	eval $webhook_script $tool $level $status
}

perform_backup()
{
	echo "MariaDB Backup Manager $BM_VERSION starting"
	location=$tt/$fn 
	if [ "$encryptor" != "" -a "$enc_key" = "" ]
	then
		enc_key=$(openssl rand -base64 32)
		export enc_key="$enc_key"
		local_key=$enc_key
	fi
	inventory_init
	case "$tool" in
		'mariabackup')
			perform_maria_backup;;
		'zsnapshot')
			perform_zsnapshot_backup;;
		'mariaunpacked')
			perform_mariaunpacked_backup;;
		'xtrabackup')
			perform_xtra_backup;;
		'mysqldump')
			perform_mysqldump_backup;;
		'smartdump')
			perform_smartdump_backup;;
		'mydumper')
			perform_mydumper_backup;;
		'binlogs')
			perform_binlogs_backup;;
		*)
			echo "Unsupported backup tool $tool"
			clean_exit 1
			;;
	esac
}

perform_binlogs_backup()
{
	find_util mysqlbinlog
	if [ "$util" = "" ]
	then
		echo "ERROR: mysqlbinlog program not installed, but needed for binlogs backups."
		clean_exit 1
	else
		mysqlbinlog=$util
	fi
	if [ "$(mysql_variable log_bin)" != "1" ]
	then
		echo "ERROR: cannot backup binary logs if they are not enabled on server."
		clean_exit 1
	fi
	# check for a valid full backup to base binlogs backup on
	ref_id=$(echo "select uuid from backup_history where level = 0 and backup_tool in ('mariabackup','xtrabackup','mariaunpacked') and status = 0 order by start_time desc limit 1;" | dbquery $DB)
	if [ "$ref_id" = "" ]
	then
		echo "ERROR: no full backup available to base binlog backups on. Exiting."
		clean_exit 1
	else
		binlog_base=$(mysql_variable log_bin_basename)
		[ "$binlog_base" = "" ] && clean_exit 0 # server is down
		find_binlogs_backup_sp $ref_id
		build_binlog_list
		echo "Backing up binary log files" 
		echo "Files in this backup: $binlog_list"
		cd $(dirname $binlog_base)
		tar cf - $binlog_list 2>$error_log | $compressor | $encryptor 2>/dev/null > $tt/$fn
		if [ -s $error_log ]
		then
			status=1
		else
			blarr=($binlog_list)
			position_from_binlog ${binlog##*/}
			binlog_file=${binlog##*/}
			echo "update backup_history set ref_full_backup = '$ref_id' , binlog_file = '$binlog_file', binlog_position = $binlog_pos, gtid_binlog_pos='$gtid_binlog_pos', binlog_first = '${blarr[0]}', binlog_last = '${blarr[-1]}', binlog_last_ts = datetime('$lb_ts', '+1 second') where uuid = '$backup_id';" | dbquery $DB
			status=0
		fi
	fi
	update_backup_status
	fire_webhook
}

save_binlog_info()
{
	[ $status -ne 0 ] && return
	binlog_ts=$($mysqlbinlog --no-defaults --skip-annotate-row-events --base64-output=NEVER --stop-position $binlog_pos $(dirname $(mysql_variable log_bin_basename))/$binlog_file | fgrep "end_log_pos " | tail -1 | sed -re "s/^#([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+) ([0-9 ]*):([0-9]*):([0-9]*) server (.*)$/20\1\2-\3\4-\5\6 \7:\8:\9/" -e "s/( )([0-9]:)/0\2/")
	case "$tool" in
		'mariabackup'|'mariaunpacked'|'zsnapshot')
			gtid_binlog_pos=$(echo "select BINLOG_GTID_POS('$binlog_file',$binlog_pos)" | mysql -ANr -u $user $sock_str $pass_str)
			;;
	esac
}

check_status()
{
	case "$tool" in
		'mariabackup'|'xtrabackup'|'mariaunpacked')
			tail -5 $logfile | fgrep -q "completed OK"
			status=$? # override exit status from backup tool
			if [ $status -eq 1 ]
			then
				tail -1 $logfile | fgrep -q "BACKUP STAGE START: Lock wait timeout exceeded"
				if [ $? -eq 0 ]
				then
					echo
					echo "ERROR: backup could not be started due to other connection(s) holding metadata lock(s)."
					echo "This may happen if there is a bulk data load or other maintenance ongoing."
					echo "If you get this error repeatedly, it may mean that the workload is not backup compatible."
					echo "In this case, you can try and schedule the backup at a different time."
					echo
				fi
			fi
			if [ "$(mysql_variable log_bin)" = "1" -a $status -eq 0 ]
			then
                                if [ "$1" = "export" ]
                                then
                                        binlog_file=$(tail $logfile | fgrep "Last binlog file ." | sed -re "s/^(.*)\sLast binlog file \.\/(.*), position ([0-9]*)$/\2/")
                                        binlog_pos=$(tail $logfile | fgrep "Last binlog file ." | sed -re "s/^(.*)\sLast binlog file \.\/(.*), position ([0-9]*)$/\3/")
                                else
                                        binlog_file=$(tail $logfile | fgrep "MySQL binlog position:" | sed -re "s/^(.*)filename '(.*)', position '([0-9]*)'(.*)$/\2/")
                                        binlog_pos=$(tail $logfile | fgrep "MySQL binlog position:" | sed -re "s/^(.*)filename '(.*)', position '([0-9]*)'(.*)$/\3/")
                                fi
				save_binlog_info
                        fi
			echo "update backup_history set status = $status, binlog_file = '$binlog_file', binlog_position = '$binlog_pos', gtid_binlog_pos='$gtid_binlog_pos', binlog_last_ts = '$binlog_ts' where uuid = '$backup_id';" | dbquery $DB
			;;
		'zsnapshot')
			save_binlog_info
			echo "update backup_history set status = $status, binlog_file = '$binlog_file', binlog_position = '$binlog_pos', gtid_binlog_pos='$gtid_binlog_pos', binlog_last_ts = '$binlog_ts' where uuid = '$backup_id';" | dbquery $DB
			;;
		'mysqldump')
			[ -s $logfile ] && status=1
                        grep -q "^-- Dump completed" $dumptail || status=1
			echo "update backup_history set status = $status where uuid = '$backup_id';" | dbquery $DB
			;;
		'smartdump')
			ri=$(cat /tmp/smartdump_master_pos 2>/dev/null | sed -re "s/^(.*):(.*)\s(.*)$/, binlog_file = '\1', binlog_position = \2, gtid_binlog_pos = '\3'/")
			echo "update backup_history set status = $status $ri where uuid = '$backup_id';" | dbquery $DB
			;;
		*)	echo "update backup_history set status = $status where uuid = '$backup_id';" | dbquery $DB
			;;
	esac
        [ "$1" = "noprint" ] && return
	echo "Exit status of $tool was $status."
	[ $status -eq 0 ] && echo "Backup SUCCESSFUL" || echo "Backup FAILED"
}

incremental_check()
{
	[ $level -ne 1 ] && return
	extra=""
	ref_full=$(echo "select uuid from backup_history where level = 0 and backup_tool = '$tool' and status = 0 $extra order by start_time desc limit 1;" | dbquery $DB)
	if [ "$ref_full" = "" ]
	then
		msg="ERROR: no valid full backup found, cannot perform incremental backup at this time."
		echo $msg
		[ "$failure_notify" != "" ] && echo $msg | send_mail "$customer: backup FAILED" $failure_notify
		exit 1	
	fi
	echo "Performing an incremental backup based on $ref_full"
}

sqlite_inventory()
{
	echo
        echo -n "MariaDB Backup Manager v$BM_VERSION"
	echo
	echo
	[ -f $lockfile ] && g_r_id=$(cat $lockfile) || g_r_id=0
	[ -f $binlog_lockfile ] && b_r_id=$(cat $binlog_lockfile) || b_r_id=0
	case "$1" in
		'pretty'|'short') 
			width="0 0 5 0 0 10 0 0 0 9"
			echo -e ".width $width\nselect uuid as 'backup id', backup_tool as 'backup tool', case(level) when 0 then 'full' when 1 then 'incr' when 2 then 'dump' end as level, datetime(start_time) as 'start time        ', datetime(end_time) as 'end time           ', ((strftime('%s', end_time) - strftime('%s', start_time)) / 86400) || '+' || time(strftime('%s', end_time) - strftime('%s', start_time), 'unixepoch') as duration, last_lsn as 'last LSN', case when length(server_version) > 20 then substr(server_version,1,17) || '..' || substr(server_version, -1) else server_version end as 'server version', case when backup_size < 1024768 then substr('        ' || round(backup_size/1024.0, 2) || 'K', -10, 10) when backup_size between 1024768 and 1073741824 then substr('        ' || round(backup_size/1024768.0, 2) || 'M', -10, 10) else substr('        ' || round(backup_size/1073741824.0, 2) || 'G', -10, 10) end as 'backup sz', case when datadir_size < 1024768 then substr('          ' || round(datadir_size/1024.0, 2) || 'K', -9, 9) when datadir_size between 1024768 and 1073741824 then substr('          ' || round(datadir_size/1024768.0, 2) || 'M', -9, 9) else substr('          ' || round(datadir_size/1073741824.0, 2) || 'G', -9, 9) end as 'data size', case when status = 0 then 'succeeded' when status is null and runtime_id in ($g_r_id, $b_r_id) then 'running' else 'failed' end as status, case(level) when 2 then dumplist end as 'additional info' from backup_history order by start_time desc;" | inv_dbquery $DB 2>/dev/null | tee /tmp/bi$$
			;;
		'binlogs')
			width="1 0 0 5 0 0 9 9 28 13 0"
			echo -e ".width $width\nselect case(level) when 0 then 'F' else ' ' end as f, uuid as 'backup id', backup_tool as 'backup tool', case(level) when 0 then 'full' when 1 then 'incr' when 2 then 'dump' end as level, datetime(start_time) as 'start time        ', datetime(end_time) as 'end time           ', case when backup_size < 1024768 then substr('        ' || round(backup_size/1024.0, 2) || 'K', -8, 8) when backup_size between 1024768 and 1073741824 then substr('        ' || round(backup_size/1024768.0, 2) || 'M', -8, 8) else substr('        ' || round(backup_size/1073741824.0, 2) || 'G', -8, 8) end as 'disk size', case when status = 0 then 'succeeded' when status is null and runtime_id in ($g_r_id, $b_r_id) then 'running' else 'failed' end as status, case(level) when 3 then '' else binlog_file || ':' || binlog_position end as 'backup position', substr(binlog_first, -6) || '-' || substr(binlog_last, -6) as binlogs, binlog_last_ts as 'backup point-in-time'  from backup_history order by binlog_last_ts desc;" | dbquery -column -header $DB 2>/dev/null | tee /tmp/bi$$
			;;
		*) echo "select * from backup_history order by start_time desc;" | inv_dbquery $DB 2>/dev/null | tee /tmp/bi$$
			;;
	esac
	echo
	if [ ! -s /tmp/bi$$ ]
	then
		echo "There are no backups in inventory. "
	fi
	rm -f /tmp/bi$$
	[ -d $target ] && echo "Backup directory $target $disk_space_p_used% used, $disk_space_avail left" 
	echo
}

usage() 
{               
	echo "usage: $0 backup [ mariabackup | mariaunpacked | xtrabackup | zsnapshot | mydumper | mysqldump | smartdump | binlogs ]" 
	exit 1                  
}   

level_usage()
{
	echo "usage: $0 backup $1 [ full | incr ]" 
	exit 1                  
}

get_backup_level()
{
	incr=""
	case "$2" in
		'mariaunpacked') level=0;;
		'mariabackup'|'xtrabackup'|'zsnapshot')
			incr="| incr"
			case "$3" in
				'full') level=0;;
				'incr'|'incremental') [ "$incr" != "" ] && level=1;;
				*) level_usage $2;;
			esac
			;;
		'mysqldump') 	level=2
				dumplist="$3"
				[ "$dumplist" = "" -o "$dumplist" = "full" ] && dumplist="ALL"
				;;
		'smartdump') 	level=2
				;;
		'binlogs') level=3;;
		'mydumper') level=0;;
		*) 	return 1;;
	esac
	return 0
}

do_backup()
{
	check_root backup
	tool=$1
	what="backup"
	server_check
	incremental_check
	prepare_target
	check_free_space
	check_slave_status
	curl_before
	save_bootstrap
	perform_backup
	email_notification
	curl_after
	purge_incomplete
}

get_repl_creds()
{
	[ "$BM_MASTER_INFO" != "" ] && mi="$BM_MASTER_INFO" || mi=$(mysql_variable datadir 2>/dev/null)/master.info
	if [ "$mi" = "/master.info" ]
	then
		echo "WARNING: no replication info available (local server is down and BM_MASTER_INFO env var is empty)"
		return
	fi
	if [ ! -f $mi ]
	then
		echo "WARNING: no replication info available (checked $mi)"
		return
	fi
	tail -2 $mi | fgrep -q END_MARKER
	if [ $? -ne 0 ]
	then
		echo "WARNING: $mi doesn't look like valid replication info, ignoring"
		return
	fi
	lc=0
	while read -r l; do
		case $lc in
			3) repl_host="$l";;
			4) repl_user="$l";;
			5) repl_pass="$l";;
			6) repl_port="$l";;
			8) repl_ssl="$l";;
			9) repl_ssl_ca="$l";;
			11) repl_ssl_cert="$l";;
			13) repl_ssl_key="$l";;
		esac
       		lc=$((lc+1))
	done < $mi
}

which_gtid()
{
	gtid_list=$(tail $logfile | fgrep gtid_slave_pos | tr -d "'" | cut -d";" -f 1 | sed -re "s/^(.*)gtid_slave_pos\ (.*)$/\2/" | tr "," " ")
	tid=0
	for gtid in $gtid_list
	do
		this=$(echo $gtid | cut -d"-" -f3)
		[ $this -gt $tid ] && tid=$this
	done
	echo $tid
}

build_master_cmd()
{
	master_cmd="mysql -u $repl_user -p$repl_pass -h$repl_host -P$repl_port -ANr --skip-ssl --max-allowed-packet=1073741824"
}

convert_incr_to_full()
{
	lv=$(echo "select level from backup_history where uuid = '$1' and status = 0;" | dbquery $DB)
	[ "$lv" != "1" ] && return
	rf=$(echo "select ref_full_backup from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$rf" = "" ] && return
	pit=$(echo "select binlog_last_ts from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$pit" = "" ] && return
	echo "Converting request to full:$rf @ '$pit'"
	exec $0 restore $rf $2 "$pit" noconfirm
}

do_remote_restore()
{
	while true
	do
		echo -n "Please enter hostname or IP address of the remote restore target: "
		read target_host
		[ "$target_host" = "" ] && continue
		ssh -oConnectTimeout=10 root@$target_host true && break
		echo
		echo "That didn't work."
		echo "Please make sure you entered the correct information, and ssh keypair authentication is set up properly."	
		echo
		[ ! -t 0 ] && exit 1
	done
	if [ "$BM_BACKUP_PATH" = "" ]
	then    
		while true
		do
			echo -n "Please enter path where backups can be found on this host (or quit and set \$BM_BACKUP_PATH instead): "
			read backup_path
			[ "$backup_path" = "" ] && continue
			[ -d $backup_path ] && break
			echo
			echo "That didn't work."
			echo "Please enter a valid path."
			echo
		done    
	else    
		backup_path="$BM_BACKUP_PATH"
	fi      
	[ "$BM_SSH_KEY" != "" ] && ssh_key_opt="-i $BM_SSH_KEY"
	ssh="ssh -q $ssh_key_opt -oStrictHostKeyChecking=no root@$target_host"
	local_remote="$ssh"
	[ "$ulimit" = "" ] && ulimit=100000
	replication_credentials
	if [ "$repl_user" != "" ] 
	then
		admin_user="$ADMIN_USER"
		admin_pass="$ADMIN_PASSWORD"
		if [ "$admin_user" = "" -o "$admin_pass" = "" ]
	       	then
			echo "ERROR: automatic replication setup requires exporting ADMIN_USER and ADMIN_PASSWORD in the environment first. Exiting."
			exit 1
		fi
	fi
	do_restore $1 "$2" "$3" "$4"
	if [ "$repl_user" != "" ] 
	then
		$ssh chown -R mysql:mysql $2
		find_remote_mysql
		start_remote_server
		wait_for_remote_server
		user=$admin_user
		password=$admin_pass
		setup_replication $target_host $2
		echo "Replication set up successfully."
	fi
}

find_remote_mysql()
{
	if [ "$local_remote" != "eval" ]
	then
		mysqlcli=$($ssh "find / -xdev -type f -a -perm /001 -a \( -name mysql -o -name mariadb \)" | head -1)
	else
		mysqlcli=$(find / -xdev -type f -a -perm /001 -a \( -name mysql -o -name mariadb \) | head -1)
	fi
	[ "$mysqlcli" = "" ] && mysqlcli="mysql"
}

wait_for_remote_server()
{
	cd=10
	echo -n "Waiting for remote service to start..."
	while true
	do
        	echo "select 1" | $ssh $mysqlcli -u $admin_user -p$admin_pass > /dev/null 2>&1 && break
		cd=$((cd-1))
		[ $cd -eq 0 ] && break
		echo -n "."
		sleep 9
	done
	echo
	if [ $cd -eq 0 ]
	then
		echo "ERROR: server failed to start, or admin credentials not working. Exiting."
		exit 1
	fi
}

start_remote_server()
{
	
	echo -n "Starting remote server... "
	if [ "$($ssh which supervisorctl 2>/dev/null)" != "" ]
	then
		$ssh supervisorctl start mariadb
		echo
		return
	fi
	if [ "$($ssh which systemctl 2>/dev/null)" != "" ]
	then
		$ssh systemctl start mariadb.service
		echo
		return
	fi
	if [ "$($ssh which service 2>/dev/null)" != "" ]
	then
		$ssh service mariadb start
		echo
		return
	fi
	echo "ERROR: unable to start MariaDB service on remote target. Exiting."
	exit 1
}

compression_encryption_override()
{
	uncompressor=$(echo "select uncompressor from backup_history where uuid = '$1';" | dbquery $DB)
	if [ "$(which $uncompressor 2>/dev/null)" = "" ]
	then
		echo "ERROR: cannot exec '$uncompressor', is the program installed on this machine?"
		exit 1
	fi
	unencryptor=$(echo "select unencryptor from backup_history where uuid = '$1';" | dbquery $DB)
	if [ "$(which $unencryptor 2>/dev/null)" = "" ]
	then
		echo "ERROR: cannot exec '$unencryptor', is the program installed on this machine?"
		exit 1
	fi
}

find_util()
{
	util=$($ssh which $1 2>/dev/null)
	[ "$util" != "" ] && return
	util=$($ssh find / -xdev -type f -a -perm /001 -a -name $1 | head -1)
}

do_restore()
{
	check_root restore
	if [ "$1" = "" ]
	then
		echo "usage: $0 restore <backupid> <targetdir> [ <point-in-time> ]" 
		exit 1
	fi
	if [ "$1" = "test" ]
	then
		do_restore_test
		return
	fi
	convert_incr_to_full $*
	what="restore"
	uuid=$1
	if [ $(echo "select count(*) from backup_history where uuid = '$1' and level in (0, 2) and status = 0;" | dbquery $DB) -eq 0 ]
	then
		echo "full backup with id '$1' not found, or not valid."
		exit 1
	fi
	tool=$(echo "select backup_tool from backup_history where uuid = '$1';" | dbquery $DB)
	if [ "$ssh" != "" -a "$tool" != "mariabackup" ]
	then
		echo "ERROR: this backup type does not support remote restore."
		exit 1
	fi
	case "$tool" in
		'binlogs'|'mariaunpacked')	toolcheck="mysqlbinlog";;
		'zsnapshot')			toolcheck="zfs";;
		*)				toolcheck=$tool
	esac
	find_util $toolcheck
	if [ "$util" = "" ]
	then
		if [ "$toolcheck" = "mariabackup" ]
		then
			find_util mariadb-backup
			if [ "$util" = "" ]
			then
				echo "ERROR: tool $toolcheck needed to restore '$1' is not installed. Please install it."
				exit 1
			fi
		else
			echo "ERROR: tool $toolcheck needed to restore '$1' is not installed. Please install it."
			exit 1
		fi
	fi
	if [ "$tool" = "mariabackup" ]
	then
		find_util mbstream
		if [ "$util" = "" ]
		then
			echo "ERROR: tool mbstream, needed to restore '$1', is not installed. Please install it."
			exit 1
		fi
	fi
	if [ "$tool" = "xtrabackup" ]
	then
		find_util xbstream
		if [ "$util" = "" ]
		then
			echo "ERROR: tool xbstream, needed to restore '$1', is not installed. Please install it."
			exit 1
		fi
	fi
	case "$tool" in
		'mariabackup'|'xtrabackup'|'mariaunpacked'|'zsnapshot')
			if [ "$2" = "" ]
			then
				echo "usage: $0 restore [ backupid ] [ targetdir ] [ point-in-time ]"
				exit 1
			fi
			target=$2
			if [ "$target" != "-" ]
			then
				if $ssh [ -d $target ]
				then
					if [ "$($ssh ls -a1 $target | tr -d ".\n")" != "" ]
					then
						echo "ERROR: target directory $target must be empty."
						exit 1
					fi
				fi
			fi
			[ "$3" != "" ] && validate_point_in_time "$3" $4
			if [ $point_in_time -eq 1 ]
			then
				find_util mysql
				if [ "$util" = "" ]
				then
					find_util mariadb
					if [ "$util" = "" ]
					then
						echo "ERROR: mysql CLI, needed for point-in-time restore, is not installed. Please install it."
						exit 1
					else
						mysqlcli=$util
					fi
				else
					mysqlcli=$util
				fi
				find_util mysqlbinlog
				if [ "$util" = "" ]
				then
					echo "ERROR: tool mysqlbinlog, needed for point-in-time restore, is not installed. Please install it."
					exit 1
				else
					mysqlbinlog=$util
				fi
			fi
			[ "$2" != "-" ] && echo -n "Restoring backup '$uuid' using $tool to $target"
			[ "$2" != "-" ] && echo
			if [ "$target" != "-" -a "$local_remote" = "eval" ]
			then
				[ ! -d $target ] && mkdir -p $target
				logfile=$target/restore.log
			else
				logfile=/tmp/restore.log
				[ "$RESTORE_LOG" != "" ] && logfile=$RESTORE_LOG
			fi
			rm -f $logfile
			[ "$tool" != "zsnapshot" ] && echo "Logfile: $logfile"
			;;
	esac
	dim_prepare_memory
	compression_encryption_override $1
	case "$tool" in
		'mariabackup')
			perform_maria_restore;;
		'mariaunpacked')
			perform_mariaunpacked_restore;;
		'zsnapshot')
			perform_zsnapshot_restore;;
		'xtrabackup')
			perform_xtra_restore;;
		'mysqldump')
			perform_mysqldump_restore;;
		'smartdump')
			perform_smartdump_restore;;
		'mydumper')
			perform_mydumper_restore;;
	esac
	case "$tool" in
		'mariabackup'|'xtrabackup')
			if [ "$target" != "-" ]
			then
				echo "Exit status of $tool was $status."
				if [ $restore_test -eq 1 ]
				then
					if [ $status -eq 0 ]
					then
						[ "$success_notify" != "" ] && echo "Restore test successful. Details in /tmp/restore.log" | send_mail "$customer: restore test SUCCESSFUL" $success_notify 
					else
						[ "$failure_notify" != "" ] && echo "Restore test FAILED, please see /tmp/restore.log for details" | send_mail "$customer: restore test FAILED" $failure_notify
					fi
				else
					if [ $status -eq 0 ]
					then
						echo "Restore complete."
						[ "$repl_user" = "" ] && echo "Please don't forget to chown -R mysql:mysql $target."
					else
						echo "ERROR: restore failed! Please see $logfile for details."
						exit 1
					fi
				fi
			else
				echo $status > /tmp/build_slave.status
			fi
			;;
	esac
}

inventory_cleanup()
{
	exit 1
}

extract_binlog_piece()
{
	path=$(echo "select bulocation from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$backup_path" != "" ] && path=$backup_path/$(echo $path | sed -re "s/^(.*)\/([0-9-]*)\/(.*)\/(.*)$/\2\/\3\/\4/")
	key=$(echo "select cryptkey from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	if [ "$reader" = "$default_reader" -a ! -f $path ]
	then
		echo "ERROR: binlogs backup archive not found. Aborting restore."
		mariadb_instance stop
		return 1
	fi
	eval $reader | $unencryptor 2>/dev/null | $uncompressor | tar xf -
	first_b=$(basename $(ls -1 $bxfolder/* | head -1))
	last_b=$(basename $(ls -1 $bxfolder/* | tail -1))
	if [ "$requested_binlog_file" != "" ]
	then
		[ "$last_b" \> "$requested_binlog_file" ] && last_b=$requested_binlog_file
	else
		scan_binlog_archive
		if [ "$last_b" = "" ]
 		then
 			echo "ERROR: required binlog $bf_start_file not available. Aborting restore."
			mariadb_instance stop
 			return 1
 		fi
	fi
	[ "$bf_start_file" \> "$first_b" ] && first_b=$bf_start_file
	echo -n "applying binlog files from $first_b to $last_b.."
	for bf in $(ls $bxfolder)
	do
		[ "$bf_start_file" \> "$bf" ] && continue
		echo -n "."
		if [ "$bf" != "$requested_binlog_file" ]
		then
			if [ $initial_bf_done -eq 1 ]
			then
				cat $bxfolder/$bf | $local_remote $mysqlbinlog --no-defaults --stop-datetime="'$requested_binlog_ts'" - | $ssh mysql -A -S /tmp/backup_manager.sock 2>$aux_log
			else
				initial_bf_done=1
				cat $bxfolder/$bf | $local_remote $mysqlbinlog --no-defaults --start-position=$bf_start_pos --stop-datetime="'$requested_binlog_ts'" - | $ssh mysql -A -S /tmp/backup_manager.sock 2>$aux_log
			fi
			if [ $? -ne 0 ]
			then
				echo
				echo "ERROR: apply of binary log $bf failed!"
				cat $aux_log
				echo "Aborting restore."
				mariadb_instance stop
				return 1
			fi
		else
			last_file=$bf
			if [ $initial_bf_done -eq 1 ]
			then
				cat $bxfolder/$bf | $local_remote $mysqlbinlog --no-defaults --stop-position=$requested_binlog_position --stop-datetime="'$requested_binlog_ts'" - | $ssh mysql -A -S /tmp/backup_manager.sock 2>$aux_log
			else
				cat $bxfolder/$bf | $local_remote $mysqlbinlog --no-defaults --start-position=$bf_start_pos --stop-position=$requested_binlog_position --stop-datetime="'$requested_binlog_ts'" - | $ssh mysql -A -S /tmp/backup_manager.sock 2>$aux_log
			fi
			if [ $? -ne 0 ]
			then
				echo
				echo "ERROR: apply of binary log $bf failed!"
				cat $aux_log
				echo "Aborting restore."
				mariadb_instance stop
				return 1
			fi
			break
		fi
		[ "$bf" = "$last_b" ] && break
	done
	echo
	rm -f $bxfolder/*
	return 0
}

check_root()
{
	if [ $(id -u) -ne 0 ]
        then
                echo "the $1 command requires superuser privileges. Exiting."
                exit 1
        fi
}

backup_stage()
{
	case "$1" in
		'START') echo -n "BACKUP STAGE: $1 ";;
		'END') echo "$1";;
		*) echo -n "$1 ";;
	esac
	echo "backup stage $1;" >&${mysqlc[1]}
	while read -t 0.2 -u ${mysqlc[0]} row
	do
		echo "$row"
	done > $aux_log
	fgrep -q "Query OK," $aux_log 2>/dev/null
	if [ $? -ne 0 ]
	then
		echo
		cat $aux_log
		echo "Exiting."
		clean_exit 1
	fi
}

zfs_purge_snapshots()
{
	[ $level -ne 0 ] && return
	id=$(echo "select uuid from backup_history where level = 0 and backup_tool = 'zsnapshot' and status = 0 order by start_time desc limit 1;" | dbquery $DB)
	[ "$id" = "" ] && return
	for ip in $(echo "select uuid from backup_history where ref_full_backup = '$id' and level=1;" | dbquery $DB)
	do
		zfs destroy ${snap_t:1}@$ip
	done
	zfs destroy ${snap_t:1}@$id
}

zfs_preflight_checks()
{
	d=$(mysql_variable datadir)
	if [ "$(df -t zfs $d/ibdata1 2>/dev/null)" = "" ]
	then
		echo "ERROR: snapshot backup requires that datadir is on a ZFS filesystem. Exiting."
		clean_exit 1
	fi
	z=$(which zfs 2>/dev/null)
	if [ "$z" = "" ]
	then
		echo "Please install the zfs command."
		clean_exit 1
	fi
	zfs_purge_snapshots
}

perform_zsnapshot_backup()
{
	find_util mysqlbinlog
	if [ "$util" = "" ]
	then
		echo "ERROR: cannot find mysqlbinlog tool, please make sure it is installed."
		clean_exit 1
	else
		mysqlbinlog=$util
	fi
	echo "Performing backup using ZFS snapshot."
	snap_t=$(stat -Lc %m $(mysql_variable datadir))
	zfs_preflight_checks
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	coproc mysqlc { script -c "mysql -ANr -u $user $sock_str $pass_str 2>&1" /dev/null; }
	backup_stage START
	backup_stage FLUSH
	backup_stage BLOCK_DDL
	backup_stage BLOCK_COMMIT
	zfs snapshot ${snap_t:1}@$backup_id 2>$aux_log
	if [ $? -ne 0 ]
	then
		echo "ERROR: zfs snapshot command failed!"
		cat $aux_log
		echo "Exiting."
		clean_exit 1
	fi
	ms=$(echo "show master status" | mysql -ANr -u $user $sock_str $pass_str 2>$aux_log)
	if [ "$ms" = "" ]
	then
		echo -n "ERROR: cannot obtain master status: "
		cat $aux_log
		echo "Exiting."
		clean_exit 1
	fi
	binlog_file=$(echo "$ms" | cut -f 1)
	binlog_pos=$(echo "$ms" | cut -f 2)
	backup_stage END
	echo -n "Saving snapshot... "
	case "$level" in
		0)
			zfs send ${snap_t:1}@$backup_id | $compressor | $encryptor > $tt/$fn 2>$aux_log
			;;
		1)
			zfs send -i @$ref_full ${snap_t:1}@$backup_id | $compressor | $encryptor > $tt/$fn 2>$aux_log
			;;
	esac
	if [ $? -ne 0 ]
	then
		echo "ERROR: zfs send command failed!"
		cat $aux_log
		echo "Exiting."
		clean_exit 1
	fi
	echo
	update_backup_status
	fire_webhook
}

perform_maria_backup()
{
	find_util mariabackup
	if [ "$util" = "" ]
	then
		find_util mariadb-backup
		if [ "$util" = "" ]
		then
			echo "ERROR: Please install $tool first."
		else
			mariabackup=$util
		fi
		clean_exit 1
	else
		mariabackup=$util
	fi
	echo "Performing backup using $tool."
	find_util mysqlbinlog
	if [ "$util" = "" ]
	then
		echo "ERROR: cannot find mysqlbinlog tool, please make sure it is installed."
		clean_exit 1
	else
		mysqlbinlog=$util
	fi
	mkdir -p $target/checkpoints/mariabackup
	open_files_limit
	[ "$password" != "" ] && pass_str="--password=$password"
	[ "$socket" != "" ] && sock_str="--socket=$socket"
	[ $galera -eq 1 ] && galera_str="--galera-info"
	[ $kill_query_time -gt 0 ] && kill_str="--kill-long-queries-timeout=$kill_query_time --kill-long-query-type=SELECT"
	case $level in
		0)
			$mariabackup --backup $galera_str $kill_str $limit_str --user=$user $pass_str $sock_str --parallel=$parallelism --extra-lsndir=/tmp --stream=xbstream --slave-info --ftwrl-wait-timeout=$BACKUP_LOCK_TIMEOUT --ftwrl-wait-threshold=999999 --target-dir=$tt 2>> $logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/mariabackup 2>/dev/null
			;;
		1)
			cp $target/checkpoints/mariabackup/xtrabackup_checkpoints /tmp 2>/dev/null
			$mariabackup --backup $galera_str $kill_str $limit_str --incremental-basedir=$target/checkpoints/mariabackup --user=$user $sock_str $pass_str --parallel=$parallelism --extra-lsndir=/tmp --stream=xbstream --slave-info --ftwrl-wait-timeout=$BACKUP_LOCK_TIMEOUT --ftwrl-wait-threshold=999999 --target-dir=$tt 2>> $logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/mariabackup 2>/dev/null
			;;
	esac
	get_lsn
	update_backup_status
	fire_webhook
}

open_files_limit()
{
	[ "$ulimit" = "" ] && return
	limit_str="--open-files-limit=$ulimit"
	if [ "$local_remote" != "eval" ]
	then
		curr_fmax=$($ssh cat /proc/sys/fs/file-max)
		[ $curr_fmax -lt $ulimit ] && $ssh "echo $((ulimit+curr_fmax)) > /proc/sys/fs/file-max"
	else
		curr_fmax=$(cat /proc/sys/fs/file-max)
		[ $curr_fmax -lt $ulimit ] && echo $((ulimit+curr_fmax)) > /proc/sys/fs/file-max
	fi
}

perform_mariaunpacked_backup()
{
	find_util mariabackup
	if [ "$util" = "" ]
	then
		find_util mariadb-backup
		if [ "$util" = "" ]
		then
			echo "ERROR: Please install $tool first."
		else
			mariabackup=$util
		fi
		clean_exit 1
	else
		mariabackup=$util
	fi
	echo "Performing backup using $tool."
	find_util mysqlbinlog
	if [ "$util" = "" ]
	then
		echo "ERROR: cannot find mysqlbinlog tool, please make sure it is installed."
		clean_exit 1
	else
		mysqlbinlog=$util
	fi
	mkdir -p $target/checkpoints/mariaunpacked
	[ "$password" != "" ] && pass_str="--password=$password"
	[ "$socket" != "" ] && sock_str="--socket=$socket"
	[ $galera -eq 1 ] && galera_str="--galera-info"
	[ $kill_query_time -gt 0 ] && kill_str="--kill-long-queries-timeout=$kill_query_time --kill-long-query-type=SELECT"
	case $level in
		0)
			$mariabackup --backup $galera_str $kill_str --user=$user $pass_str $sock_str --parallel=$parallelism --extra-lsndir=/tmp --slave-info --ftwrl-wait-timeout=$BACKUP_LOCK_TIMEOUT --ftwrl-wait-threshold=999999 --target-dir=$tt 2>> $logfile &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/mariaunpacked 2>/dev/null
			;;
		1)	# NOT IMPLEMENTABLE
			;;
	esac
        check_status noprint
        [ $status -ne 0 ] && return
	open_files_limit
        dim_prepare_memory
        $mariabackup --prepare $limit_str --export --use-memory=${prepare_memory}K --target-dir=$tt >> $logfile 2>&1
        status=$?
        [ $status -ne 0 ] && return
        tail -1 $logfile | fgrep -q "completed OK"
        status=$?
	fire_webhook
        [ $status -ne 0 ] && return
        get_lsn
        update_backup_status export
        echo "Backup prepared successfully for export."
}

perform_xtra_backup()
{
	xtrabackup=$(which xtrabackup 2>/dev/null)
	if [ "$xtrabackup" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool."
	fi
	mkdir -p $target/checkpoints/xtrabackup
	[ "$password" != "" ] && pass_str="--password=$password"
	[ "$socket" != "" ] && sock_str="--socket=$socket"
	[ $galera -eq 1 ] && galera_str="--galera-info"
	[ $kill_query_time -gt 0 ] && kill_str="--kill-long-queries-timeout=$kill_query_time --kill-long-query-type=SELECT"
	case $level in
		0)
			xtrabackup --backup $galera_str $kill_str --user=$user $pass_str $sock_str --parallel=$parallelism --extra-lsndir=/tmp --target-dir=$tt --stream=xbstream --slave-info 2>> $logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/xtrabackup 2>/dev/null
			;;
		1)
			cp $target/checkpoints/xtrabackup/xtrabackup_checkpoints /tmp 2>/dev/null
			xtrabackup --backup $galera_str $kill_str --incremental-basedir=$target/checkpoints/xtrabackup --user=$user $pass_str $sock_str --parallel=$parallelism --extra-lsndir=/tmp --target-dir=$tt --stream=xbstream --slave-info 2>> $logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/xtrabackup 2>/dev/null
			;;
	esac
	get_lsn
	update_backup_status
	fire_webhook
}

perform_mydumper_backup()
{
	mydumper=$(which mydumper 2>/dev/null)
	if [ "$mydumper" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool." 
		[ "$compressor" != "cat" ] && echo "Note: compression configured in config file, but $tool will use its built-in compression instead."
		[ "$encryptor" != "cat" ] && echo "Warning: encryption configured in config file, but not supported by $tool, hence setting ignored."
	fi
	[ $kill_query_time -gt 0 ] && kill_str="-l $kill_query_time -K"
	case $level in
		0)
			[ "$password" != "" ] && pass_str="-p $password"
			[ "$socket" != "" ] && sock_str="-S $socket"
			$mydumper -o $tt -t $parallelism -L $logfile $kill_str -G -E -R -v 3 -c -h $host -P $port $sock_str -u $user $pass_str &
			run_with_timeout
			;;
		1)
			echo "Incremental backups not supported by $tool. Exiting."
			clean_exit 1
			;;
	esac
	update_backup_status
	fire_webhook
}

set_read_only()
{
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	[ "$port" != "" ] && port_str="-P$port"
	echo "set global read_only=$1" | mysql -A -u $user $sock_str $pass_str $port_str
}

perform_smartdump_backup()
{
	smartdump=$(which smartdump 2>/dev/null)
	if [ "$smartdump" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool."
	fi
	ro=$(mysql_variable read_only)
	[ "$ro" = "1" ] && set_read_only 0
	[ "$password" != "" ] && pass_str="--password $password"
	[ "$socket" != "" ] && sock_str="--socket $socket"
	[ "$port" != "" ] && port_str="--port $port"
	$smartdump  --dump --lock-timeout=30 --threads $parallelism --host $host --user $user $pass_str $sock_str $port_str 2>$logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
	run_with_timeout
	[ "$ro" = "1" ] && set_read_only 1
	update_backup_status
	fire_webhook
}

perform_mysqldump_backup()
{
	mysqldump=$(which mysqldump 2>/dev/null)
	if [ "$mysqldump" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool."
	fi
	[ "$dumplist" = "ALL" ] && dbstr="--all-databases --master-data=2" || dbstr="--databases ${dumplist//,/ }"
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	[ "$port" != "" ] && port_str="-P$port"
	[ $master_position -eq 1 ] && mp_str="--dump-slave=2"
	$mysqldump --single-transaction --routines --triggers $mp_str --log-error=$logfile --max_allowed_packet=1G -h $host $port_str $sock_str -u $user $pass_str $dbstr | tee >(tail -1 > $dumptail) | $compressor | $encryptor 2>/dev/null > $tt/$fn &
	run_with_timeout
	update_backup_status
	fire_webhook
}

perform_mydumper_restore()
{
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	echo "To restore this $tool dump, please use: myloader -d $path ..."
	exit 0
}

perform_smartdump_restore()
{
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	[ "$password" != "" ] && pass_str="--password $password"
	[ "$socket" != "" ] && sock_str="--socket $socket"
	[ "$port" != "" ] && port_str="--port $port"
	eval $reader | $unencryptor 2>/dev/null | $uncompressor | smartdump --stream --threads $parallelism --host $host --user $user $pass_str $sock_str $port_str
	status=$?
}

perform_mysqldump_restore()
{
	if [ -t 1 ]
	then
		echo "To restore this $tool dump, please use: $0 restore $uuid | mysql -h ... "
		exit 1
	fi
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	eval $reader | $unencryptor 2>/dev/null | $uncompressor
	status=$?
}

do_restore_test()
{
	tb=$(echo "select uuid from backup_history where level = 0 and status = 0 and backup_tool in ('mariabackup', 'xtrabackup') order by start_time desc limit 1;" | dbquery $DB)
	if [ "$tb" = "" ]
	then
		msg="no valid backup found to perform a restore test. Exiting."
		echo "ERROR: $msg"
		[ ! -t 1 -a "$failure_notify" != "" ] && echo $msg | send_mail "$customer: restore test FAILED" $failure_notify
		return
	fi
	echo "Performing a test restore of backup $tb and related incrementals"
	restore_test=1
	[ "$restore_test_dir" != "" ] && do_restore $tb $restore_test_dir/RESTORE-TEST || do_restore $tb $target/RESTORE-TEST
	mv $logfile /tmp/
	echo "Removing restore test directory $target. Details of this test execution can be found in /tmp/restore.log."
	rm -rf $target
	exit $status
}

build_slave()
{
	check_root build_slave
	if [ "$1" = "" -o "$2" = "" ]
	then
		echo "usage: $0 build-slave [ targethost ] [ targetdir ]"
		exit 1
	fi
	replication_credentials
	if [ "$repl_user" = "" ] 
	then
		echo "Not a slave myself, cannot build another slave. Exiting."
		exit 1
	fi
	ssh_setup $1
	echo "*** Login to $1 successful"
	if [ $setup_repl_only -eq 0 ]
	then
		ssh -q $1 test -d $2
		if [ $? -ne 0 ]
		then
			ssh -q $1 mkdir $2
			if [ $? -ne 0 ]
			then
				echo "error creating target directory $2 on $1. Exiting."
				exit 1
			fi
		fi
		if [ "$(ssh -q $1 ls -1 $2)" != "" ]
		then
			echo "target directory $2 on target host $1 must be empty. Exiting."
			exit 1
		fi
        	uuid=$(echo "select uuid from backup_history where level = 0 and backup_tool in ('mariabackup','xtrabackup') and status = 0 order by start_time desc limit 1;" | dbquery $DB)
		if [ "$uuid" = "" ]
		then
			echo "no backup suitable for slave build found in inventory. Exiting."
			exit 1
		fi
        	tool=$(echo "select backup_tool from backup_history where uuid = '$uuid';" | dbquery $DB)
		case "$tool" in
			'mariabackup') rtool="mbstream"; ropts="-p $parallelism";;
			'xtrabackup') rtool="xbstream"; ropts="";;
		esac
		ssh -q $1 id mysql >/dev/null 2>&1
		if [ $? -ne 0 ]
		then
			echo "ERROR: MariaDB not found. Please install MariaDB-server package on $1 and retry."
			exit 1
		fi
		ssh -q $1 which $rtool >/dev/null 2>&1
		if [ $? -ne 0 ]
		then
			echo "ERROR: $rtool is not installed on $1. Please install the $tool package there and retry."
			exit 1
		fi
		echo "*** Streaming last good full backup ($uuid) to $1:$2"
		r_uncompressor=$uncompressor
		uncompressor="cat" 
		do_restore $uuid - | ssh -q $1 "$r_uncompressor | $rtool $ropts -v -x -C $2"
		status=$(cat /tmp/build_slave.status)
		if [ $status -ne 0 ]
		then
			echo "Streaming error detected! Exiting."
			exit 1
		fi
		echo "*** Preparing backup on $1"
        	avail=$(ssh -q $1 "grep ^MemTotal /proc/meminfo" | sed -re "s/^MemTotal:(\s*)([0-9]*) kB/\2/")
		["$avail" = "" ] && avail=16777216
        	prepare_memory=$((avail/4))
		[ "$tool" = "mariabackup" ] && open_files_limit
		ssh -q $1 $tool --prepare $limit_str --use-memory=${prepare_memory}K --target-dir=$2
		echo "*** Fixing permissions on $1"
		ssh -q $1 chown -R mysql:mysql $2
		echo "*** Starting MariaDB on $1"
		ssh -q $1 service mysql start
		if [ $? -ne 0 ]
		then
			ssh -q $1 service mariadb start
			if [ $? -ne 0 ]
			then
				echo "MariaDB failed to start. Stopping here."
				echo "You can start it by hand and resume the process with: '$0 setup-replication $*'"
				exit 1
			fi
		fi
	fi
	if [ "$repl_user" != "" ]
	then
		state_update "setting up replication"
		echo "*** Setting up replication on $1"
		[ "$password" != "" ] && pass_str="-p$password"
		config_lookup $1 socket || build_slave_failure $*
		[ "$cfg" != "" ] && sock_str="-S$cfg" || sock_str=""
		( 
			echo "RESET MASTER;"
			echo "CHANGE MASTER TO MASTER_HOST='$repl_host', MASTER_PORT=$repl_port, MASTER_USER='$repl_user', MASTER_PASSWORD='$repl_pass';"
			if [ "$BM_FILE_POS" != "" -a "$BM_CLEAR_GTID_POS" = "" ]
			then
				chgc=$(ssh -q $1 cat $2/xtrabackup_binlog_info | sed -re "s/^(.*)\.([0-9]*)\s([0-9]*)\s(.*)$/MASTER_LOG_FILE='\1.\2', MASTER_LOG_POS=\3/")
				echo "CHANGE MASTER TO $chgc;"
			else
				gtid=$(ssh -q $1 cat $2/xtrabackup_binlog_info | sed -re "s/^(.*)\s+(.*)\s+(.*)/\3/")
				if [ "$gtid" = "" -a "$BM_OVERRIDE_GTID_POS" = "" -a "$BM_CLEAR_GTID_POS" = "" ]
				then
					echo "Unable to get GTID info for replication. Are GTIDs enabled on backup server?"
					exit 1
				fi
				if [ "$BM_CLEAR_GTID_POS" = "" ]
				then
					if [ "$BM_OVERRIDE_GTID_POS" != "" ]
					then
						echo "SET GLOBAL gtid_slave_pos = '$BM_OVERRIDE_GTID_POS';"
					else
						echo "SET GLOBAL gtid_slave_pos = '$gtid';"
					fi
					echo "CHANGE MASTER TO MASTER_USE_GTID=slave_pos;"
				fi
			fi
			[ "$repl_ssl" = "1" ] && echo "CHANGE MASTER TO MASTER_SSL=1, MASTER_SSL_CA='$repl_ssl_ca', MASTER_SSL_CERT='$repl_ssl_cert', MASTER_SSL_KEY='$repl_ssl_key';"
			echo "START SLAVE;" 
			if [ "$BM_CLEAR_GTID_POS" != "" ]
			then
				echo "SELECT SLEEP(5);"
				echo "STOP SLAVE;"
				echo "CHANGE MASTER TO MASTER_USE_GTID=slave_pos;"
				echo "START SLAVE;"
			fi
		) | ssh -q $1 "tee /tmp/bm.change_master | $mysqlcli -ANr -u $user $sock_str $pass_str" || build_slave_failure $*
		sleep 10
		success=$(echo "show slave status\G" | ssh -q $1 $mysqlcli -Ar -u $user $sock_str $pass_str | grep 'Running:' | fgrep -c Yes)
		if [ "$success" = "2" ]
		then
			echo "*** Slave started successfully!"
		fi
	fi
	[ $setup_repl_only -eq 0 ] && echo "*** Build complete."
}

build_slave_failure()
{
	[ $setup_repl_only -eq 0 ] && echo "Replication setup failed."
	echo "Please fix the issue and retry with: '$0 setup-replication $*'"
	exit 1
}

config_lookup()
{
	cfg=$(ssh -q $1 "find /etc/my* -type f -name \*.cnf | xargs grep -rh ^$2" | sort | uniq | tr -d "[ \t]" | cut -d"=" -f 2)
	if [ $(echo "$cfg" | wc -w) -gt 1 ]
	then
		echo "ERROR: found multiple config values for $2!"
		return 1
	fi
	return 0
}

perform_xtra_restore()
{
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	if [ "$target" != "-" ]
	then
		mkdir -p $target/full
		echo -n "extracting full backup $uuid... "
		echo "--> eval $reader | $unencryptor | $uncompressor | xbstream -p $parallelism -x -v -C $target/full" >> $logfile
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | xbstream -p $parallelism -x -v -C $target/full 2>> $logfile
	else
		eval $reader | $unencryptor 2>/dev/null | $uncompressor 2>> $logfile
		status=$?
		return
	fi
	status=$?
	echo
	[ $status -ne 0 ] && return
	echo -n "applying redo logs for $uuid... "
	echo "--> xtrabackup --prepare --apply-log-only --use-memory=${prepare_memory}K --target-dir=$target/full" >> $logfile
	xtrabackup --prepare --apply-log-only --use-memory=${prepare_memory}K --target-dir=$target/full >> $logfile 2>&1
	status=$?
	echo
	[ $status -ne 0 ] && return
	tail -1 $logfile | fgrep -q "completed OK"
	status=$?
	[ $status -ne 0 ] && return
	binlogs_starting_point=$uuid
	for id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and backup_tool = '$tool' and status =0 order by start_time asc;" | dbquery $DB)
	do
		incr_check_position $id && break
		path=$(echo "select bulocation from backup_history where uuid = '$id';" | dbquery $DB)
		key=$(echo "select cryptkey from backup_history where uuid = '$id';" | dbquery $DB)
		[ "$key" != "" ] && export enc_key="$key"
		incdir=$(basename $path)
		echo -n "extracting incremental backup $id... "
		mkdir -p $target/$incdir
		echo "--> eval $reader | $unencryptor | $uncompressor | xbstream -p $parallelism -x -v -C $target/$incdir" >> $logfile
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | xbstream -p $parallelism -x -v -C $target/$incdir 2>> $logfile
		status=$?
		echo
		[ $status -ne 0 ] && break
		echo -n "applying redo logs for $id... "
		echo "--> xtrabackup --prepare --apply-log-only --use-memory=${prepare_memory}K --target-dir=$target/full --incremental-dir=$target/$incdir" >> $logfile
		xtrabackup --prepare --apply-log-only --use-memory=${prepare_memory}K --target-dir=$target/full --incremental-dir=$target/$incdir >> $logfile 2>&1
		status=$?
		echo
		[ $status -ne 0 ] && break
		tail -1 $logfile | fgrep -q "completed OK"
		status=$?
		[ $status -ne 0 ] && break
		binlogs_starting_point=$id
		rm -rf $target/$incdir
	done
	[ $status -ne 0 ] && return
	echo -n "final preparation of backup... "
	echo "--> xtrabackup --prepare --use-memory=${prepare_memory}K --target-dir=$target/full" >> $logfile 
	xtrabackup --prepare --use-memory=${prepare_memory}K --target-dir=$target/full >> $logfile 2>&1
	status=$?
	echo
	[ $status -ne 0 ] && return
	tail -1 $logfile | fgrep -q "completed OK"
	status=$?
	mv $target/full/* $target/
	rmdir $target/full
	if [ $status -eq 0 -a $point_in_time -eq 1 ]
	then
		bxfolder=$target/.backupmanager
		apply_binlogs || exit 1
	        echo "Done applying binary logs."
	fi
}

perform_zsnapshot_restore()
{
	snap_t=$(stat -Lc %m $target)
	if [ "$(df -t zfs $snap_t 2>/dev/null)" = "" ]
	then
		echo "ERROR: restoring a snapshot requires that target dir is on a ZFS filesystem. Exiting."
		clean_exit 1
	fi
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	echo -n "restoring full snapshot $uuid... "
	eval $reader | $unencryptor 2>/dev/null | $uncompressor | zfs recv -u ${target:1} 2>$aux_log
	if [ $? -ne 0 ]
	then
		echo
		echo "ERROR: zfs receiver failed! Exiting."
		cat $aux_log
		exit 1
	else
		echo -n " OK "
	fi
	current_position $uuid
	binlogs_starting_point=$uuid
	if [ "$requested_binlog_ts" != "" ]
	then
		this_binlog_ts=$(echo "select binlog_last_ts from backup_history where uuid = '$uuid';" | dbquery $DB)
		[ "$this_binlog_ts" = "$requested_binlog_ts" ] && restore_incr=0 || restore_incr=1
	else
		restore_incr=1
	fi
	if [ $restore_incr -eq 1 ]
	then
		for id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and backup_tool = '$tool' and status = 0 order by start_time asc;" | dbquery $DB)
		do
			if [ $point_in_time -eq 1 ]
			then
				this_binlog_ts=$(echo "select binlog_last_ts from backup_history where uuid = '$id';" | dbquery $DB)
				[ "$this_binlog_ts" = "$requested_binlog_ts" ] && break
			fi
		done
		path=$(echo "select bulocation from backup_history where uuid = '$id';" | dbquery $DB)
		key=$(echo "select cryptkey from backup_history where uuid = '$id';" | dbquery $DB)
		[ "$key" != "" ] && export enc_key="$key"
		echo -n "restoring incremental snapshot $id... "
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | zfs recv -u ${target:1} 2>$aux_log
		if [ $? -ne 0 ]
		then
			echo
			echo "ERROR: zfs receiver failed! Exiting."
			cat $aux_log
			exit 1
		else
			echo -n " OK "
			current_position $id
			binlogs_starting_point=$id
		fi
	fi
	zfs mount ${target:1}
	echo "Restore complete, datadir restored to $target."
}

state_update()
{
	echo "$1" > /tmp/bm_restore_state_$target_host
}

perform_maria_restore()
{
	mb_ver=$($ssh mariabackup --version 2>&1 | sed -re "s/(.*)server (.[0-9])\.([0-9])(.*)/\2.\3/")
	[ "$mb_ver" = "10.1" ] && mb_all="--apply-log-only" || mb_all=""
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$backup_path" != "" ] && path=$backup_path/$(echo $path | sed -re "s/^(.*)\/([0-9-]*)\/(.*)\/(.*)$/\2\/\3\/\4/")
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	rm -f /tmp/xtrabackup*
	find_util mariabackup
	if [ "$util" = "" ]
	then
		find_util mariadb-backup
	fi
	mariabackup=$util
	find_util mbstream
	mbstream=$util
	state_update "extracting full backup $uuid"
	if [ "$target" != "-" ]
	then
		echo -n "extracting full backup $uuid... "
		$ssh mkdir -p $target/full
		echo "--> eval $reader | $unencryptor | $uncompressor | $ssh $mbstream -p $parallelism -x -v -C $target/full" >> $logfile
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | $ssh $mbstream -p $parallelism -x -v -C $target/full 2>> $logfile
	else
		eval $reader | $unencryptor 2>/dev/null | $uncompressor 2>> $logfile
		status=$?
		return
	fi
	status=$?
	echo
	[ $status -ne 0 ] && return
	open_files_limit
	echo -n "applying redo logs for $uuid... "
	echo "--> $ssh $mariabackup --prepare $mb_all $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full" >> $logfile
	state_update "preparing full backup $uuid"
	$ssh $mariabackup --prepare $mb_all $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full >> $logfile 2>&1
	status=$?
	echo
	[ $status -ne 0 ] && return
	tail -1 $logfile | fgrep -q "completed OK"
	status=$?
	[ $status -ne 0 ] && return
	current_position $uuid
	binlogs_starting_point=$uuid
	for id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and backup_tool = '$tool' and status = 0 order by start_time asc;" | dbquery $DB)
	do
		incr_check_position $id && break
		path=$(echo "select bulocation from backup_history where uuid = '$id';" | dbquery $DB)
		[ "$backup_path" != "" ] && path=$backup_path/$(echo $path | sed -re "s/^(.*)\/([0-9-]*)\/(.*)\/(.*)$/\2\/\3\/\4/")
		key=$(echo "select cryptkey from backup_history where uuid = '$id';" | dbquery $DB)
		[ "$key" != "" ] && export enc_key="$key"
		incdir=$(basename $path)
		echo -n "extracting incremental backup $id... "
		$ssh mkdir -p $target/$incdir
		rm -f /tmp/xtrabackup*
		state_update "extracting incremental backup $id"
		echo "--> eval $reader | $unencryptor | $uncompressor | $ssh $mbstream -p $parallelism -x -v -C $target/$incdir" >> $logfile
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | $ssh $mbstream -p $parallelism -x -v -C $target/$incdir 2>> $logfile
		status=$?
		echo
		[ $status -ne 0 ] && break
		echo -n "applying redo logs for $id... "
		state_update "preparing incremental backup $id"
		echo "--> $ssh $mariabackup --prepare $mb_all $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full --incremental-dir=$target/$incdir" >> $logfile
		$ssh $mariabackup --prepare $mb_all $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full --incremental-dir=$target/$incdir >> $logfile 2>&1
		status=$?
		echo
		[ $status -ne 0 ] && break
		tail -1 $logfile | fgrep -q "completed OK"
		status=$?
		[ $status -ne 0 ] && break
		current_position $id
		binlogs_starting_point=$id
		$ssh rm -rf $target/$incdir
	done
	[ $status -ne 0 ] && return
	echo -n "Finalizing backup... "
	state_update "finalizing restore"
	echo "--> $ssh $mariabackup --prepare $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full" >> $logfile 
	$ssh $mariabackup --prepare $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full >> $logfile 2>&1
	status=$?
	echo
	[ $status -ne 0 ] && return
	tail -1 $logfile | fgrep -q "completed OK"
	status=$?
	$ssh mv $target/full/* $target/
	$ssh rmdir $target/full
	if [ $status -eq 0 -a $point_in_time -eq 1 ]
	then
		[ "$backup_path" = "" ] && bxfolder=$target/.backupmanager || bxfolder=$backup_path/.backupmanager
		[ "$BM_BINLOG_PATH" != "" ] && bxfolder=$BM_BINLOG_PATH/.backupmanager
		apply_binlogs || exit 1
	        echo "Done applying binary logs."
	fi
	state_update "restore completed"
}

perform_mariaunpacked_restore()
{
	find_util rsync
	if [ "$util" = "" ]
	then
		echo "ERROR: Please install rsync first."
		clean_exit 1
	else
		rsync=$util
	fi
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	$rsync -a $path/* $target/
	if [ $? -ne 0 ]
	then
		echo "ERROR:copying backup to $target failed."
		clean_exit 1
	fi
	if [ $point_in_time -eq 1 ]
	then
		current_position $uuid
		binlogs_starting_point=$uuid
		bxfolder=$target/.backupmanager
		apply_binlogs || exit 1
	        echo "Done applying binary logs."
	else
		echo "The data at $target is ready for use."
	fi
	status=0
}

ssh_setup()
{
	if [ ! -f $HOME/.ssh/id_rsa.pub ]
	then
		ssh-keygen -q -t rsa -b 2048 -f $HOME/.ssh/id_rsa -N ''
		if [ $? -ne 0 ]
		then
			echo "error setting up public/private key pair. Exiting."
			exit 1
		fi
	fi
	ssh -oPasswordAuthentication=no -q $1 true
	if [ $? -ne 0 ]
	then
		echo "*** Setting up ssh"
		echo "Setting up public/private key authentication. Please enter $targethost password."
		cat $HOME/.ssh/id_rsa.pub | ssh -tq $1 "mkdir .ssh 2>/dev/null; chmod 755 .ssh; cat >> .ssh/authorized_keys; chmod 644 .ssh/authorized_keys"
		if [ $? -ne 0 ]
		then
			echo "error setting up public/private key pair. Exiting."
			rm -rf $HOME/.ssh/id_rsa*
			exit 1
		fi
	fi
	ssh -q $1 true
	if [ $? -ne 0 ]
	then
		echo "ssh connection to $1 was not successful. Exiting."
		exit 1
	fi
}

replication_credentials()
{
	get_repl_creds
}

pit_xid()
{
	replication_credentials
	[ "$repl_user" = "" ] && return
	build_master_cmd
	target_gtid=$(which_gtid)
	[ $target_gtid -eq 0 ] && return
	for binlog in $(echo "show binary logs" | $master_cmd 2>/dev/null | cut -f 1 | sort -r)
	do
		gtid=$(echo "show binlog events in '$binlog' limit 5" | $master_cmd 2>/dev/null | fgrep -v Gtid_list | fgrep Gtid | cut -f 6 | cut -d" " -f 3 | cut -d"-" -f 3)
		[ "$gtid" = "" ] && break
		if [ $target_gtid -ge $gtid ]
		then
			target_binlog=$binlog
			break
		fi
	done
	[ "$target_binlog" = "" ] && return
        pos=$(echo "show binlog events in '$target_binlog'" | $master_cmd 2>/dev/null | grep -E -- "GTID\ ([0-9]*)-([0-9]*)-$target_gtid($| )" | cut -f 2)
	[ "$pos" = "" ] && return
	xid=$(echo "show binlog events in '$target_binlog' from $pos" | $master_cmd 2>/dev/null | fgrep -m 1 COMMIT | sed -re "s/^(.*)\ xid=([0-9]*)\ (.*)/\2/")
	if [ "$xid" !=  "" ]
	then
		echo "update backup_history set xid = $xid  where uuid = '$backup_id';" | dbquery $DB
		echo "Great! Xid $xid for galera master decoupling has been retrieved and saved to inventory."
	fi
}

disk_space()
{
	[ ! -d $target ] && return
	disk_space_avail=$(df -h $target |  tail -1 | tr -s " " "\t" | cut -f 4)
	disk_space_avail_k=$(df -k $target |  tail -1 | tr -s " " "\t" | cut -f 4)
	disk_space_p_used=$(df -h $target |  tail -1 | tr -s " " "\t" | cut -f 5 | tr -d "%")
	disk_space_p_avail=$((100-disk_space_p_used))
}

check_slave_status()
{
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	if [ "$hb_schema" != "" -a "$hb_table" != "" -a "$hb_stale_secs" != "" ]
	then
		hb_delay=$(echo "select timestampdiff(second, ts, now()) from $hb_schema.$hb_table order by ts desc limit 1" | mysql -ANr -u $user $sock_str $pass_str)
		if [ "$hb_delay" = "" ]
		then
			true
		else
			[ $hb_delay -ge $hb_stale_secs ]
		fi
	else
		echo "show slave status\G" | mysql -Ar -u $user $sock_str $pass_str | grep -P "Slave_(.*)_Running:" | egrep -q "No|Connecting"
	fi
	if [ $? -eq 0 ]
	then
		msg="ERROR: replication is broken, will not backup stale data. Exiting."
		echo $msg
		[ "$tool" = "binlogs" ] && exit 1
		[ "$failure_notify" != "" ] && echo $msg | send_mail "$customer: backup FAILED" $failure_notify
		status=1; fire_webhook
		exit 1
	fi
}

get_lsn()
{
	lsn=$(fgrep last_lsn $target/checkpoints/$tool/xtrabackup_checkpoints 2>/dev/null | tr -d " " | cut -d"=" -f 2)
}

build_config()
{
	if [ $(id -u) -ne 0 ]
	then
		CONFIGFILE=$HOME/$CONFIGNAME
	else
		[ ! -d $CONFIGDIR ] && mkdir $CONFIGDIR
	fi
	if [ -f $CONFIGFILE ]
	then
		echo "$CONFIGFILE already exists, will not overwrite."
		exit 1
	fi
	base64 -d << DOC_EOF | gzip -dc | sed -e "s/\$VERSION/v$BM_VERSION/" > $CONFIGFILE
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
45+OXr/+N+keomRFFwAA
DOC_EOF

	echo "Created $CONFIGFILE. Please adjust it for your setup." 
	exit 0
}

check_server_path()
{
	while true
	do
		$ssh [ -f $server_path ] && return
		echo "ERROR: could not find MariaDB server executable '$server_path'!"
		echo -n "Please enter its location on this system (including filename): "
		read server_path
	done
}

mariadb_instance()
{
	case "$1" in
		'start')
			check_server_path
			echo -n "starting MariaDB auxiliary instance on $target... "
			$local_remote "echo 'server_id=987654321' >> $target/backup-my.cnf"
			$local_remote "echo 'lower_case_table_names=$case_insens' >> $target/backup-my.cnf"
			$ssh $server_path --defaults-file=$target/backup-my.cnf  --innodb_file_per_table  --skip-grant-tables --basedir=/usr --datadir=$target --plugin-dir=/usr/lib64/mysql/plugin --user=root --log-error=$target/backup_manager_mysqld.err $limit_str --pid-file=$target/mysql.pid --socket=/tmp/backup_manager.sock --port=65432 2>> /tmp/backup_manager_mysqld.err &
			sleep 10
			instance=$($ssh cat $target/mysql.pid 2>/dev/null)
			[ "$instance" = "" ] && return 1
			echo "(pid $instance)"
			$ssh kill -0 $instance 2>/dev/null
			return $?
			;;
                'stop') echo "stopping MariaDB auxiliary instance"
			$ssh kill $instance
			;;
	esac
}

dim_prepare_memory()
{
        avail=$($ssh grep ^MemTotal  /proc/meminfo | sed -re "s/^MemTotal:(\s*)([0-9]*) kB/\2/")
        prepare_memory=$((avail/4))
}

run_purge_backups()
{
	purge_backups $*
}

show_logs()
{
	logfile=$(echo "select logfile from backup_history where uuid = '$1';" | dbquery $DB)
	if [ "$logfile" = "" ]
	then
		echo "backup with id '$1' not found."
		exit 1
	fi
	[ "$(which less 2>/dev/null)" != "" ] && pager="less" || pager="more"
	if [ "$(which fuser 2>/dev/null)" != "" ]
	then
        	fuser -s $logfile && tail -f $logfile || $pager $logfile
	else
        	echo -e "  loading logfile into pager, please wait... \r\c"
		$pager $logfile
	fi
}

build_binlog_list()
{
	ena=0
	binlog_list=""
	for binlog in $(ls ${binlog_base}* | grep -v index)
	do
		[ "${binlog##*/}" \> "$binlog_start" -o "${binlog##*/}" = "$binlog_start" ] && ena=1
		[ $ena -eq 0 ] && continue
		binlog_list="$binlog_list ${binlog##*/}"
	done
	binlog_list=$(echo $binlog_list | sed -e "s/${binlog##*/}//")
	if [ "${binlog_list## }" = "" ]
	then
		echo "No binary logs needing backup."
		clean_exit 0
	fi
}

position_from_binlog()
{
	cat $1 | $ssh $mysqlbinlog --no-defaults --skip-annotate-row-events --base64-output=NEVER - | fgrep -v Warning | fgrep -C10 -m1 "Start: binlog" > $aux_log
	lb_ts=$(grep "GTID " $aux_log | sed -re "s/^#([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)\s+([0-9 ]*):([0-9]*):([0-9]*) server (.*)$/20\1\2-\3\4-\5\6 \7:\8:\9/" -e "s/( )([0-9]:)/ 0\2/")
	[ "$lb_ts" = "" ] && lb_ts=$(grep "created " $aux_log | sed -re "s/^#([0-9][0-9])([0-9][0-9])([0-9][0-9])(\s*)([0-9]*):([0-9]*):([0-9]*)\s(.*)$/20\1-\2-\3 \5:\6:\7/" -e "s/( )([0-9]:)/ 0\2/")
        binlog_pos=$(grep "^# at " $aux_log | head -1 | sed -re "s/^# at ([0-9]*)/\1/")
	gtid_binlog_pos=$(cat $aux_log | tr -d "\n" | tr -d "#" | sed -re "s/(.*)\[(.*)\](.*)/\2/")
}

setup_replication()
{
	setup_repl_only=1
	build_slave $1 $2
}

get_replication_info()
{
	replication_info $1
}

safe_defaults
if [ "$1" = "debug" ]
then
	while true
	do
		sleep 10
	done
	exit 1
fi
[ "$1" = "build-config" ] && build_config
check_home_config
if [ ! -f $CONFIGFILE ]
then
	[ $# -eq 0 ] && self_doc
	echo "$CONFIGFILE not found. You can build it with: $0 build-config."
	[ $(id -u) -ne 0 ] && echo "Since you are not running as root, it will be created in your home directory."
	exit 1
fi
[ "$1" = "help" ] && self_doc
parse_config $*
setup_db
case "$1" in
	'backup') 	
		disk_space
		do_backup $2 $3 $4 $5
		exit $status
		;;
	'restore') 	
		do_restore $2 "$3" "$4" "$5"
		;;
	'remote-restore') 	
		do_remote_restore $2 "$3" "$4" "$5"
		;;
	'inventory'|'inv'|'list') 
		disk_space
		inventory $2 $3 $4
		;;
	'purge') 
		run_purge_backups $2
		;;
	'logs') 
		show_logs $2
		;;
	'build-slave') 
		build_slave $2 $3
		;;
	'print-latest') 
		print_latest
		;;
	'print-latest-id') 
		print_latest_id
		;;
	'replication-info') 
		get_replication_info $2
		;;
	'backup-type') 
		backup_type $2
		;;
	'backup-time') 
		backup_time $2
		;;
	'backup-size') 
		backup_size $2
		;;
	'validate-pit') 
		pit_dry_run $2 "$3"
		;;
	'setup-replication') 
		setup_replication $2 $3 
		;;
	'version') 
		echo $BM_VERSION
		;;
	'help')
		;;
	*) 
		[ "$1" = "" ] && self_doc || echo "$0: unkown option $1"; exit 1
		;;
esac
exit 0
