#!/bin/bash
#
# MariaDB Backup Manager: a backup-tool-agnostic backup and restore script
#
# Please send bugs to pizzi@leopardus.com
#
#

# begin 

BM_VERSION="4.8.9"
CONFIGDIR=/etc/mariadb
CONFIGNAME=backup_manager.cnf
CONFIGFILE=$CONFIGDIR/$CONFIGNAME
DB=$CONFIGDIR/.backup_inventory.db
BOOTSTRAP_FILE=mysql/bckmgr_bootstrap.opt
BACKUP_LOCK_TIMEOUT=30
#
#

semaphore_setup()
{
	if [ $custom_config -eq 0 ]
        then
                if [ "$2" != "binlogs" ]
                then
                        [ $level -eq 0 ] && get_lock 1 || get_lock 0
                else
                        get_binlogs_lock
                fi
        	setup_trap $2
        else
                get_lock 1
                get_binlogs_lock wait
        	setup_trap custom
        fi
}

setup_trap()
{
	case "$1" in
		'binlogs')
        		trap 'rm -f $tmpfile $binlog_lockfile $error_log $aux_log $dbq_stderr $dumptail 2>/dev/null' 0
			;;
		'custom')
        		trap 'rm -f $tmpfile $lockfile $binlog_lockfile $error_log $aux_log $dbq_stderr $dumptail 2>/dev/null' 0
			;;
		'other')
        		trap 'rm -f $tmpfile $error_log $aux_log $dbq_stderr $dumptail 2>/dev/null' 0
			;;
		*)
        		trap 'rm -f $tmpfile $lockfile $error_log $aux_log $dbq_stderr $dumptail 2>/dev/null' 0
			;;
	esac
}

get_binlogs_lock()
{
	while true
	do
		[ ! -f $binlog_lockfile ] && break
		kill -0 $(cat $binlog_lockfile) 2>/dev/null
		[ $? -ne 0 ] && break
		if [ "$1" = "" ]
		then
			echo "Binlog or custom backup already in progress, skipping"
			exit 0
		fi
		sleep 1
	done
	echo $runtime_id > $binlog_lockfile
}

get_lock()
{
	if [ -f $lockfile ]
	then
		kill -0 $(cat $lockfile) 2>/dev/null
		if [ $? -eq 0 ]
		then	
			echo "Another backup is in progress, skipping this run."
			exit $1
		fi
	fi
	echo $runtime_id > $lockfile
}

safe_defaults()
{
	error_log=/tmp/bm.error.$$
	aux_log=/tmp/bm.aux.$$
	dumptail=/tmp/bm.dt.$$
	dbq_stderr=/tmp/dbq.stderr.$$
	tmpfile=/tmp/bm.tmp.$$
	parallelism=4
	port=3306
	dt_format="%Y-%m-%d"
	compressor="cat"
	encryptor="cat"
	uncompressor="cat"
	unencryptor="cat"
	reader="cat \$path"
	default_reader="$reader"
	purge_incomplete=0
	expire_days=0
	smart_purge=0
	smart_purge_months=6
	master_position=0
	min_disk_pfree=20
	galera=0
	runtime_id=$$
	restore_test=0
	timeout=0
	setup_repl_only=0
	enc_key_local=0
	kill_query_time=0
	status=0
	level=0
	expire_days=7
        [ "$(which less 2>/dev/null)" != "" ] && pager="less -em -Pm--more--"  || pager="cat"
	perldoc=0
        [ "$(which perldoc 2>/dev/null)" != "" ] && perldoc=1
	point_in_time=0
	set_maintenance=0
	ignore_errors=0
	master_slave=0
	skip_notification=0
	custom_config=0
	server_path="/usr/sbin/mysqld"
	cloud_storage=0
	local_remote="eval"
}

setup_db()
{
	[ "$BM_BACKUP_INVENTORY" != "" ] && DB=$BM_BACKUP_INVENTORY
	setup_sqlite_db
}

setup_sqlite_db()
{
	if [ "$(which sqlite3 2>/dev/null)" = "" ]
	then
		echo "This script requires the sqlite3 package. Please install it."
		exit 1
	fi
	if [ "$(which curl 2>/dev/null)" = "" ]
	then
		echo "This script requires the curl package. Please install it."
		exit 1
	fi
	if  [ ! -f $DB ]
	then
		(
		echo "CREATE TABLE backup_history ("
  		echo "uuid varchar(40) NOT NULL,"
		echo "runtime_id int DEFAULT NULL,"
  		echo "start_time timestamp NULL DEFAULT NULL,"
  		echo "end_time timestamp NULL DEFAULT NULL,"
  		echo "bulocation varchar(255) DEFAULT NULL,"
  		echo "logfile varchar(255) DEFAULT NULL,"
  		echo "status tinyint DEFAULT NULL,"
  		echo "level tinyint DEFAULT NULL,"
  		echo "compressor varchar(40) DEFAULT NULL,"
  		echo "uncompressor varchar(40) DEFAULT NULL,"
  		echo "encryptor varchar(40) DEFAULT NULL,"
  		echo "unencryptor varchar(40) DEFAULT NULL,"
  		echo "cryptkey varchar(255) DEFAULT NULL,"
  		echo "last_lsn bigint DEFAULT NULL,"
  		echo "backup_tool varchar(120) DEFAULT NULL,"
  		echo "server_version varchar(50) DEFAULT NULL,"
  		echo "backup_size bigint  DEFAULT NULL,"
  		echo "ref_full_backup varchar(40) DEFAULT NULL,"
  		echo "xid bigint DEFAULT NULL,"
  		echo "dumplist varchar(2000) DEFAULT NULL,"
  		echo "kubernetes_pod varchar(64) DEFAULT NULL,"
  		echo "kubernetes_bucket varchar(255) DEFAULT NULL,"
  		echo "kubernetes_db varchar(64) DEFAULT NULL,"
  		echo "checkpoint varchar(64) DEFAULT NULL,"
		echo "binlog_file varchar(64) DEFAULT NULL,"
		echo "binlog_position varchar(64) DEFAULT NULL,"
		echo "binlog_first varchar(64) DEFAULT NULL,"
		echo "binlog_last varchar(64) DEFAULT NULL,"
  		echo "binlog_last_ts timestamp NULL DEFAULT NULL,"
		echo "kubernetes_bucket_id varchar(64) DEFAULT NULL,"
		echo "kubernetes_bucket_secret varchar(64) DEFAULT NULL,"
  		echo "level13_alert tinyint DEFAULT NULL,"
		echo "gtid_binlog_pos varchar(128) DEFAULT NULL,"
  		echo "datadir_size bigint DEFAULT NULL,"
		echo "case_insensitive tinyint DEFAULT NULL,"
  		echo "PRIMARY KEY (uuid),"
  		echo "FOREIGN KEY (ref_full_backup) REFERENCES backup_history(uuid) ON DELETE CASCADE);"
		echo "CREATE INDEX start_time ON backup_history(start_time);"
		echo "CREATE INDEX ref_full ON backup_history(ref_full_backup);"
		echo "CREATE INDEX incremental_check on backup_history(backup_tool, level, status);"
		echo "CREATE INDEX binlog_last_ts ON backup_history(binlog_last_ts);"
		) | dbquery $DB
	else
		patch_sqlite_db $DB
	fi
}

patch_sqlite_db()
{
	rev=$(echo "PRAGMA table_info(backup_history);" | dbquery $1 | tail -1 | cut -d "|" -f 1)
	case "$rev" in
		'17') 	echo "ALTER TABLE backup_history ADD COLUMN xid bigint DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'18') 	echo "ALTER TABLE backup_history ADD COLUMN dumplist varchar(2000) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN kubernetes_pod varchar(64) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN kubernetes_bucket varchar(256) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN kubernetes_db varchar(64) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN checkpoint varchar(64) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'23') 	echo "ALTER TABLE backup_history ADD COLUMN binlog_file varchar(64) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'24') 	echo "ALTER TABLE backup_history ADD COLUMN binlog_position varchar(16) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'25') 	echo "ALTER TABLE backup_history ADD COLUMN binlog_first varchar(16) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN binlog_last varchar(16) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'27') 	echo "ALTER TABLE backup_history ADD COLUMN binlog_last_ts timestamp DEFAULT NULL;" | dbquery $1
			echo "CREATE INDEX binlog_last_ts ON backup_history(binlog_last_ts);" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'28') 	echo "ALTER TABLE backup_history ADD COLUMN kubernetes_bucket_id varchar(64) DEFAULT NULL;" | dbquery $1
			echo "ALTER TABLE backup_history ADD COLUMN kubernetes_bucket_secret varchar(64) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'30') 	echo "ALTER TABLE backup_history ADD COLUMN level13_alert tinyint DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'31') 	echo "ALTER TABLE backup_history ADD COLUMN gtid_binlog_pos varchar(128) DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'32') 	echo "ALTER TABLE backup_history ADD COLUMN datadir_size bigint DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
		'33') 	echo "ALTER TABLE backup_history ADD COLUMN case_insensitive tinyint DEFAULT NULL;" | dbquery $1
			patch_sqlite_db $1
			return
			;;
	esac
}

clean_exit()
{
	[ "$what" = "backup" ] && echo "delete from backup_history where uuid = '$backup_id';" | dbquery $DB
	exit $1
}

curl_before()
{
	[ "$url_before" != "" ] && curl --output - --insecure --silent --connect-timeout 10  "$url_before" > $tt/callout_before.log 2>&1
}

curl_after()
{
	[ "$url_after" != "" ] && curl --output - --insecure --silent --connect-timeout 10  "$url_after" > $tt/callout_after.log 2>&1
}

check_free_space()
{
	if [ $disk_space_p_avail -eq 0 ]
	then
		echo "ERROR: filesystem is full for target directory $target."
		msg="Filesystem for backup target directory is full. Exiting."
		echo $msg
		[ "$failure_notify" != "" ] && echo $msg | send_mail "$customer: backup FAILED" $failure_notify
		status=1; fire_webhook
			exit 1
	fi
	if [ $level -eq 0 -a $disk_space_p_avail -lt $min_disk_pfree ]
	then
		echo "ERROR: Not enough free space on target directory $target."
		msg="Filesystem has $disk_space_p_avail% ($disk_space_avail) free, but $min_disk_pfree% is required. Exiting."
		echo $msg
		[ "$failure_notify" != "" ] && echo $msg | send_mail "$customer: backup FAILED" $failure_notify
		status=1; fire_webhook
		exit 1
	fi
}

email_notification()
{
	[ -t 0 ] && return
	[ $skip_notification -eq 1 ] && return
	if [ "$failure_notify" != "" ]
	then
		if [ $status -eq 1 ]
		then
			echo "Backup failed, please run 'backup_manager logs $backup_id' for details" | send_mail "$customer: backup FAILED" $failure_notify
		else
			[ "$success_notify" != "" -a $level -eq 0 ] && inventory pretty | send_mail "$customer: backup SUCCESSFUL" $success_notify
		fi
	fi
}

run_with_timeout()
{
	pid=$(jobs -p)
	if [ $timeout -eq 0  ]
	then
		wait $pid
		status=$?
		return
	fi
	echo "NOTICE: backup_timeout in effect, timeout ${timeout}m, controller id $pid"
	countdown=$((timeout*12+1))
	while true
	do
		kill -0 $pid 2>/dev/null || break	
		countdown=$((countdown-1))
		[ $countdown -eq 0 ] && break
		sleep 5
	done
	if [ $countdown -eq 0 ]
	then
		echo "ERROR: Backup timed out. Killing it."
		pkill -9 -P $pid
		echo "Backup killed due to timeout." >> $logfile
		status=1
	else
		wait $pid
		status=$?
	fi
}

scan_binlog_archive()
{
	echo -n "scanning binlog archive.."
	for bf in $(ls $bxfolder)
	do
	t=$(cat $bf | $ssh $mysqlbinlog --no-defaults - | fgrep -m 1 "Start: binlog" | sed -re "s/^#([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)\s+([0-9 ]*):([0-9]*):([0-9]*) server (.*)$/20\1\2-\3\4-\5\6 \7:\8:\9/" -e "s/( )([0-9]:)/ 0\2/")
		if [ "$(echo "select '$t' > '$requested_binlog_ts';" | dbquery $DB)" = "1" ]
		then 
			last_b=$prev_bf
			scan_complete=1
			echo
			return
		fi
		prev_bf=$bf
		echo -n "."
	done
	echo
}

# set bxfolder before calling
apply_binlogs()
{
	bf_start_file=$(echo "select binlog_file from backup_history where uuid = '$binlogs_starting_point';" | dbquery $DB)
	bf_start_pos=$(echo "select binlog_position from backup_history where uuid = '$binlogs_starting_point';" | dbquery $DB)
	bf_start_ts=$(echo "select binlog_last_ts from backup_history where uuid = '$binlogs_starting_point';" | dbquery $DB)
	[ "$bf_start_file" = "$requested_binlog_file" -a "$bf_start_pos" = "$requested_binlog_position" ] && return 0
	[ "$bf_start_ts" = "$requested_binlog_ts" ] && return 0
	bf_parent=$(echo "select ref_full_backup from backup_history where uuid = '$binlogs_starting_point';" | dbquery $DB)
	[ "$bf_parent" = "" ] && bf_parent=$binlogs_starting_point
	case_insens=$(echo "select case_insensitive from backup_history where uuid = '$bf_parent';" | dbquery $DB)
	if [ "$requested_binlog_ts" != "" ]
	then
		echo "Now applying binary logs for all events having timestamp < '$requested_binlog_ts'"
	else
		echo "Now applying binary logs up to: file $requested_binlog_file, position $requested_binlog_position"
		requested_binlog_ts="2038-01-19 03:14:07"
	fi
	initial_bf_done=0
	scan_complete=0
	echo "Inital position for binlogs: file $bf_start_file, position $bf_start_pos"
	mariadb_instance start
	if [ $? -ne 0 ]
	then
		echo "ERROR: unable to start MariaDB auxiliary instance. More info: /tmp/backup_manager_mysqld.err"
		echo "Aborting restore."
		return 1
	fi
	[ ! -d $bxfolder ] && mkdir $bxfolder
	cd $bxfolder
	wanted_seqno=${bf_start_file:(-6)}
        scan_start=$(echo "select start_time from backup_history where uuid = '$uuid';" | dbquery $DB)
        for bp in $(echo "select uuid from backup_history where backup_tool = 'binlogs' and ref_full_backup = '$bf_parent' and start_time > '$scan_start' order by start_time asc;" | dbquery $DB)
	do
		last_seqno=$(echo "select substr(binlog_last, -6) from backup_history where uuid = '$bp';" | dbquery $DB)
		[ $last_seqno -lt $wanted_seqno ] && continue
		echo "extracting binlog backup $bp"
		state_update "applying binlog backup $bp"
		extract_binlog_piece $bp  || return 1
		[ $scan_complete -eq 1 ] && break
		[ "$bp" = "$target_binlog_backup_id" ] && break
		[ "$last_file" != "" ] && break
		current_position $bp
	done
	mariadb_instance stop
	cd /tmp
	rmdir $bxfolder
	return 0
}

pit_input_error()
{
	echo "ERROR: '$1': not a valid point-in-time specification."
	echo "accepted formats: timestamp ('YYYY-MM-DD HH:MM:SS') or position (binlogfile:position)"
	exit 1
}

pit_dry_run()
{       
        if [ "$2" = "" ]
        then    
                echo "usage: $0 validate-pit <backupid> <point-in-time>"
                exit 1
        fi
        uuid=$(echo "select uuid from backup_history where uuid = '$1';" | dbquery $DB)
        if [ "$uuid" = "" ]
        then    
                echo "ERROR: backup $1 not found in inventory."
                exit 1
        fi
        validate_point_in_time "$2" dontask
        exit 0
}


validate_point_in_time()
{
	if [ "$(echo "select datetime('$1') = '${1/T/ }';" | dbquery $DB)" = "1" ]
	then
		requested_binlog_ts="${1/T/ }"
	else
		IFS=":"
		posarr=($1)
		[ ${#posarr[@]} -ne 2 ] && pit_input_error "$1"
		requested_binlog_file=${posarr[0]}
		requested_binlog_position=${posarr[1]}
		unset IFS
		echo "$requested_binlog_file" | grep -qE "^[-0-9a-z\.]+$"  || pit_input_error "$1"
		echo "$requested_binlog_position" | grep -qE "^[0-9]+$" || pit_input_error "$1"
	fi
	check_pit_availability
	if [ "$target_binlog_backup_id" = "" ]
	then
		echo "ERROR: requested point-in-time not available in the specified full backup."
		echo "Please run \"backup_manager inventory binlogs\" to verify if another backup has it."
		exit 1
	fi
	echo -n "Point-in-time recovery requested: "
	if [ "$requested_binlog_ts" = "" ]
	then
		echo "file $requested_binlog_file, position $requested_binlog_position"
	else
		echo "'$requested_binlog_ts'"
	fi
	echo "Requested point-in-time found in backup piece $target_binlog_backup_id."
	[ "$2" = "" ] && confirm_operation
	[ "$target_binlog_backup_id" != "$uuid" ] && point_in_time=1
}

pit_not_present()
{
	echo "ERROR: requested point-in-time not available in this backup."
	echo "You requested $requested_binlog_file:$requested_binlog_position and this backup starts with $bf:$bp."
	echo "Please select an older backup, or run without point-in-time recovery."
}

check_pit_availability()
{
	if [ "$requested_binlog_file" != "" ]
	then
		bf=$(echo "select binlog_file from backup_history where uuid = '$uuid';" | dbquery $DB)
		bp=$(echo "select binlog_position from backup_history where uuid = '$uuid';" | dbquery $DB)
		#echo "full $uuid: $bf:$bp"
		if [ "$bf" \> "$requested_binlog_file" ]
		then
			pit_not_present
			exit 1
		fi
		if [ "$bf" = "$requested_binlog_file" ]
		then
			if [ $bp -gt $requested_binlog_position ]
			then
				pit_not_present
				exit 1
			fi
		fi
		for bb_id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and backup_tool = 'binlogs' and status = 0 order by start_time asc;" | dbquery $DB)
		do
			bl=$(echo "select binlog_last from backup_history where uuid = '$bb_id';" | dbquery $DB)
			if [ "$bl" \> "$requested_binlog_file" -o "$bl" = "$requested_binlog_file" ]
			then
				target_binlog_backup_id=$bb_id
				return
			fi
		done
		for bb_id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and level = 1 and status = 0 order by start_time asc;" | dbquery $DB)
		do
			bl=$(echo "select binlog_file from backup_history where uuid = '$bb_id';" | dbquery $DB)
			if [ "$bl" \> "$requested_binlog_file" -o "$bl" = "$requested_binlog_file" ]
			then
				target_binlog_backup_id=$bb_id
				return
			fi
		done
	else
                blt=$(echo "select binlog_last_ts from backup_history where uuid = '$uuid';" | dbquery $DB)
		[ "$requested_binlog_ts" \< "$blt" ] && return
		if [ "$requested_binlog_ts" = "$blt" ]
		then
			target_binlog_backup_id=$uuid
			return
		fi
		 pt=$(echo "select uuid from backup_history where ((binlog_last_ts = '$requested_binlog_ts' and level in (0,1)) or (binlog_last_ts > '$requested_binlog_ts' and level = 3)) and status = 0 limit 1;" | dbquery $DB)
                ref=$(echo "select ref_full_backup from backup_history where uuid = '$pt';" | dbquery $DB)
		if [ "$ref" = "" ]
		then
			echo "ERROR: requested point-in-time not available in this backup."
                        exit 1
		fi
                if [ "$ref" != "$uuid" ]
                then
                        echo "ERROR: a more recent full backup exists for the requested point in time."
                        echo "In order to speed up your restore, please base it on backup id $ref."
                        exit 1
                fi
                target_binlog_backup_id=$pt
	fi
}

find_binlogs_backup_sp()
{
        last_binlog=$(echo "select binlog_file from backup_history where backup_tool = 'binlogs' and status=0 order by end_time desc limit 1;" | dbquery $DB)
	if [ "$last_binlog" = "" ]
	then
        	binlog_start=$(echo "select binlog_file from backup_history where uuid = '$1';" | dbquery $DB)
	else
		binlog_start=$last_binlog
	fi
}

send_mail()
{
	if [ $(mailx -V | fgrep -c GNU) -gt 0 ]
	then
		(
			echo "<PRE>"
			cat
			echo "</PRE>"
		) | mailx -s "$1" -a "Content-Type: text/html" $2
	else
		mailx -s "$1" $2
	fi
}

purge_incomplete()
{
	[ $purge_incomplete -eq 0 ] && return
	[ $status -eq 0 ] && return
	[ "$tt" = "" ] && return
	echo "purging incomplete backup"
	case "$tool" in
		'mariabackup'|'xtrabackup'|'mysqldump'|'smartdump') 
					rm -f $tt/$fn
					;;
		'mariaunpacked'|'mydumper') 
					mv $logfile $aux_log 2>/dev/null
					rm -rf $tt/*
					mv $aux_log $logfile 2>/dev/null
					;;
	esac
}

current_position()
{
	echo "select '(current position: ' || binlog_file || ':' || binlog_position || ', GTID: [' || gtid_binlog_pos || '], backup time: ' || binlog_last_ts || ')' from backup_history where uuid = '$1';" | dbquery $DB
}

incr_check_position()
{
	if [ $point_in_time -eq 1 ]
	then
		if [ "$requested_binlog_file" != "" ]
		then
			this_binlog_file=$(echo "select binlog_file from backup_history where uuid = '$id';" | dbquery $DB)
			[ "$this_binlog_file" \> "$requested_binlog_file" ] && return 0
			if [ "$this_binlog_file" = "$requested_binlog_file" ]
			then
				this_binlog_position=$(echo "select binlog_position from backup_history where uuid = '$id';" | dbquery $DB)
				[ $this_binlog_position -gt $requested_binlog_position ] && return 0
			fi
		else
			this_binlog_ts=$(echo "select binlog_last_ts from backup_history where uuid = '$id';" | dbquery $DB)
                        [ "$this_binlog_ts" \> "$requested_binlog_ts" ] && return 0
		fi
	fi
	return 1
}

yes_or_no()
{
	while true
	do
		read a
		case "$a" in
			'N'|'n') return 1;;
			'Y'|'y') return 0;;
			*) echo -n "Please enter Y or N: ";;
		esac
	done
}

confirm_operation()
{
	l=1
	while [ $l -eq 1 ]
	do
		echo -n "Confirm? y/N "
		read a
		case "$a" in
			'N'|'n'|'') echo "Never mind."; exit 1;;
			'Y'|'y') l=0;;
		esac
	done
}

print_latest()
{
	path=$(echo "select bulocation from backup_history where level = 0 and backup_tool in ('mariabackup','xtrabackup') and status = 0 order by start_time desc limit 1;" | dbquery $DB)
	if [ "$path" = "" ]
	then
		echo "no backups found."
		exit 1
	else
		echo $path
	fi
}

print_latest_id()
{
	id=$(echo "select uuid from backup_history where level = 0 and backup_tool in ('mariabackup','xtrabackup') and status = 0 order by start_time desc limit 1;" | dbquery $DB)
	if [ "$id" = "" ]
	then
		echo "no backups found."
		exit 1
	else
		echo $id
	fi
}

remove_files()
{
	for fn in $(echo "select bulocation || ' ' || logfile from backup_history where uuid = '$1';" | dbquery $DB)
	do
		rm -f $fn
	done
}

purge_incrementals()
{
	for ip in $(echo "select uuid from backup_history where ref_full_backup = '$1' and level=1;" | dbquery $DB)
	do
		remove_files $ip
		echo "delete from backup_history where uuid = '$ip';" | dbquery $DB
	done
}

smart_purge()
{
	keep=$(echo "select uuid || ',' || '0' from backup_history where start_time > date('now','-6 day') union select uuid || ',' || '1' from backup_history where start_time > date('now','-1 month', '-5 day') and strftime('%w', start_time)  = '0' union select uuid || ',' || '1' from backup_history where start_time > date('now','-$smart_purge_months month', '-1 month', '-6 day') and strftime('%w', start_time)  = '0' group by strftime('%m', start_time);" | dbquery $DB)
	echo -n "Purging backups using smart purge, keeping last $smart_purge_months months... "
	[ $dry -eq 1 ] && echo "(dry run)" || echo
	for fp in $(echo "select uuid from backup_history where level=0 order by start_time;" | dbquery $DB)
	do
		kf=$(echo "$keep" | fgrep $fp | head -1)
		pi=$(echo $kf | grep -c ",1$")
		if [ "$kf" != "" ]
		then
			[ $pi -eq 1 -a $dry -eq 0 ] && purge_incrementals $fp
			continue
		fi
		do_purge $fp
	done
}

do_purge()
{
	echo "purging $1"
	if [ $dry -eq 0 ]
	then
		if [ $cloud_storage -eq 0 ]
		then
			path=$(echo "select bulocation from backup_history where uuid = '$1';" | dbquery $DB)
			if [ -d $path ]
			then
				rm -rf $path
			else
				remove_files $1
			fi
			for ref_id in $(echo "select uuid from backup_history where ref_full_backup = '$1';" | dbquery $DB)
			do
				remove_files $ref_id
			done
			rmdir --ignore-fail-on-non-empty $(dirname $path)
			rmdir --ignore-fail-on-non-empty $(dirname $(dirname $path))
		fi
		(echo "PRAGMA foreign_keys=ON;"; echo "delete from backup_history where uuid = '$1';") | dbquery $DB
	fi
}

purge_backups()
{
	check_root purge
	if [ $expire_days -eq 0 -a $smart_purge -eq 0 ]
	then
		echo "purge is not properly configured."
		echo "please set either purge_days variable, or enable smart purge in config file."
		exit 1
	fi
	dry=0
	[ "$1" = "dry-run" -o "$1" = "dryrun" ] && dry=1
	if [ "$1" != "" -a $dry -eq 0 ]
	then
		if [ $(echo "select count(*) from backup_history where uuid = '$1';" | dbquery $DB) -eq 0 ]
		then
			echo "backup with id '$1' not found."
			exit 1
		fi
		echo "purging backup piece $1"
		path=$(echo "select bulocation from backup_history where uuid = '$1';" | dbquery $DB)
		if [ -d $path ]
		then
			rm -rf $path
		else
			remove_files $1
		fi
		echo "delete from backup_history where uuid = '$1';" | dbquery $DB
		return
	fi
	if [ $smart_purge -eq 1 ] 
	then
		smart_purge $1
		return
	fi
	echo -n "Purging backups older than $expire_days days... "
	[ $dry -eq 1 ] && echo "(dry run)" || echo
        [ -f $lockfile ] && r_id=$(cat $lockfile) || r_id=0
	for fp in $(echo "select uuid from backup_history where level in (0, 2, 3) and start_time < '$(date -d "today - $expire_days days" +%Y-%m-%d\ %T) and runtime_id <> $r_id order by start_time';" | dbquery $DB)
	do
		do_purge $fp
	done
}

check_home_config()
{
	if [ "$BM_CONFIG_FILE" != "" ]
	then
		CONFIGFILE=$BM_CONFIG_FILE
		return
	fi
	[ $(id -u) -eq 0 ] && return
	[ -f $HOME/$CONFIGNAME ] && CONFIGFILE=$HOME/$CONFIGNAME
}

self_doc()
{
	base64 -d << DOC_EOF | gzip -dc | sed -e "s/\$VERSION/v$BM_VERSION/" > /tmp/bmdoc.$$
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
vlN1ML4ZpZQd9/1n90XwU1xXwT8BUnGHcaZLAAA=
DOC_EOF
[ $perldoc -eq 1 ] && perldoc /tmp/bmdoc.$$ || $pager /tmp/bmdoc.$$
rm -f /tmp/bmdoc.$$
}

dbquery()
{
	dbq=$(cat)
	qtr=0
	while true
	do
		echo "$dbq" | sqlite3 $* 2>$dbq_stderr
		if [ -s $dbq_stderr ]
		then
			qtr=$((qtr+1))
			sleep $((RANDOM%5+1))
			[ $qtr -lt 10 ] && continue
			echo "ERROR: Unable to update inventory. Backup will proceed nonetheless."
			echo "$(date) inventory query \"$dbq\" failed with: $(cat $dbq_stderr)" >> /tmp/backup_manager.debug
		fi
		break
	done
}

inv_dbquery()
{
	sqlite3 -column -header $*
}

validate_table_name()
{
	ts_schema=${1%.*}
	ts_table=${1#*.}
	if [ "$ts_schema" = "" -o "$ts_table" = "" ]
	then
		echo "ERROR: invalid table name $3"
		exit 1
	fi
}

inventory()
{
	sqlite_inventory $*
	rm -f $dbq_stderr 2>/dev/null
}

replication_info()
{
	rc=$(echo "select uuid || binlog_file from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$rc" = "" ] && return
	[ "$rc" = "$uuid" ] && echo "No replication info available for this backup" || echo "select 'Replication info for $1: position ' || binlog_file || ':' || binlog_position || ', GTID ' || ifnull(gtid_binlog_pos, 'N/A') from backup_history where uuid = '$1';" | dbquery $DB
}

backup_size()
{
	rc=$(echo "select datadir_size from backup_history where uuid = '$1';" | dbquery $DB)
	echo $rc
}

backup_time()
{
	rc=$(echo "select binlog_last_ts from backup_history where uuid = '$1';" | dbquery $DB)
	echo $rc
}

backup_type()
{
	rc=$(echo "select backup_tool from backup_history where uuid = '$1';" | dbquery $DB)
	echo $rc
}

parse_config()
{
	host="$BACKUP_HOST"
	port="$BACKUP_PORT"
	user="$BACKUP_USER"
	password="$BACKUP_PASSWORD"
	socket="$BACKUP_SOCKET"
	grep -q "^backup_host" $CONFIGFILE && host=$(grep "^backup_host" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^backup_port" $CONFIGFILE && port=$(grep "^backup_port" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^backup_user" $CONFIGFILE && user=$(grep "^backup_user" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^backup_password" $CONFIGFILE && password=$(grep "^backup_password" $CONFIGFILE | sed -re 's/([^=]*)=(.*)$/\2/')
	grep -q "^backup_socket" $CONFIGFILE && socket=$(grep "^backup_socket" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^target_directory" $CONFIGFILE && target=$(grep "^target_directory" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^compressor" $CONFIGFILE && compressor=$(grep "^compressor" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^uncompressor" $CONFIGFILE && uncompressor=$(grep "^uncompressor" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^encryptor" $CONFIGFILE && encryptor=$(grep "^encryptor" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^unencryptor" $CONFIGFILE && unencryptor=$(grep "^unencryptor" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^downloader" $CONFIGFILE && reader=$(grep "^downloader" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^purge_incomplete_backups" $CONFIGFILE && purge_incomplete=$(grep "^purge_incomplete_backups" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^expire_days" $CONFIGFILE && expire_days=$(grep "^expire_days" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^purge_days" $CONFIGFILE && expire_days=$(grep "^purge_days" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^smart_purge=" $CONFIGFILE && smart_purge=$(grep "^smart_purge=" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^smart_purge_months" $CONFIGFILE && smart_purge_months=$(grep "^smart_purge_months" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^customer" $CONFIGFILE && customer=$(grep "^customer" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^notify_label" $CONFIGFILE && customer=$(grep "^notify_label" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^parallelism" $CONFIGFILE && parallelism=$(grep "^parallelism" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^date_format" $CONFIGFILE && dt_format=$(grep "^date_format" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^failure_notify" $CONFIGFILE && failure_notify=$(grep "^failure_notify" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^success_notify" $CONFIGFILE && success_notify=$(grep "^success_notify" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^master_position" $CONFIGFILE && master_position=$(grep "^master_position" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^free_space_percentage" $CONFIGFILE && min_disk_pfree=$(grep "^free_space_percentage" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^callout_url_before" $CONFIGFILE && url_before=$(grep "^callout_url_before" $CONFIGFILE | sed -re 's/([^=]*)=(.*)$/\2/')
	grep -q "^callout_url_after" $CONFIGFILE && url_after=$(grep "^callout_url_after" $CONFIGFILE | sed -re 's/([^=]*)=(.*)$/\2/')
	grep -q "^galera_info" $CONFIGFILE && galera=$(grep "^galera_info" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^restore_test_directory" $CONFIGFILE && restore_test_dir=$(grep "^restore_test_directory" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^backup_timeout" $CONFIGFILE && timeout=$(grep "^backup_timeout" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^kill_query_time" $CONFIGFILE && kill_query_time=$(grep "^kill_query_time" $CONFIGFILE | cut -d"=" -f2)
	grep -q "^open_files_limit" $CONFIGFILE && ulimit=$(grep "^open_files_limit" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^server_path" $CONFIGFILE && server_path=$(grep "^server_path" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^webhook_script" $CONFIGFILE && webhook_script=$(grep "^webhook_script" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^cloud_storage" $CONFIGFILE && cloud_storage=$(grep "^cloud_storage" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^heartbeat_schema" $CONFIGFILE && hb_schema=$(grep "^heartbeat_schema" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^heartbeat_table" $CONFIGFILE && hb_table=$(grep "^heartbeat_table" $CONFIGFILE | cut -d"=" -f2)
        grep -q "^heartbeat_stale_seconds" $CONFIGFILE && hb_stale_secs=$(grep "^heartbeat_stale_seconds" $CONFIGFILE | cut -d"=" -f2)

	if [ "$1" = "backup" ]
	then
		if [ "$host" = "" -o "$user" = "" ]
		then
			echo "Please set backup_host and backup_user in $CONFIGFILE."
			exit 1
		fi
		if [ "$target" = "" ]
		then
			echo "Please set target_directory in $CONFIGFILE."
				exit 1
		fi
		if [ ! -d "$target" ]
		then
			echo "Target directory $target does not exist."
			exit 1
		fi
	fi
	if [ "$compressor" != "" ]
	then
		ct=$(which ${compressor/%\ */} 2>/dev/null)
		if [ "$ct" = "" ]
		then
			echo "You have configured ${compressor/%\ */}, please install it first."
			exit 1
		fi
	fi
	if [ "$encryptor" != "" ]
	then
		ct=$(which ${encryptor/%\ */} 2>/dev/null)
		if [ "$ct" = "" ]
		then
			echo "You have configured ${encryptor/%\ */}, please install it first."
			exit 1
		fi
		if [ "$(which openssl 2>/dev/null)" = "" ]
		then
			echo "ERROR: This script requires the openssl package. Please install it."
			exit 1
		fi
	fi
	[ "$BM_DOWNLOADER" != "" ] && reader=$BM_DOWNLOADER
	[ "$BM_SERVER_PATH" != "" ] && server_path=$BM_SERVER_PATH

	lockfile=/tmp/backup_manager.lock
	binlog_lockfile=/tmp/backup_manager_binlogs.lock
	if [ "$success_notify" != "" -a "$failure_notify" = "" ]
	then
		echo "NOTICE: 'failure_notify' not set in config, using email in 'success_notify' for failure notifications."
		failure_notify=$success_notify
	fi
	if [ "$failure_notify" != "" ]
	then
		mx=$(which mailx 2>/dev/null)
		if [ "$mx" = "" ]
		then
			echo "You have configured email notifications, please install the mailx utility."
			exit 1
		fi
		if [ "$customer" = "" ]
		then
			echo "You have configured email notifications, please configure customer name."
			exit 1
		fi
	fi

	if [ "$1" = "backup" ]
	then
		get_backup_level $* || usage
		semaphore_setup $*
	else
		setup_trap other
	fi
}

server_check()
{
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	find_util mysqladmin
        $util -u $user $sock_str $pass_str ping >$aux_log 2>&1
	if [ $? -ne 0 ]
	then
		echo
		echo "ERROR: cannot connect to database instance"
	else
		fgrep -iq denied $aux_log || return
		echo
		fgrep -i denied $aux_log | sed -e "s/error/ERROR/"
	fi
	echo
	echo "pre-flight checks failed, cannot continue. Exiting."
	status=1; fire_webhook
	exit 1
}

mysql_variable()
{
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	echo "select @@$1" | mysql -ANr -u $user $sock_str $pass_str
}

prepare_target()
{
	backup_id=$(date "+%s$$" | md5sum | cut -d" " -f 1)
	case "$level" in
		0) fn=full_$(date +%H:%M);;
			1) fn=incr_$(date +%H:%M);;
		2) fn=${dumplist}_$(date +%H:%M);;
		3) fn=binlogs_$(date +%H:%M);;
	esac
	case "$tool" in
		'mydumper')
				fn=""
				tt=$target/$(date +$dt_format)/${tool}_$(date +%H:%M)
				;;
		'smartdump')
				fn="smartdump_$(date +%H:%M)"
				tt=$target/$(date +$dt_format)/$tool
				;;
		'mariaunpacked')
				fn=""
				tt=$target/$(date +$dt_format)/${tool}/$(date +%H:%M)
				;;
		*)
				tt=$target/$(date +$dt_format)/$tool
				;;
	esac
	mkdir -p $tt
	echo "Target directory for this backup: $tt"
	logfile=$tt/$backup_id.log
	case "$tool" in
		'binlogs'|'zsnapshot') ;;
		*) echo "Logfile: $logfile";;
	esac
}

save_bootstrap()
{
	case "$tool" in
		'mariabackup'| 'xtrabackup' | 'mariaunpacked' )
			cp $DB $(mysql_variable datadir)/$BOOTSTRAP_FILE 2>/dev/null
			;;
	esac
}

inventory_init()
{
	case "$level" in
		1) echo "insert into backup_history values('$backup_id', $runtime_id, '$(date +%Y-%m-%d\ %T)', NULL, '$location', '$logfile', NULL, $level, '$compressor', '$uncompressor', '$encryptor', '$unencryptor', '$local_key', NULL, '$tool', '$(mysql_variable version)', NULL, '$ref_full', NULL, '$dumplist', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL);" | dbquery $DB;;
		*) echo "insert into backup_history values('$backup_id', $runtime_id, '$(date +%Y-%m-%d\ %T)', NULL, '$location', '$logfile', NULL, $level, '$compressor', '$uncompressor', '$encryptor', '$unencryptor', '$local_key', NULL, '$tool', '$(mysql_variable version)', NULL, NULL, NULL, '$dumplist', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL);" | dbquery $DB;;
	esac
}

save_datadir_size()
{
	ddsz=$(du -B 1 -s --exclude="*\.[0-9][0-9][0-9][0-9][0-9][0-9]" $(mysql_variable datadir) | cut -f 1)
	[ "$ddsz" != "" ] && echo "update backup_history set datadir_size = $ddsz where uuid = '$backup_id';" | dbquery $DB
}

update_backup_status()
{
	check_status $1
	echo "update backup_history set end_time = '$(date +%Y-%m-%d\ %T)' where uuid = '$backup_id';" | dbquery $DB
	[ $status -ne 0 ] && return
	case_insens=$(mysql_variable lower_case_table_names)
	case "$tool" in
		'mariaunpacked')
			echo "update backup_history set last_lsn = $lsn, case_insensitive = $case_insens, backup_size = $(du -bs $tt | cut -f 1) where uuid = '$backup_id';" | dbquery $DB
			pit_xid
			;;
		'mariabackup'| 'xtrabackup' )
			echo "update backup_history set last_lsn = $lsn, case_insensitive = $case_insens, backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			pit_xid
			;;
		'zsnapshot')
			echo "update backup_history set backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			;;
		'mysqldump')
			echo "update backup_history set backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			;;
		'smartdump')
			echo "update backup_history set backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			;;
		'mydumper')
			echo "update backup_history set backup_size = $(du -b $tt | cut -f 1) where uuid = '$backup_id';" | dbquery $DB
			;;
		'binlogs')
			echo "update backup_history set backup_size = $(stat -c %s $tt/$fn) where uuid = '$backup_id';" | dbquery $DB
			;;
	esac
	case $level in
		0) save_datadir_size;;
		2) [ "$dumplist" = "ALL" ] && save_datadir_size;;
	esac
}

fire_webhook()
{
	[ "$webhook_script" = "" ] && return
	[ "$customer" != "" ] && export BACKUP_LABEL="$customer"
	eval $webhook_script $tool $level $status
}

perform_backup()
{
	echo "MariaDB Backup Manager $BM_VERSION starting"
	location=$tt/$fn 
	if [ "$encryptor" != "" -a "$enc_key" = "" ]
	then
		enc_key=$(openssl rand -base64 32)
		export enc_key="$enc_key"
		local_key=$enc_key
	fi
	inventory_init
	case "$tool" in
		'mariabackup')
			perform_maria_backup;;
		'zsnapshot')
			perform_zsnapshot_backup;;
		'mariaunpacked')
			perform_mariaunpacked_backup;;
		'xtrabackup')
			perform_xtra_backup;;
		'mysqldump')
			perform_mysqldump_backup;;
		'smartdump')
			perform_smartdump_backup;;
		'mydumper')
			perform_mydumper_backup;;
		'binlogs')
			perform_binlogs_backup;;
		*)
			echo "Unsupported backup tool $tool"
			clean_exit 1
			;;
	esac
}

perform_binlogs_backup()
{
	find_util mysqlbinlog
	if [ "$util" = "" ]
	then
		echo "ERROR: mysqlbinlog program not installed, but needed for binlogs backups."
		clean_exit 1
	else
		mysqlbinlog=$util
	fi
	if [ "$(mysql_variable log_bin)" != "1" ]
	then
		echo "ERROR: cannot backup binary logs if they are not enabled on server."
		clean_exit 1
	fi
	# check for a valid full backup to base binlogs backup on
	ref_id=$(echo "select uuid from backup_history where level = 0 and backup_tool in ('mariabackup','xtrabackup','mariaunpacked') and status = 0 order by start_time desc limit 1;" | dbquery $DB)
	if [ "$ref_id" = "" ]
	then
		echo "ERROR: no full backup available to base binlog backups on. Exiting."
		clean_exit 1
	else
		binlog_base=$(mysql_variable log_bin_basename)
		[ "$binlog_base" = "" ] && clean_exit 0 # server is down
		find_binlogs_backup_sp $ref_id
		build_binlog_list
		echo "Backing up binary log files" 
		echo "Files in this backup: $binlog_list"
		cd $(dirname $binlog_base)
		tar cf - $binlog_list 2>$error_log | $compressor | $encryptor 2>/dev/null > $tt/$fn
		if [ -s $error_log ]
		then
			status=1
		else
			blarr=($binlog_list)
			position_from_binlog ${binlog##*/}
			binlog_file=${binlog##*/}
			echo "update backup_history set ref_full_backup = '$ref_id' , binlog_file = '$binlog_file', binlog_position = $binlog_pos, gtid_binlog_pos='$gtid_binlog_pos', binlog_first = '${blarr[0]}', binlog_last = '${blarr[-1]}', binlog_last_ts = datetime('$lb_ts', '+1 second') where uuid = '$backup_id';" | dbquery $DB
			status=0
		fi
	fi
	update_backup_status
	fire_webhook
}

save_binlog_info()
{
	[ $status -ne 0 ] && return
	binlog_ts=$($mysqlbinlog --no-defaults --skip-annotate-row-events --base64-output=NEVER --stop-position $binlog_pos $(dirname $(mysql_variable log_bin_basename))/$binlog_file | fgrep "end_log_pos " | tail -1 | sed -re "s/^#([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+) ([0-9 ]*):([0-9]*):([0-9]*) server (.*)$/20\1\2-\3\4-\5\6 \7:\8:\9/" -e "s/( )([0-9]:)/0\2/")
	case "$tool" in
		'mariabackup'|'mariaunpacked'|'zsnapshot')
			gtid_binlog_pos=$(echo "select BINLOG_GTID_POS('$binlog_file',$binlog_pos)" | mysql -ANr -u $user $sock_str $pass_str)
			;;
	esac
}

check_status()
{
	case "$tool" in
		'mariabackup'|'xtrabackup'|'mariaunpacked')
			tail -5 $logfile | fgrep -q "completed OK"
			status=$? # override exit status from backup tool
			if [ $status -eq 1 ]
			then
				tail -1 $logfile | fgrep -q "BACKUP STAGE START: Lock wait timeout exceeded"
				if [ $? -eq 0 ]
				then
					echo
					echo "ERROR: backup could not be started due to other connection(s) holding metadata lock(s)."
					echo "This may happen if there is a bulk data load or other maintenance ongoing."
					echo "If you get this error repeatedly, it may mean that the workload is not backup compatible."
					echo "In this case, you can try and schedule the backup at a different time."
					echo
				fi
			fi
			if [ "$(mysql_variable log_bin)" = "1" -a $status -eq 0 ]
			then
                                if [ "$1" = "export" ]
                                then
                                        binlog_file=$(tail $logfile | fgrep "Last binlog file ." | sed -re "s/^(.*)\sLast binlog file \.\/(.*), position ([0-9]*)$/\2/")
                                        binlog_pos=$(tail $logfile | fgrep "Last binlog file ." | sed -re "s/^(.*)\sLast binlog file \.\/(.*), position ([0-9]*)$/\3/")
                                else
                                        binlog_file=$(tail $logfile | fgrep "MySQL binlog position:" | sed -re "s/^(.*)filename '(.*)', position '([0-9]*)'(.*)$/\2/")
                                        binlog_pos=$(tail $logfile | fgrep "MySQL binlog position:" | sed -re "s/^(.*)filename '(.*)', position '([0-9]*)'(.*)$/\3/")
                                fi
				save_binlog_info
                        fi
			echo "update backup_history set status = $status, binlog_file = '$binlog_file', binlog_position = '$binlog_pos', gtid_binlog_pos='$gtid_binlog_pos', binlog_last_ts = '$binlog_ts' where uuid = '$backup_id';" | dbquery $DB
			;;
		'zsnapshot')
			save_binlog_info
			echo "update backup_history set status = $status, binlog_file = '$binlog_file', binlog_position = '$binlog_pos', gtid_binlog_pos='$gtid_binlog_pos', binlog_last_ts = '$binlog_ts' where uuid = '$backup_id';" | dbquery $DB
			;;
		'mysqldump')
			[ -s $logfile ] && status=1
                        grep -q "^-- Dump completed" $dumptail || status=1
			echo "update backup_history set status = $status where uuid = '$backup_id';" | dbquery $DB
			;;
		'smartdump')
			ri=$(cat /tmp/smartdump_master_pos 2>/dev/null | sed -re "s/^(.*):(.*)\s(.*)$/, binlog_file = '\1', binlog_position = \2, gtid_binlog_pos = '\3'/")
			echo "update backup_history set status = $status $ri where uuid = '$backup_id';" | dbquery $DB
			;;
		*)	echo "update backup_history set status = $status where uuid = '$backup_id';" | dbquery $DB
			;;
	esac
        [ "$1" = "noprint" ] && return
	echo "Exit status of $tool was $status."
	[ $status -eq 0 ] && echo "Backup SUCCESSFUL" || echo "Backup FAILED"
}

incremental_check()
{
	[ $level -ne 1 ] && return
	extra=""
	ref_full=$(echo "select uuid from backup_history where level = 0 and backup_tool = '$tool' and status = 0 $extra order by start_time desc limit 1;" | dbquery $DB)
	if [ "$ref_full" = "" ]
	then
		msg="ERROR: no valid full backup found, cannot perform incremental backup at this time."
		echo $msg
		[ "$failure_notify" != "" ] && echo $msg | send_mail "$customer: backup FAILED" $failure_notify
		exit 1	
	fi
	echo "Performing an incremental backup based on $ref_full"
}

sqlite_inventory()
{
	echo
        echo -n "MariaDB Backup Manager v$BM_VERSION"
	echo
	echo
	[ -f $lockfile ] && g_r_id=$(cat $lockfile) || g_r_id=0
	[ -f $binlog_lockfile ] && b_r_id=$(cat $binlog_lockfile) || b_r_id=0
	case "$1" in
		'pretty'|'short') 
			width="0 0 5 0 0 10 0 0 0 9"
			echo -e ".width $width\nselect uuid as 'backup id', backup_tool as 'backup tool', case(level) when 0 then 'full' when 1 then 'incr' when 2 then 'dump' end as level, datetime(start_time) as 'start time        ', datetime(end_time) as 'end time           ', ((strftime('%s', end_time) - strftime('%s', start_time)) / 86400) || '+' || time(strftime('%s', end_time) - strftime('%s', start_time), 'unixepoch') as duration, last_lsn as 'last LSN', case when length(server_version) > 20 then substr(server_version,1,17) || '..' || substr(server_version, -1) else server_version end as 'server version', case when backup_size < 1000000 then substr('        ' || round(backup_size/1000.0, 2) || 'K', -10, 10) when backup_size between 1000000 and 999999999 then substr('        ' || round(backup_size/1000000.0, 2) || 'M', -10, 10) else substr('        ' || round(backup_size/1000000000.0, 2) || 'G', -10, 10) end as 'backup sz', case when datadir_size < 1000000 then substr('          ' || round(datadir_size/1000.0, 2) || 'K', -9, 9) when datadir_size between 1000000 and 999999999 then substr('          ' || round(datadir_size/1000000.0, 2) || 'M', -9, 9) else substr('          ' || round(datadir_size/1000000000.0, 2) || 'G', -9, 9) end as 'data size', case when status = 0 then 'succeeded' when status is null and runtime_id in ($g_r_id, $b_r_id) then 'running' else 'failed' end as status, case(level) when 2 then dumplist end as 'additional info' from backup_history order by start_time desc;" | inv_dbquery $DB 2>/dev/null | tee /tmp/bi$$
			;;
		'binlogs')
			width="1 0 0 5 0 0 9 9 28 13 0"
			echo -e ".width $width\nselect case(level) when 0 then 'F' else ' ' end as f, uuid as 'backup id', backup_tool as 'backup tool', case(level) when 0 then 'full' when 1 then 'incr' when 2 then 'dump' end as level, datetime(start_time) as 'start time        ', datetime(end_time) as 'end time           ', case when backup_size < 1000000 then substr('        ' || round(backup_size/1000.0, 2) || 'K', -8, 8) when backup_size between 1000000 and 999999999 then substr('        ' || round(backup_size/1000000.0, 2) || 'M', -8, 8) else substr('        ' || round(backup_size/1000000000.0, 2) || 'G', -8, 8) end as 'disk size', case when status = 0 then 'succeeded' when status is null and runtime_id in ($g_r_id, $b_r_id) then 'running' else 'failed' end as status, case(level) when 3 then '' else binlog_file || ':' || binlog_position end as 'backup position', substr(binlog_first, -6) || '-' || substr(binlog_last, -6) as binlogs, binlog_last_ts as 'backup point-in-time'  from backup_history order by binlog_last_ts desc;" | dbquery -column -header $DB 2>/dev/null | tee /tmp/bi$$
			;;
		*) echo "select * from backup_history order by start_time desc;" | inv_dbquery $DB 2>/dev/null | tee /tmp/bi$$
			;;
	esac
	echo
	if [ ! -s /tmp/bi$$ ]
	then
		echo "There are no backups in inventory. "
	fi
	rm -f /tmp/bi$$
	[ -d $target ] && echo "Backup directory $target $disk_space_p_used% used, $disk_space_avail left" 
	echo
}

usage() 
{               
	echo "usage: $0 backup [ mariabackup | mariaunpacked | xtrabackup | zsnapshot | mydumper | mysqldump | smartdump | binlogs ]" 
	exit 1                  
}   

level_usage()
{
	echo "usage: $0 backup $1 [ full | incr ]" 
	exit 1                  
}

get_backup_level()
{
	incr=""
	case "$2" in
		'mariaunpacked') level=0;;
		'mariabackup'|'xtrabackup'|'zsnapshot')
			incr="| incr"
			case "$3" in
				'full') level=0;;
				'incr'|'incremental') [ "$incr" != "" ] && level=1;;
				*) level_usage $2;;
			esac
			;;
		'mysqldump') 	level=2
				dumplist="$3"
				[ "$dumplist" = "" -o "$dumplist" = "full" ] && dumplist="ALL"
				;;
		'smartdump') 	level=2
				;;
		'binlogs') level=3;;
		'mydumper') level=0;;
		*) 	return 1;;
	esac
	return 0
}

do_backup()
{
	check_root backup
	tool=$1
	what="backup"
	server_check
	incremental_check
	prepare_target
	check_free_space
	check_slave_status
	curl_before
	save_bootstrap
	perform_backup
	email_notification
	curl_after
	purge_incomplete
}

get_repl_creds()
{
	[ "$BM_MASTER_INFO" != "" ] && mi="$BM_MASTER_INFO" || mi=$(mysql_variable datadir 2>/dev/null)/master.info
	if [ "$mi" = "/master.info" ]
	then
		echo "WARNING: no replication info available (local server is down and BM_MASTER_INFO env var is empty)"
		return
	fi
	if [ ! -f $mi ]
	then
		echo "WARNING: no replication info available (checked $mi)"
		return
	fi
	if [ "$(tail -1 $mi)" != "END_MARKER" ]
	then
		echo "WARNING: $mi doesn't look like valid replication info, ignoring"
		return
	fi
	lc=0
	while read -r l; do
		case $lc in
			3) repl_host="$l";;
			4) repl_user="$l";;
			5) repl_pass="$l";;
			6) repl_port="$l";;
			8) repl_ssl="$l";;
			9) repl_ssl_ca="$l";;
			11) repl_ssl_cert="$l";;
			13) repl_ssl_key="$l";;
		esac
       		lc=$((lc+1))
	done < $mi
}

which_gtid()
{
	gtid_list=$(tail $logfile | fgrep gtid_slave_pos | tr -d "'" | cut -d";" -f 1 | sed -re "s/^(.*)gtid_slave_pos\ (.*)$/\2/" | tr "," " ")
	tid=0
	for gtid in $gtid_list
	do
		this=$(echo $gtid | cut -d"-" -f3)
		[ $this -gt $tid ] && tid=$this
	done
	echo $tid
}

build_master_cmd()
{
	master_cmd="mysql -u $repl_user -p$repl_pass -h$repl_host -P$repl_port -ANr --skip-ssl --max-allowed-packet=1073741824"
}

convert_incr_to_full()
{
	lv=$(echo "select level from backup_history where uuid = '$1' and status = 0;" | dbquery $DB)
	[ "$lv" != "1" ] && return
	rf=$(echo "select ref_full_backup from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$rf" = "" ] && return
	pit=$(echo "select binlog_last_ts from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$pit" = "" ] && return
	echo "Converting request to full:$rf @ '$pit'"
	exec $0 restore $rf $2 "$pit" noconfirm
}

do_remote_restore()
{
	while true
	do
		echo -n "Please enter hostname or IP address of the remote restore target: "
		read target_host
		[ "$target_host" = "" ] && continue
		ssh -oConnectTimeout=10 root@$target_host true && break
		echo
		echo "That didn't work."
		echo "Please make sure you entered the correct information, and ssh keypair authentication is set up properly."	
		echo
		[ ! -t 0 ] && exit 1
	done
	if [ "$BM_BACKUP_PATH" = "" ]
	then    
		while true
		do
			echo -n "Please enter path where backups can be found on this host (or quit and set \$BM_BACKUP_PATH instead): "
			read backup_path
			[ "$backup_path" = "" ] && continue
			[ -d $backup_path ] && break
			echo
			echo "That didn't work."
			echo "Please enter a valid path."
			echo
		done    
	else    
		backup_path="$BM_BACKUP_PATH"
	fi      
	[ "$BM_SSH_KEY" != "" ] && ssh_key_opt="-i $BM_SSH_KEY"
	ssh="ssh -q $ssh_key_opt -oStrictHostKeyChecking=no root@$target_host"
	local_remote="$ssh"
	replication_credentials
	if [ "$repl_user" != "" ] 
	then
		admin_user="$ADMIN_USER"
		admin_pass="$ADMIN_PASSWORD"
		if [ "$admin_user" = "" -o "$admin_pass" = "" ]
	       	then
			echo "ERROR: automatic replication setup requires exporting ADMIN_USER and ADMIN_PASSWORD in the environment first. Exiting."
			exit 1
		fi
	fi
	do_restore $1 "$2" "$3" "$4"
	if [ "$repl_user" != "" ] 
	then
		$ssh chown -R mysql:mysql $2
		find_remote_mysql
		start_remote_server
		wait_for_remote_server
		user=$admin_user
		password=$admin_pass
		setup_replication $target_host $2
		echo "Replication set up successfully."
	fi
}

find_remote_mysql()
{
	if [ "$local_remote" != "eval" ]
	then
		mysqlcli=$($ssh "find / -xdev -type f -a -perm /001 -a \( -name mysql -o -name mariadb \)" | head -1)
	else
		mysqlcli=$(find / -xdev -type f -a -perm /001 -a \( -name mysql -o -name mariadb \) | head -1)
	fi
	[ "$mysqlcli" = "" ] && mysqlcli="mysql"
}

wait_for_remote_server()
{
	cd=10
	echo -n "Waiting for remote service to start..."
	while true
	do
        	echo "select 1" | $ssh $mysqlcli -u $admin_user -p$admin_pass > /dev/null 2>&1 && break
		cd=$((cd-1))
		[ $cd -eq 0 ] && break
		echo -n "."
		sleep 9
	done
	echo
	if [ $cd -eq 0 ]
	then
		echo "ERROR: server failed to start, or admin credentials not working. Exiting."
		exit 1
	fi
}

start_remote_server()
{
	
	echo -n "Starting remote server... "
	if [ "$($ssh which supervisorctl 2>/dev/null)" != "" ]
	then
		$ssh supervisorctl start mariadb
		echo
		return
	fi
	if [ "$($ssh which systemctl 2>/dev/null)" != "" ]
	then
		$ssh systemctl start mariadb.service
		echo
		return
	fi
	if [ "$($ssh which service 2>/dev/null)" != "" ]
	then
		$ssh service mariadb start
		echo
		return
	fi
	echo "ERROR: unable to start MariaDB service on remote target. Exiting."
	exit 1
}

compression_encryption_override()
{
	uncompressor=$(echo "select uncompressor from backup_history where uuid = '$1';" | dbquery $DB)
	if [ "$(which $uncompressor 2>/dev/null)" = "" ]
	then
		echo "ERROR: cannot exec '$uncompressor', is the program installed on this machine?"
		exit 1
	fi
	unencryptor=$(echo "select unencryptor from backup_history where uuid = '$1';" | dbquery $DB)
	if [ "$(which $unencryptor 2>/dev/null)" = "" ]
	then
		echo "ERROR: cannot exec '$unencryptor', is the program installed on this machine?"
		exit 1
	fi
}

find_util()
{
	util=$($ssh which $1 2>/dev/null)
	[ "$util" != "" ] && return
	util=$($ssh find / -xdev -type f -a -perm /001 -a -name $1 | head -1)
}

do_restore()
{
	check_root restore
	if [ "$1" = "" ]
	then
		echo "usage: $0 restore <backupid> <targetdir> [ <point-in-time> ]" 
		exit 1
	fi
	if [ "$1" = "test" ]
	then
		do_restore_test
		return
	fi
	convert_incr_to_full $*
	what="restore"
	uuid=$1
	if [ $(echo "select count(*) from backup_history where uuid = '$1' and level in (0, 2) and status = 0;" | dbquery $DB) -eq 0 ]
	then
		echo "full backup with id '$1' not found, or not valid."
		exit 1
	fi
	tool=$(echo "select backup_tool from backup_history where uuid = '$1';" | dbquery $DB)
	if [ "$ssh" != "" -a "$tool" != "mariabackup" ]
	then
		echo "ERROR: this backup type does not support remote restore."
		exit 1
	fi
	case "$tool" in
		'binlogs'|'mariaunpacked')	toolcheck="mysqlbinlog";;
		'zsnapshot')			toolcheck="zfs";;
		*)				toolcheck=$tool
	esac
	find_util $toolcheck
	if [ "$util" = "" ]
	then
		if [ "$toolcheck" = "mariabackup" ]
		then
			find_util mariadb-backup
			if [ "$util" = "" ]
			then
				echo "ERROR: tool $toolcheck needed to restore '$1' is not installed. Please install it."
				exit 1
			fi
		else
			echo "ERROR: tool $toolcheck needed to restore '$1' is not installed. Please install it."
			exit 1
		fi
	fi
	if [ "$tool" = "mariabackup" ]
	then
		find_util mbstream
		if [ "$util" = "" ]
		then
			echo "ERROR: tool mbstream, needed to restore '$1', is not installed. Please install it."
			exit 1
		fi
	fi
	if [ "$tool" = "xtrabackup" ]
	then
		find_util xbstream
		if [ "$util" = "" ]
		then
			echo "ERROR: tool xbstream, needed to restore '$1', is not installed. Please install it."
			exit 1
		fi
	fi
	case "$tool" in
		'mariabackup'|'xtrabackup'|'mariaunpacked'|'zsnapshot')
			if [ "$2" = "" ]
			then
				echo "usage: $0 restore [ backupid ] [ targetdir ] [ point-in-time ]"
				exit 1
			fi
			target=$2
			if [ "$target" != "-" ]
			then
				if $ssh [ -d $target ]
				then
					if [ "$($ssh ls -a1 $target | tr -d ".\n")" != "" ]
					then
						echo "ERROR: target directory $target must be empty."
						exit 1
					fi
				fi
			fi
			[ "$3" != "" ] && validate_point_in_time "$3" $4
			if [ $point_in_time -eq 1 ]
			then
				find_util mysql
				if [ "$util" = "" ]
				then
					find_util mariadb
					if [ "$util" = "" ]
					then
						echo "ERROR: mysql CLI, needed for point-in-time restore, is not installed. Please install it."
						exit 1
					else
						mysqlcli=$util
					fi
				else
					mysqlcli=$util
				fi
				find_util mysqlbinlog
				if [ "$util" = "" ]
				then
					echo "ERROR: tool mysqlbinlog, needed for point-in-time restore, is not installed. Please install it."
					exit 1
				else
					mysqlbinlog=$util
				fi
			fi
			[ "$2" != "-" ] && echo -n "Restoring backup '$uuid' using $tool to $target"
			[ "$2" != "-" ] && echo
			if [ "$target" != "-" -a "$local_remote" = "eval" ]
			then
				[ ! -d $target ] && mkdir -p $target
				logfile=$target/restore.log
			else
				logfile=/tmp/restore.log
				[ "$RESTORE_LOG" != "" ] && logfile=$RESTORE_LOG
			fi
			rm -f $logfile
			[ "$tool" != "zsnapshot" ] && echo "Logfile: $logfile"
			;;
	esac
	dim_prepare_memory
	compression_encryption_override $1
	case "$tool" in
		'mariabackup')
			perform_maria_restore;;
		'mariaunpacked')
			perform_mariaunpacked_restore;;
		'zsnapshot')
			perform_zsnapshot_restore;;
		'xtrabackup')
			perform_xtra_restore;;
		'mysqldump')
			perform_mysqldump_restore;;
		'smartdump')
			perform_smartdump_restore;;
		'mydumper')
			perform_mydumper_restore;;
	esac
	case "$tool" in
		'mariabackup'|'xtrabackup')
			if [ "$target" != "-" ]
			then
				echo "Exit status of $tool was $status."
				if [ $restore_test -eq 1 ]
				then
					if [ $status -eq 0 ]
					then
						[ "$success_notify" != "" ] && echo "Restore test successful. Details in /tmp/restore.log" | send_mail "$customer: restore test SUCCESSFUL" $success_notify 
					else
						[ "$failure_notify" != "" ] && echo "Restore test FAILED, please see /tmp/restore.log for details" | send_mail "$customer: restore test FAILED" $failure_notify
					fi
				else
					if [ $status -eq 0 ]
					then
						echo "Restore complete."
						[ "$repl_user" = "" ] && echo "Please don't forget to chown -R mysql:mysql $target."
					else
						echo "ERROR: restore failed! Please see $logfile for details."
						exit 1
					fi
				fi
			else
				echo $status > /tmp/build_slave.status
			fi
			;;
	esac
}

inventory_cleanup()
{
	exit 1
}

extract_binlog_piece()
{
	path=$(echo "select bulocation from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$backup_path" != "" ] && path=$backup_path/$(echo $path | sed -re "s/^(.*)\/([0-9-]*)\/(.*)\/(.*)$/\2\/\3\/\4/")
	key=$(echo "select cryptkey from backup_history where uuid = '$1';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	if [ "$reader" = "$default_reader" -a ! -f $path ]
	then
		echo "ERROR: binlogs backup archive not found. Aborting restore."
		mariadb_instance stop
		return 1
	fi
	eval $reader | $unencryptor 2>/dev/null | $uncompressor | tar xf -
	first_b=$(basename $(ls -1 $bxfolder/* | head -1))
	last_b=$(basename $(ls -1 $bxfolder/* | tail -1))
	if [ "$requested_binlog_file" != "" ]
	then
		[ "$last_b" \> "$requested_binlog_file" ] && last_b=$requested_binlog_file
	else
		scan_binlog_archive
		if [ "$last_b" = "" ]
 		then
 			echo "ERROR: required binlog $bf_start_file not available. Aborting restore."
			mariadb_instance stop
 			return 1
 		fi
	fi
	[ "$bf_start_file" \> "$first_b" ] && first_b=$bf_start_file
	echo -n "applying binlog files from $first_b to $last_b.."
	for bf in $(ls $bxfolder)
	do
		[ "$bf_start_file" \> "$bf" ] && continue
		echo -n "."
		if [ "$bf" != "$requested_binlog_file" ]
		then
			if [ $initial_bf_done -eq 1 ]
			then
				cat $bxfolder/$bf | $local_remote $mysqlbinlog --no-defaults --stop-datetime="'$requested_binlog_ts'" - | $ssh mysql -A -S /tmp/backup_manager.sock 2>$aux_log
			else
				initial_bf_done=1
				cat $bxfolder/$bf | $local_remote $mysqlbinlog --no-defaults --start-position=$bf_start_pos --stop-datetime="'$requested_binlog_ts'" - | $ssh mysql -A -S /tmp/backup_manager.sock 2>$aux_log
			fi
			if [ $? -ne 0 ]
			then
				echo
				echo "ERROR: apply of binary log $bf failed!"
				cat $aux_log
				echo "Aborting restore."
				mariadb_instance stop
				return 1
			fi
		else
			last_file=$bf
			if [ $initial_bf_done -eq 1 ]
			then
				cat $bxfolder/$bf | $local_remote $mysqlbinlog --no-defaults --stop-position=$requested_binlog_position --stop-datetime="'$requested_binlog_ts'" - | $ssh mysql -A -S /tmp/backup_manager.sock 2>$aux_log
			else
				cat $bxfolder/$bf | $local_remote $mysqlbinlog --no-defaults --start-position=$bf_start_pos --stop-position=$requested_binlog_position --stop-datetime="'$requested_binlog_ts'" - | $ssh mysql -A -S /tmp/backup_manager.sock 2>$aux_log
			fi
			if [ $? -ne 0 ]
			then
				echo
				echo "ERROR: apply of binary log $bf failed!"
				cat $aux_log
				echo "Aborting restore."
				mariadb_instance stop
				return 1
			fi
			break
		fi
		[ "$bf" = "$last_b" ] && break
	done
	echo
	rm -f $bxfolder/*
	return 0
}

check_root()
{
	if [ $(id -u) -ne 0 ]
        then
                echo "the $1 command requires superuser privileges. Exiting."
                exit 1
        fi
}

backup_stage()
{
	case "$1" in
		'START') echo -n "BACKUP STAGE: $1 ";;
		'END') echo "$1";;
		*) echo -n "$1 ";;
	esac
	echo "backup stage $1;" >&${mysqlc[1]}
	while read -t 0.2 -u ${mysqlc[0]} row
	do
		echo "$row"
	done > $aux_log
	fgrep -q "Query OK," $aux_log 2>/dev/null
	if [ $? -ne 0 ]
	then
		echo
		cat $aux_log
		echo "Exiting."
		clean_exit 1
	fi
}

zfs_purge_snapshots()
{
	[ $level -ne 0 ] && return
	id=$(echo "select uuid from backup_history where level = 0 and backup_tool = 'zsnapshot' and status = 0 order by start_time desc limit 1;" | dbquery $DB)
	[ "$id" = "" ] && return
	for ip in $(echo "select uuid from backup_history where ref_full_backup = '$id' and level=1;" | dbquery $DB)
	do
		zfs destroy ${snap_t:1}@$ip
	done
	zfs destroy ${snap_t:1}@$id
}

zfs_preflight_checks()
{
	d=$(mysql_variable datadir)
	if [ "$(df -t zfs $d/ibdata1 2>/dev/null)" = "" ]
	then
		echo "ERROR: snapshot backup requires that datadir is on a ZFS filesystem. Exiting."
		clean_exit 1
	fi
	z=$(which zfs 2>/dev/null)
	if [ "$z" = "" ]
	then
		echo "Please install the zfs command."
		clean_exit 1
	fi
	zfs_purge_snapshots
}

perform_zsnapshot_backup()
{
	find_util mysqlbinlog
	if [ "$util" = "" ]
	then
		echo "ERROR: cannot find mysqlbinlog tool, please make sure it is installed."
		clean_exit 1
	else
		mysqlbinlog=$util
	fi
	echo "Performing backup using ZFS snapshot."
	snap_t=$(stat -Lc %m $(mysql_variable datadir))
	zfs_preflight_checks
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	coproc mysqlc { script -c "mysql -ANr -u $user $sock_str $pass_str 2>&1" /dev/null; }
	backup_stage START
	backup_stage FLUSH
	backup_stage BLOCK_DDL
	backup_stage BLOCK_COMMIT
	zfs snapshot ${snap_t:1}@$backup_id 2>$aux_log
	if [ $? -ne 0 ]
	then
		echo "ERROR: zfs snapshot command failed!"
		cat $aux_log
		echo "Exiting."
		clean_exit 1
	fi
	ms=$(echo "show master status" | mysql -ANr -u $user $sock_str $pass_str 2>$aux_log)
	if [ "$ms" = "" ]
	then
		echo -n "ERROR: cannot obtain master status: "
		cat $aux_log
		echo "Exiting."
		clean_exit 1
	fi
	binlog_file=$(echo "$ms" | cut -f 1)
	binlog_pos=$(echo "$ms" | cut -f 2)
	backup_stage END
	echo -n "Saving snapshot... "
	case "$level" in
		0)
			zfs send ${snap_t:1}@$backup_id | $compressor | $encryptor > $tt/$fn 2>$aux_log
			;;
		1)
			zfs send -i @$ref_full ${snap_t:1}@$backup_id | $compressor | $encryptor > $tt/$fn 2>$aux_log
			;;
	esac
	if [ $? -ne 0 ]
	then
		echo "ERROR: zfs send command failed!"
		cat $aux_log
		echo "Exiting."
		clean_exit 1
	fi
	echo
	update_backup_status
	fire_webhook
}

perform_maria_backup()
{
	find_util mariabackup
	if [ "$util" = "" ]
	then
		find_util mariadb-backup
		if [ "$util" = "" ]
		then
			echo "ERROR: Please install $tool first."
		else
			mariabackup=$util
		fi
		clean_exit 1
	else
		mariabackup=$util
	fi
	echo "Performing backup using $tool."
	find_util mysqlbinlog
	if [ "$util" = "" ]
	then
		echo "ERROR: cannot find mysqlbinlog tool, please make sure it is installed."
		clean_exit 1
	else
		mysqlbinlog=$util
	fi
	mkdir -p $target/checkpoints/mariabackup
	open_files_limit
	[ "$password" != "" ] && pass_str="--password=$password"
	[ "$socket" != "" ] && sock_str="--socket=$socket"
	[ $galera -eq 1 ] && galera_str="--galera-info"
	[ $kill_query_time -gt 0 ] && kill_str="--kill-long-queries-timeout=$kill_query_time --kill-long-query-type=SELECT"
	case $level in
		0)
			$mariabackup --backup $galera_str $kill_str $limit_str --user=$user $pass_str $sock_str --parallel=$parallelism --extra-lsndir=/tmp --stream=xbstream --slave-info --ftwrl-wait-timeout=$BACKUP_LOCK_TIMEOUT --ftwrl-wait-threshold=999999 --target-dir=$tt 2>> $logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/mariabackup 2>/dev/null
			;;
		1)
			cp $target/checkpoints/mariabackup/xtrabackup_checkpoints /tmp 2>/dev/null
			$mariabackup --backup $galera_str $kill_str $limit_str --incremental-basedir=$target/checkpoints/mariabackup --user=$user $sock_str $pass_str --parallel=$parallelism --extra-lsndir=/tmp --stream=xbstream --slave-info --ftwrl-wait-timeout=$BACKUP_LOCK_TIMEOUT --ftwrl-wait-threshold=999999 --target-dir=$tt 2>> $logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/mariabackup 2>/dev/null
			;;
	esac
	get_lsn
	update_backup_status
	fire_webhook
}

open_files_limit()
{
	[ "$ulimit" = "" ] && return
	limit_str="--open-files-limit=$ulimit"
	curr_fmax=$(cat /proc/sys/fs/file-max)
	[ $curr_fmax -lt $ulimit ] && echo $((ulimit+curr_fmax)) > /proc/sys/fs/file-max
}

perform_mariaunpacked_backup()
{
	find_util mariabackup
	if [ "$util" = "" ]
	then
		find_util mariadb-backup
		if [ "$util" = "" ]
		then
			echo "ERROR: Please install $tool first."
		else
			mariabackup=$util
		fi
		clean_exit 1
	else
		mariabackup=$util
	fi
	echo "Performing backup using $tool."
	find_util mysqlbinlog
	if [ "$util" = "" ]
	then
		echo "ERROR: cannot find mysqlbinlog tool, please make sure it is installed."
		clean_exit 1
	else
		mysqlbinlog=$util
	fi
	mkdir -p $target/checkpoints/mariaunpacked
	[ "$password" != "" ] && pass_str="--password=$password"
	[ "$socket" != "" ] && sock_str="--socket=$socket"
	[ $galera -eq 1 ] && galera_str="--galera-info"
	[ $kill_query_time -gt 0 ] && kill_str="--kill-long-queries-timeout=$kill_query_time --kill-long-query-type=SELECT"
	case $level in
		0)
			$mariabackup --backup $galera_str $kill_str --user=$user $pass_str $sock_str --parallel=$parallelism --extra-lsndir=/tmp --slave-info --ftwrl-wait-timeout=$BACKUP_LOCK_TIMEOUT --ftwrl-wait-threshold=999999 --target-dir=$tt 2>> $logfile &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/mariaunpacked 2>/dev/null
			;;
		1)	# NOT IMPLEMENTABLE
			;;
	esac
        check_status noprint
        [ $status -ne 0 ] && return
	open_files_limit
        dim_prepare_memory
        $mariabackup --prepare $limit_str --export --use-memory=${prepare_memory}K --target-dir=$tt >> $logfile 2>&1
        status=$?
        [ $status -ne 0 ] && return
        tail -1 $logfile | fgrep -q "completed OK"
        status=$?
	fire_webhook
        [ $status -ne 0 ] && return
        get_lsn
        update_backup_status export
        echo "Backup prepared successfully for export."
}

perform_xtra_backup()
{
	xtrabackup=$(which xtrabackup 2>/dev/null)
	if [ "$xtrabackup" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool."
	fi
	mkdir -p $target/checkpoints/xtrabackup
	[ "$password" != "" ] && pass_str="--password=$password"
	[ "$socket" != "" ] && sock_str="--socket=$socket"
	[ $galera -eq 1 ] && galera_str="--galera-info"
	[ $kill_query_time -gt 0 ] && kill_str="--kill-long-queries-timeout=$kill_query_time --kill-long-query-type=SELECT"
	case $level in
		0)
			xtrabackup --backup $galera_str $kill_str --user=$user $pass_str $sock_str --parallel=$parallelism --extra-lsndir=/tmp --target-dir=$tt --stream=xbstream --slave-info 2>> $logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/xtrabackup 2>/dev/null
			;;
		1)
			cp $target/checkpoints/xtrabackup/xtrabackup_checkpoints /tmp 2>/dev/null
			xtrabackup --backup $galera_str $kill_str --incremental-basedir=$target/checkpoints/xtrabackup --user=$user $pass_str $sock_str --parallel=$parallelism --extra-lsndir=/tmp --target-dir=$tt --stream=xbstream --slave-info 2>> $logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
			run_with_timeout
			mv -f /tmp/xtrabackup_checkpoints $target/checkpoints/xtrabackup 2>/dev/null
			;;
	esac
	get_lsn
	update_backup_status
	fire_webhook
}

perform_mydumper_backup()
{
	mydumper=$(which mydumper 2>/dev/null)
	if [ "$mydumper" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool." 
		[ "$compressor" != "cat" ] && echo "Note: compression configured in config file, but $tool will use its built-in compression instead."
		[ "$encryptor" != "cat" ] && echo "Warning: encryption configured in config file, but not supported by $tool, hence setting ignored."
	fi
	[ $kill_query_time -gt 0 ] && kill_str="-l $kill_query_time -K"
	case $level in
		0)
			[ "$password" != "" ] && pass_str="-p $password"
			[ "$socket" != "" ] && sock_str="-S $socket"
			$mydumper -o $tt -t $parallelism -L $logfile $kill_str -G -E -R -v 3 -c -h $host -P $port $sock_str -u $user $pass_str &
			run_with_timeout
			;;
		1)
			echo "Incremental backups not supported by $tool. Exiting."
			clean_exit 1
			;;
	esac
	update_backup_status
	fire_webhook
}

set_read_only()
{
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	[ "$port" != "" ] && port_str="-P$port"
	echo "set global read_only=$1" | mysql -A -u $user $sock_str $pass_str $port_str
}

perform_smartdump_backup()
{
	smartdump=$(which smartdump 2>/dev/null)
	if [ "$smartdump" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool."
	fi
	ro=$(mysql_variable read_only)
	[ "$ro" = "1" ] && set_read_only 0
	[ "$password" != "" ] && pass_str="--password $password"
	[ "$socket" != "" ] && sock_str="--socket $socket"
	[ "$port" != "" ] && port_str="--port $port"
	$smartdump  --dump --lock-timeout=30 --threads $parallelism --host $host --user $user $pass_str $sock_str $port_str 2>$logfile | $compressor | $encryptor 2>/dev/null > $tt/$fn &
	run_with_timeout
	[ "$ro" = "1" ] && set_read_only 1
	update_backup_status
	fire_webhook
}

perform_mysqldump_backup()
{
	mysqldump=$(which mysqldump 2>/dev/null)
	if [ "$mysqldump" = "" ]
	then
		echo "ERROR: Please install $tool first."
		clean_exit 1
	else
		echo "Performing backup using $tool."
	fi
	[ "$dumplist" = "ALL" ] && dbstr="--all-databases --master-data=2" || dbstr="--databases ${dumplist//,/ }"
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	[ "$port" != "" ] && port_str="-P$port"
	[ $master_position -eq 1 ] && mp_str="--dump-slave=2"
	$mysqldump --single-transaction --routines --triggers $mp_str --log-error=$logfile --max_allowed_packet=1G -h $host $port_str $sock_str -u $user $pass_str $dbstr | tee >(tail -1 > $dumptail) | $compressor | $encryptor 2>/dev/null > $tt/$fn &
	run_with_timeout
	update_backup_status
	fire_webhook
}

perform_mydumper_restore()
{
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	echo "To restore this $tool dump, please use: myloader -d $path ..."
	exit 0
}

perform_smartdump_restore()
{
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	[ "$password" != "" ] && pass_str="--password $password"
	[ "$socket" != "" ] && sock_str="--socket $socket"
	[ "$port" != "" ] && port_str="--port $port"
	eval $reader | $unencryptor 2>/dev/null | $uncompressor | smartdump --stream --threads $parallelism --host $host --user $user $pass_str $sock_str $port_str
	status=$?
}

perform_mysqldump_restore()
{
	if [ -t 1 ]
	then
		echo "To restore this $tool dump, please use: $0 restore $uuid | mysql -h ... "
		exit 1
	fi
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	eval $reader | $unencryptor 2>/dev/null | $uncompressor
	status=$?
}

do_restore_test()
{
	tb=$(echo "select uuid from backup_history where level = 0 and status = 0 and backup_tool in ('mariabackup', 'xtrabackup') order by start_time desc limit 1;" | dbquery $DB)
	if [ "$tb" = "" ]
	then
		msg="no valid backup found to perform a restore test. Exiting."
		echo "ERROR: $msg"
		[ ! -t 1 -a "$failure_notify" != "" ] && echo $msg | send_mail "$customer: restore test FAILED" $failure_notify
		return
	fi
	echo "Performing a test restore of backup $tb and related incrementals"
	restore_test=1
	[ "$restore_test_dir" != "" ] && do_restore $tb $restore_test_dir/RESTORE-TEST || do_restore $tb $target/RESTORE-TEST
	mv $logfile /tmp/
	echo "Removing restore test directory $target. Details of this test execution can be found in /tmp/restore.log."
	rm -rf $target
	exit $status
}

build_slave()
{
	check_root build_slave
	if [ "$1" = "" -o "$2" = "" ]
	then
		echo "usage: $0 build-slave [ targethost ] [ targetdir ]"
		exit 1
	fi
	replication_credentials
	if [ "$repl_user" = "" ] 
	then
		echo "Not a slave myself, cannot build another slave. Exiting."
		exit 1
	fi
	ssh_setup $1
	echo "*** Login to $1 successful"
	if [ $setup_repl_only -eq 0 ]
	then
		ssh -q $1 test -d $2
		if [ $? -ne 0 ]
		then
			ssh -q $1 mkdir $2
			if [ $? -ne 0 ]
			then
				echo "error creating target directory $2 on $1. Exiting."
				exit 1
			fi
		fi
		if [ "$(ssh -q $1 ls -1 $2)" != "" ]
		then
			echo "target directory $2 on target host $1 must be empty. Exiting."
			exit 1
		fi
        	uuid=$(echo "select uuid from backup_history where level = 0 and backup_tool in ('mariabackup','xtrabackup') and status = 0 order by start_time desc limit 1;" | dbquery $DB)
		if [ "$uuid" = "" ]
		then
			echo "no backup suitable for slave build found in inventory. Exiting."
			exit 1
		fi
        	tool=$(echo "select backup_tool from backup_history where uuid = '$uuid';" | dbquery $DB)
		case "$tool" in
			'mariabackup') rtool="mbstream"; ropts="-p $parallelism";;
			'xtrabackup') rtool="xbstream"; ropts="";;
		esac
		ssh -q $1 id mysql >/dev/null 2>&1
		if [ $? -ne 0 ]
		then
			echo "ERROR: MariaDB not found. Please install MariaDB-server package on $1 and retry."
			exit 1
		fi
		ssh -q $1 which $rtool >/dev/null 2>&1
		if [ $? -ne 0 ]
		then
			echo "ERROR: $rtool is not installed on $1. Please install the $tool package there and retry."
			exit 1
		fi
		echo "*** Streaming last good full backup ($uuid) to $1:$2"
		r_uncompressor=$uncompressor
		uncompressor="cat" 
		do_restore $uuid - | ssh -q $1 "$r_uncompressor | $rtool $ropts -v -x -C $2"
		status=$(cat /tmp/build_slave.status)
		if [ $status -ne 0 ]
		then
			echo "Streaming error detected! Exiting."
			exit 1
		fi
		echo "*** Preparing backup on $1"
        	avail=$(ssh -q $1 "grep ^MemTotal /proc/meminfo" | sed -re "s/^MemTotal:(\s*)([0-9]*) kB/\2/")
		["$avail" = "" ] && avail=16777216
        	prepare_memory=$((avail/4))
		[ "$tool" = "mariabackup" ] && open_files_limit
		ssh -q $1 $tool --prepare $limit_str --use-memory=${prepare_memory}K --target-dir=$2
		echo "*** Fixing permissions on $1"
		ssh -q $1 chown -R mysql:mysql $2
		echo "*** Starting MariaDB on $1"
		ssh -q $1 service mysql start
		if [ $? -ne 0 ]
		then
			ssh -q $1 service mariadb start
			if [ $? -ne 0 ]
			then
				echo "MariaDB failed to start. Stopping here."
				echo "You can start it by hand and resume the process with: '$0 setup-replication $*'"
				exit 1
			fi
		fi
	fi
	if [ "$repl_user" != "" ]
	then
		state_update "setting up replication"
		echo "*** Setting up replication on $1"
		[ "$password" != "" ] && pass_str="-p$password"
		config_lookup $1 socket || build_slave_failure $*
		[ "$cfg" != "" ] && sock_str="-S$cfg" || sock_str=""
		gtid=$(ssh -q $1 cat $2/xtrabackup_binlog_info | sed -re "s/^(.*)\s+(.*)\s+(.*)/\3/")
		if [ "$gtid" = "" -a "$BM_OVERRIDE_GTID_POS" = "" -a "$BM_CLEAR_GTID_POS" = "" ]
		then
			echo "Unable to get GTID info for replication. Are GTIDs enabled on backup server?"
			exit 1
		fi
		( 
			echo "RESET MASTER;"
			if [ "$BM_CLEAR_GTID_POS" = "" ]
			then
				if [ "$BM_OVERRIDE_GTID_POS" != "" ]
				then
					echo "SET GLOBAL gtid_slave_pos = '$BM_OVERRIDE_GTID_POS';"
				else
					echo "SET GLOBAL gtid_slave_pos = '$gtid';"
				fi
				echo "CHANGE MASTER TO MASTER_HOST='$repl_host', MASTER_PORT=$repl_port, MASTER_USER='$repl_user', MASTER_PASSWORD='$repl_pass', MASTER_USE_GTID=slave_pos;"
			else
				echo "CHANGE MASTER TO MASTER_HOST='$repl_host', MASTER_PORT=$repl_port, MASTER_USER='$repl_user', MASTER_PASSWORD='$repl_pass';"
			fi
			[ "$repl_ssl" = "1" ] && echo "CHANGE MASTER TO MASTER_SSL=1, MASTER_SSL_CA='$repl_ssl_ca', MASTER_SSL_CERT='$repl_ssl_cert', MASTER_SSL_KEY='$repl_ssl_key';"
			echo "START SLAVE;" 
		) | ssh -q $1 "cat | $mysqlcli -ANr -u $user $sock_str $pass_str" || build_slave_failure $*
		sleep 10
		success=$(echo "show slave status\G" | ssh -q $1 $mysqlcli -Ar -u $user $sock_str $pass_str | grep 'Running:' | fgrep -c Yes)
		if [ "$success" = "2" ]
		then
			echo "*** Slave started successfully!"
		fi
	fi
	[ $setup_repl_only -eq 0 ] && echo "*** Build complete."
}

build_slave_failure()
{
	[ $setup_repl_only -eq 0 ] && echo "Replication setup failed."
	echo "Please fix the issue and retry with: '$0 setup-replication $*'"
	exit 1
}

config_lookup()
{
	cfg=$(ssh -q $1 "find /etc/my* -type f -name \*.cnf | xargs grep -rh ^$2" | sort | uniq | tr -d "[ \t]" | cut -d"=" -f 2)
	if [ $(echo "$cfg" | wc -w) -gt 1 ]
	then
		echo "ERROR: found multiple config values for $2!"
		return 1
	fi
	return 0
}

perform_xtra_restore()
{
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	if [ "$target" != "-" ]
	then
		mkdir -p $target/full
		echo -n "extracting full backup $uuid... "
		echo "--> eval $reader | $unencryptor | $uncompressor | xbstream -p $parallelism -x -v -C $target/full" >> $logfile
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | xbstream -p $parallelism -x -v -C $target/full 2>> $logfile
	else
		eval $reader | $unencryptor 2>/dev/null | $uncompressor 2>> $logfile
		status=$?
		return
	fi
	status=$?
	echo
	[ $status -ne 0 ] && return
	echo -n "applying redo logs for $uuid... "
	echo "--> xtrabackup --prepare --apply-log-only --use-memory=${prepare_memory}K --target-dir=$target/full" >> $logfile
	xtrabackup --prepare --apply-log-only --use-memory=${prepare_memory}K --target-dir=$target/full >> $logfile 2>&1
	status=$?
	echo
	[ $status -ne 0 ] && return
	tail -1 $logfile | fgrep -q "completed OK"
	status=$?
	[ $status -ne 0 ] && return
	binlogs_starting_point=$uuid
	for id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and backup_tool = '$tool' and status =0 order by start_time asc;" | dbquery $DB)
	do
		incr_check_position $id && break
		path=$(echo "select bulocation from backup_history where uuid = '$id';" | dbquery $DB)
		key=$(echo "select cryptkey from backup_history where uuid = '$id';" | dbquery $DB)
		[ "$key" != "" ] && export enc_key="$key"
		incdir=$(basename $path)
		echo -n "extracting incremental backup $id... "
		mkdir -p $target/$incdir
		echo "--> eval $reader | $unencryptor | $uncompressor | xbstream -p $parallelism -x -v -C $target/$incdir" >> $logfile
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | xbstream -p $parallelism -x -v -C $target/$incdir 2>> $logfile
		status=$?
		echo
		[ $status -ne 0 ] && break
		echo -n "applying redo logs for $id... "
		echo "--> xtrabackup --prepare --apply-log-only --use-memory=${prepare_memory}K --target-dir=$target/full --incremental-dir=$target/$incdir" >> $logfile
		xtrabackup --prepare --apply-log-only --use-memory=${prepare_memory}K --target-dir=$target/full --incremental-dir=$target/$incdir >> $logfile 2>&1
		status=$?
		echo
		[ $status -ne 0 ] && break
		tail -1 $logfile | fgrep -q "completed OK"
		status=$?
		[ $status -ne 0 ] && break
		binlogs_starting_point=$id
		rm -rf $target/$incdir
	done
	[ $status -ne 0 ] && return
	echo -n "final preparation of backup... "
	echo "--> xtrabackup --prepare --use-memory=${prepare_memory}K --target-dir=$target/full" >> $logfile 
	xtrabackup --prepare --use-memory=${prepare_memory}K --target-dir=$target/full >> $logfile 2>&1
	status=$?
	echo
	[ $status -ne 0 ] && return
	tail -1 $logfile | fgrep -q "completed OK"
	status=$?
	mv $target/full/* $target/
	rmdir $target/full
	if [ $status -eq 0 -a $point_in_time -eq 1 ]
	then
		bxfolder=$target/.backupmanager
		apply_binlogs || exit 1
	        echo "Done applying binary logs."
	fi
}

perform_zsnapshot_restore()
{
	snap_t=$(stat -Lc %m $target)
	if [ "$(df -t zfs $snap_t 2>/dev/null)" = "" ]
	then
		echo "ERROR: restoring a snapshot requires that target dir is on a ZFS filesystem. Exiting."
		clean_exit 1
	fi
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	echo -n "restoring full snapshot $uuid... "
	eval $reader | $unencryptor 2>/dev/null | $uncompressor | zfs recv -u ${target:1} 2>$aux_log
	if [ $? -ne 0 ]
	then
		echo
		echo "ERROR: zfs receiver failed! Exiting."
		cat $aux_log
		exit 1
	else
		echo -n " OK "
	fi
	current_position $uuid
	binlogs_starting_point=$uuid
	if [ "$requested_binlog_ts" != "" ]
	then
		this_binlog_ts=$(echo "select binlog_last_ts from backup_history where uuid = '$uuid';" | dbquery $DB)
		[ "$this_binlog_ts" = "$requested_binlog_ts" ] && restore_incr=0 || restore_incr=1
	else
		restore_incr=1
	fi
	if [ $restore_incr -eq 1 ]
	then
		for id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and backup_tool = '$tool' and status = 0 order by start_time asc;" | dbquery $DB)
		do
			if [ $point_in_time -eq 1 ]
			then
				this_binlog_ts=$(echo "select binlog_last_ts from backup_history where uuid = '$id';" | dbquery $DB)
				[ "$this_binlog_ts" = "$requested_binlog_ts" ] && break
			fi
		done
		path=$(echo "select bulocation from backup_history where uuid = '$id';" | dbquery $DB)
		key=$(echo "select cryptkey from backup_history where uuid = '$id';" | dbquery $DB)
		[ "$key" != "" ] && export enc_key="$key"
		echo -n "restoring incremental snapshot $id... "
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | zfs recv -u ${target:1} 2>$aux_log
		if [ $? -ne 0 ]
		then
			echo
			echo "ERROR: zfs receiver failed! Exiting."
			cat $aux_log
			exit 1
		else
			echo -n " OK "
			current_position $id
			binlogs_starting_point=$id
		fi
	fi
	zfs mount ${target:1}
	echo "Restore complete, datadir restored to $target."
}

state_update()
{
	echo "$1" > /tmp/bm_restore_state_$target_host
}

perform_maria_restore()
{
	mb_ver=$($ssh mariabackup --version 2>&1 | sed -re "s/(.*)server (.[0-9])\.([0-9])(.*)/\2.\3/")
	[ "$mb_ver" = "10.1" ] && mb_all="--apply-log-only" || mb_all=""
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$backup_path" != "" ] && path=$backup_path/$(echo $path | sed -re "s/^(.*)\/([0-9-]*)\/(.*)\/(.*)$/\2\/\3\/\4/")
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	[ "$key" != "" ] && export enc_key="$key"
	rm -f /tmp/xtrabackup*
	find_util mariabackup
	if [ "$util" = "" ]
	then
		find_util mariadb-backup
	fi
	mariabackup=$util
	find_util mbstream
	mbstream=$util
	state_update "extracting full backup $uuid"
	if [ "$target" != "-" ]
	then
		echo -n "extracting full backup $uuid... "
		$ssh mkdir -p $target/full
		echo "--> eval $reader | $unencryptor | $uncompressor | $ssh $mbstream -p $parallelism -x -v -C $target/full" >> $logfile
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | $ssh $mbstream -p $parallelism -x -v -C $target/full 2>> $logfile
	else
		eval $reader | $unencryptor 2>/dev/null | $uncompressor 2>> $logfile
		status=$?
		return
	fi
	status=$?
	echo
	[ $status -ne 0 ] && return
	open_files_limit
	echo -n "applying redo logs for $uuid... "
	echo "--> $ssh $mariabackup --prepare $mb_all $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full" >> $logfile
	state_update "preparing full backup $uuid"
	$ssh $mariabackup --prepare $mb_all $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full >> $logfile 2>&1
	status=$?
	echo
	[ $status -ne 0 ] && return
	tail -1 $logfile | fgrep -q "completed OK"
	status=$?
	[ $status -ne 0 ] && return
	current_position $uuid
	binlogs_starting_point=$uuid
	for id in $(echo "select uuid from backup_history where ref_full_backup = '$uuid' and backup_tool = '$tool' and status = 0 order by start_time asc;" | dbquery $DB)
	do
		incr_check_position $id && break
		path=$(echo "select bulocation from backup_history where uuid = '$id';" | dbquery $DB)
		[ "$backup_path" != "" ] && path=$backup_path/$(echo $path | sed -re "s/^(.*)\/([0-9-]*)\/(.*)\/(.*)$/\2\/\3\/\4/")
		key=$(echo "select cryptkey from backup_history where uuid = '$id';" | dbquery $DB)
		[ "$key" != "" ] && export enc_key="$key"
		incdir=$(basename $path)
		echo -n "extracting incremental backup $id... "
		$ssh mkdir -p $target/$incdir
		rm -f /tmp/xtrabackup*
		state_update "extracting incremental backup $id"
		echo "--> eval $reader | $unencryptor | $uncompressor | $ssh $mbstream -p $parallelism -x -v -C $target/$incdir" >> $logfile
		eval $reader | $unencryptor 2>/dev/null | $uncompressor | $ssh $mbstream -p $parallelism -x -v -C $target/$incdir 2>> $logfile
		status=$?
		echo
		[ $status -ne 0 ] && break
		echo -n "applying redo logs for $id... "
		state_update "preparing incremental backup $id"
		echo "--> $ssh $mariabackup --prepare $mb_all $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full --incremental-dir=$target/$incdir" >> $logfile
		$ssh $mariabackup --prepare $mb_all $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full --incremental-dir=$target/$incdir >> $logfile 2>&1
		status=$?
		echo
		[ $status -ne 0 ] && break
		tail -1 $logfile | fgrep -q "completed OK"
		status=$?
		[ $status -ne 0 ] && break
		current_position $id
		binlogs_starting_point=$id
		$ssh rm -rf $target/$incdir
	done
	[ $status -ne 0 ] && return
	echo -n "Finalizing backup... "
	state_update "finalizing restore"
	echo "--> $ssh $mariabackup --prepare $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full" >> $logfile 
	$ssh $mariabackup --prepare $limit_str --use-memory=${prepare_memory}K --target-dir=$target/full >> $logfile 2>&1
	status=$?
	echo
	[ $status -ne 0 ] && return
	tail -1 $logfile | fgrep -q "completed OK"
	status=$?
	$ssh mv $target/full/* $target/
	$ssh rmdir $target/full
	if [ $status -eq 0 -a $point_in_time -eq 1 ]
	then
		[ "$backup_path" = "" ] && bxfolder=$target/.backupmanager || bxfolder=$backup_path/.backupmanager
		[ "$BM_BINLOG_PATH" != "" ] && bxfolder=$BM_BINLOG_PATH/.backupmanager
		apply_binlogs || exit 1
	        echo "Done applying binary logs."
	fi
	state_update "restore completed"
}

perform_mariaunpacked_restore()
{
	find_util rsync
	if [ "$util" = "" ]
	then
		echo "ERROR: Please install rsync first."
		clean_exit 1
	else
		rsync=$util
	fi
	path=$(echo "select bulocation from backup_history where uuid = '$uuid';" | dbquery $DB)
	key=$(echo "select cryptkey from backup_history where uuid = '$uuid';" | dbquery $DB)
	$rsync -a $path/* $target/
	if [ $? -ne 0 ]
	then
		echo "ERROR:copying backup to $target failed."
		clean_exit 1
	fi
	if [ $point_in_time -eq 1 ]
	then
		current_position $uuid
		binlogs_starting_point=$uuid
		bxfolder=$target/.backupmanager
		apply_binlogs || exit 1
	        echo "Done applying binary logs."
	else
		echo "The data at $target is ready for use."
	fi
	status=0
}

ssh_setup()
{
	if [ ! -f $HOME/.ssh/id_rsa.pub ]
	then
		ssh-keygen -q -t rsa -b 2048 -f $HOME/.ssh/id_rsa -N ''
		if [ $? -ne 0 ]
		then
			echo "error setting up public/private key pair. Exiting."
			exit 1
		fi
	fi
	ssh -oPasswordAuthentication=no -q $1 true
	if [ $? -ne 0 ]
	then
		echo "*** Setting up ssh"
		echo "Setting up public/private key authentication. Please enter $targethost password."
		cat $HOME/.ssh/id_rsa.pub | ssh -tq $1 "mkdir .ssh 2>/dev/null; chmod 755 .ssh; cat >> .ssh/authorized_keys; chmod 644 .ssh/authorized_keys"
		if [ $? -ne 0 ]
		then
			echo "error setting up public/private key pair. Exiting."
			rm -rf $HOME/.ssh/id_rsa*
			exit 1
		fi
	fi
	ssh -q $1 true
	if [ $? -ne 0 ]
	then
		echo "ssh connection to $1 was not successful. Exiting."
		exit 1
	fi
}

replication_credentials()
{
	get_repl_creds
}

pit_xid()
{
	replication_credentials
	[ "$repl_user" = "" ] && return
	build_master_cmd
	target_gtid=$(which_gtid)
	[ $target_gtid -eq 0 ] && return
	for binlog in $(echo "show binary logs" | $master_cmd 2>/dev/null | cut -f 1 | sort -r)
	do
		gtid=$(echo "show binlog events in '$binlog' limit 5" | $master_cmd 2>/dev/null | fgrep -v Gtid_list | fgrep Gtid | cut -f 6 | cut -d" " -f 3 | cut -d"-" -f 3)
		[ "$gtid" = "" ] && break
		if [ $target_gtid -ge $gtid ]
		then
			target_binlog=$binlog
			break
		fi
	done
	[ "$target_binlog" = "" ] && return
        pos=$(echo "show binlog events in '$target_binlog'" | $master_cmd 2>/dev/null | grep -E -- "GTID\ ([0-9]*)-([0-9]*)-$target_gtid($| )" | cut -f 2)
	[ "$pos" = "" ] && return
	xid=$(echo "show binlog events in '$target_binlog' from $pos" | $master_cmd 2>/dev/null | fgrep -m 1 COMMIT | sed -re "s/^(.*)\ xid=([0-9]*)\ (.*)/\2/")
	if [ "$xid" !=  "" ]
	then
		echo "update backup_history set xid = $xid  where uuid = '$backup_id';" | dbquery $DB
		echo "Great! Xid $xid for galera master decoupling has been retrieved and saved to inventory."
	fi
}

disk_space()
{
	[ ! -d $target ] && return
	disk_space_avail=$(df -h $target |  tail -1 | tr -s " " "\t" | cut -f 4)
	disk_space_avail_k=$(df -k $target |  tail -1 | tr -s " " "\t" | cut -f 4)
	disk_space_p_used=$(df -h $target |  tail -1 | tr -s " " "\t" | cut -f 5 | tr -d "%")
	disk_space_p_avail=$((100-disk_space_p_used))
}

check_slave_status()
{
	[ "$password" != "" ] && pass_str="-p$password"
	[ "$socket" != "" ] && sock_str="-S$socket"
	if [ "$hb_schema" != "" -a "$hb_table" != "" -a "$hb_stale_secs" != "" ]
	then
		hb_delay=$(echo "select timestampdiff(second, ts, now()) from $hb_schema.$hb_table order by ts desc limit 1" | mysql -ANr -u $user $sock_str $pass_str)
		if [ "$hb_delay" = "" ]
		then
			true
		else
			[ $hb_delay -ge $hb_stale_secs ]
		fi
	else
		echo "show slave status\G" | mysql -Ar -u $user $sock_str $pass_str | grep -P "Slave_(.*)_Running:" | egrep -q "No|Connecting"
	fi
	if [ $? -eq 0 ]
	then
		msg="ERROR: replication is broken, will not backup stale data. Exiting."
		echo $msg
		[ "$tool" = "binlogs" ] && exit 1
		[ "$failure_notify" != "" ] && echo $msg | send_mail "$customer: backup FAILED" $failure_notify
		status=1; fire_webhook
		exit 1
	fi
}

get_lsn()
{
	lsn=$(fgrep last_lsn $target/checkpoints/$tool/xtrabackup_checkpoints 2>/dev/null | tr -d " " | cut -d"=" -f 2)
}

build_config()
{
	if [ $(id -u) -ne 0 ]
	then
		CONFIGFILE=$HOME/$CONFIGNAME
	else
		[ ! -d $CONFIGDIR ] && mkdir $CONFIGDIR
	fi
	if [ -f $CONFIGFILE ]
	then
		echo "$CONFIGFILE already exists, will not overwrite."
		exit 1
	fi
	base64 -d << DOC_EOF | gzip -dc | sed -e "s/\$VERSION/v$BM_VERSION/" > $CONFIGFILE
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
45+OXr/+N+keomRFFwAA
DOC_EOF

	echo "Created $CONFIGFILE. Please adjust it for your setup." 
	exit 0
}

check_server_path()
{
	while true
	do
		$ssh [ -f $server_path ] && return
		echo "ERROR: could not find MariaDB server executable '$server_path'!"
		echo -n "Please enter its location on this system (including filename): "
		read server_path
	done
}

mariadb_instance()
{
	case "$1" in
		'start')
			check_server_path
			echo -n "starting MariaDB auxiliary instance on $target... "
			$local_remote "echo 'server_id=987654321' >> $target/backup-my.cnf"
			$local_remote "echo 'lower_case_table_names=$case_insens' >> $target/backup-my.cnf"
			$ssh $server_path --defaults-file=$target/backup-my.cnf  --innodb_file_per_table  --skip-grant-tables --basedir=/usr --datadir=$target --plugin-dir=/usr/lib64/mysql/plugin --user=root --log-error=$target/backup_manager_mysqld.err $limit_str --pid-file=$target/mysql.pid --socket=/tmp/backup_manager.sock --port=65432 2>> /tmp/backup_manager_mysqld.err &
			sleep 10
			instance=$($ssh cat $target/mysql.pid 2>/dev/null)
			[ "$instance" = "" ] && return 1
			echo "(pid $instance)"
			$ssh kill -0 $instance 2>/dev/null
			return $?
			;;
                'stop') echo "stopping MariaDB auxiliary instance"
			$ssh kill $instance
			;;
	esac
}

dim_prepare_memory()
{
        avail=$($ssh grep ^MemTotal  /proc/meminfo | sed -re "s/^MemTotal:(\s*)([0-9]*) kB/\2/")
        prepare_memory=$((avail/4))
}

run_purge_backups()
{
	purge_backups $*
}

show_logs()
{
	logfile=$(echo "select logfile from backup_history where uuid = '$1';" | dbquery $DB)
	if [ "$logfile" = "" ]
	then
		echo "backup with id '$1' not found."
		exit 1
	fi
	[ "$(which less 2>/dev/null)" != "" ] && pager="less" || pager="more"
	if [ "$(which fuser 2>/dev/null)" != "" ]
	then
        	fuser -s $logfile && tail -f $logfile || $pager $logfile
	else
        	echo -e "  loading logfile into pager, please wait... \r\c"
		$pager $logfile
	fi
}

build_binlog_list()
{
	ena=0
	binlog_list=""
	for binlog in $(ls ${binlog_base}* | grep -v index)
	do
		[ "${binlog##*/}" \> "$binlog_start" -o "${binlog##*/}" = "$binlog_start" ] && ena=1
		[ $ena -eq 0 ] && continue
		binlog_list="$binlog_list ${binlog##*/}"
	done
	binlog_list=$(echo $binlog_list | sed -e "s/${binlog##*/}//")
	if [ "${binlog_list## }" = "" ]
	then
		echo "No binary logs needing backup."
		clean_exit 0
	fi
}

position_from_binlog()
{
	cat $1 | $ssh $mysqlbinlog --no-defaults --skip-annotate-row-events --base64-output=NEVER - | fgrep -v Warning | fgrep -C10 -m1 "Start: binlog" > $aux_log
	lb_ts=$(grep "GTID " $aux_log | sed -re "s/^#([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)([0-9]+)\s+([0-9 ]*):([0-9]*):([0-9]*) server (.*)$/20\1\2-\3\4-\5\6 \7:\8:\9/" -e "s/( )([0-9]:)/ 0\2/")
	[ "$lb_ts" = "" ] && lb_ts=$(grep "created " $aux_log | sed -re "s/^#([0-9][0-9])([0-9][0-9])([0-9][0-9])(\s*)([0-9]*):([0-9]*):([0-9]*)\s(.*)$/20\1-\2-\3 \5:\6:\7/" -e "s/( )([0-9]:)/ 0\2/")
        binlog_pos=$(grep "^# at " $aux_log | head -1 | sed -re "s/^# at ([0-9]*)/\1/")
	gtid_binlog_pos=$(cat $aux_log | tr -d "\n" | tr -d "#" | sed -re "s/(.*)\[(.*)\](.*)/\2/")
}

setup_replication()
{
	setup_repl_only=1
	build_slave $1 $2
}

get_replication_info()
{
	replication_info $1
}

safe_defaults
if [ "$1" = "debug" ]
then
	while true
	do
		sleep 10
	done
	exit 1
fi
[ "$1" = "build-config" ] && build_config
check_home_config
if [ ! -f $CONFIGFILE ]
then
	[ $# -eq 0 ] && self_doc
	echo "$CONFIGFILE not found. You can build it with: $0 build-config."
	[ $(id -u) -ne 0 ] && echo "Since you are not running as root, it will be created in your home directory."
	exit 1
fi
[ "$1" = "help" ] && self_doc
parse_config $*
setup_db
case "$1" in
	'backup') 	
		disk_space
		do_backup $2 $3 $4 $5
		exit $status
		;;
	'restore') 	
		do_restore $2 "$3" "$4" "$5"
		;;
	'remote-restore') 	
		do_remote_restore $2 "$3" "$4" "$5"
		;;
	'inventory'|'inv'|'list') 
		disk_space
		inventory $2 $3 $4
		;;
	'purge') 
		run_purge_backups $2
		;;
	'logs') 
		show_logs $2
		;;
	'build-slave') 
		build_slave $2 $3
		;;
	'print-latest') 
		print_latest
		;;
	'print-latest-id') 
		print_latest_id
		;;
	'replication-info') 
		get_replication_info $2
		;;
	'backup-type') 
		backup_type $2
		;;
	'backup-time') 
		backup_time $2
		;;
	'backup-size') 
		backup_size $2
		;;
	'validate-pit') 
		pit_dry_run $2 "$3"
		;;
	'setup-replication') 
		setup_replication $2 $3 
		;;
	'version') 
		echo $BM_VERSION
		;;
	'help')
		;;
	*) 
		[ "$1" = "" ] && self_doc || echo "$0: unkown option $1"; exit 1
		;;
esac
exit 0
